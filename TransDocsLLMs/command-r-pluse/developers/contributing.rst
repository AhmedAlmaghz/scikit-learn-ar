.. _contributing:

المساهمة
============

.. currentmodule:: sklearn

هذا المشروع هو جهد مجتمعي، والجميع مرحب به للمساهمة فيه. يستضيف المشروع على https://github.com/scikit-learn/scikit-learn.
وتتم مناقشة عملية صنع القرار وهيكل إدارة المشروع في :ref:`governance`.

Scikit-learn هو مشروع :ref:`selective <selectiveness>` عندما يتعلق الأمر
بإضافة خوارزميات جديدة، وأفضل طريقة للمساهمة ومساعدة المشروع
هي البدء بالعمل على القضايا المعروفة.
راجع :ref:`new_contributors` للبدء.

.. topic:: **مجتمعنا، قيمنا**

    نحن مجتمع قائم على الانفتاح والمناقشات الودية والتعليمية.

    نسعى إلى معاملة الجميع على قدم المساواة، وتقدير مساهماتهم. نحن
    نسعى بشكل خاص إلى مشاركة الأشخاص من الخلفيات الممثلة تمثيلا ناقصا في مجال البرمجيات مفتوحة المصدر وفي scikit-learn على وجه الخصوص للمشاركة والمساهمة بخبراتهم وتجاربهم.

    تتخذ القرارات على أساس الجدارة التقنية وتوافق الآراء.

    المساهمة في المشروع لا تقتصر على كتابة الأكواد. مراجعة طلبات السحب، والرد على الاستفسارات لمساعدة الآخرين في قوائم البريد أو
    القضايا، وتنظيم وتدريس البرامج التعليمية، والعمل على الموقع الإلكتروني، وتحسين الوثائق، كلها مساهمات لا تقدر بثمن.

    نلتزم بمبادئ الانفتاح والاحترام ومراعاة الآخرين لمؤسسة برمجيات Python:
    https://www.python.org/psf/codeofconduct/


في حال واجهتك مشكلات في استخدام هذه الحزمة، لا تتردد في إرسال تذكرة إلى
`تتبع مشكلات GitHub
<https://github.com/scikit-learn/scikit-learn/issues>`_. أنت أيضًا
مرحب بك في نشر طلبات الميزات أو طلبات السحب.

طرق المساهمة
==================

هناك العديد من الطرق للمساهمة في scikit-learn، وأكثرها شيوعًا هي المساهمة في الأكواد أو الوثائق في المشروع. إن تحسين الوثائق لا يقل أهمية عن تحسين المكتبة نفسها. إذا
وجدت خطأ إملائيًا في الوثائق، أو قمت بإجراء تحسينات، فلا تتردد في
إرسال بريد إلكتروني إلى قائمة البريد أو يفضل تقديم طلب سحب على GitHub.
يمكن العثور على الوثائق الكاملة في دليل doc/.

ولكن هناك العديد من الطرق الأخرى للمساعدة. على وجه الخصوص، فإن المساعدة في
:ref:`تحسين وتقييم والتحقيق في القضايا <bug_triaging>` و
:ref:`مراجعة طلبات السحب من المطورين الآخرين <code_review>` هي مساهمات
مهمة جدًا تقلل من العبء على مسؤولي المشروع.

طريقة أخرى للمساهمة هي الإبلاغ عن المشكلات التي تواجهها، وإعطاء "إعجاب"
بالقضايا التي أبلغ عنها الآخرون والتي لها صلة بك. كما يساعدنا أيضًا إذا قمت بنشر المشروع: قم بالرجوع إليه من مدونتك ومقالاتك، واربطه بموقعك على الويب، أو قم ببساطة بالضغط على زر النجمة للإشارة إلى أنك تستخدمه:

.. raw:: html

  <p>
    <object
      data="https://img.shields.io/github/stars/scikit-learn/scikit-learn?style=for-the-badge&logo=github"
      type="image/svg+xml">
    </object>
  </p>

في حال تضمنت المساهمة/المشكلة تغييرات على مبادئ واجهة برمجة التطبيقات
أو تغييرات على التبعيات أو الإصدارات المدعومة، فيجب أن تكون مدعومة من قبل
:ref:`slep`، حيث يجب تقديم اقتراح تحسين Scikit-learn (SLEP) كطلب سحب إلى
`مقترحات التحسين <https://scikit-learn-enhancement-proposals.readthedocs.io>`_
باستخدام `قالب SLEP <https://scikit-learn-enhancement-proposals.readthedocs.io/en/latest/slep_template.html>`_
ويتبع عملية صنع القرار المحددة في :ref:`governance`.

.. dropdown:: المساهمة في المشاريع ذات الصلة

  تزدهر Scikit-learn في نظام بيئي يتضمن العديد من المشاريع ذات الصلة، والتي قد يكون لها أيضًا قضايا ذات صلة للعمل عليها، بما في ذلك المشاريع الأصغر مثل:

  * `scikit-learn-contrib <https://github.com/search?q=org%3Ascikit-learn-contrib+is%3Aissue+is%3Aopen+sort%3Aupdated-desc&type=Issues>`__
  * `joblib <https://github.com/joblib/joblib/issues>`__
  * `sphinx-gallery <https://github.com/sphinx-gallery/sphinx-gallery/issues>`__
  * `numpydoc <https://github.com/numpy/numpydoc/issues>`__
  * `liac-arff <https://github.com/renatopp/liac-arff/issues>`__

  والمشاريع الأكبر:

  * `numpy <https://github.com/numpy/numpy/issues>`__
  * `scipy <https://github.com/scipy/scipy/issues>`__
  * `matplotlib <https://github.com/matplotlib/matplotlib/issues>`__
  * وهكذا.

  ابحث عن القضايا التي تحمل علامة "مطلوب المساعدة" أو ما شابه ذلك. قد تساعد هذه المشاريع أيضًا
  scikit-learn. راجع أيضًا :ref:`related_projects`.

سياسة المساهمات الآلية
==============================

يرجى الامتناع عن تقديم المشكلات أو طلبات السحب التي تم إنشاؤها بواسطة
أدوات آلية بالكامل. يحتفظ المسؤولون بالحق، وفقًا لتقديرهم الخاص،
بإغلاق مثل هذه التقديمات وحظر أي حساب مسؤول عنها.

من الناحية المثالية، يجب أن تتبع المساهمات من مناقشة إنسان إلى إنسان في
شكل قضية.

تقديم تقرير عن خطأ أو طلب ميزة
============================================

نحن نستخدم قضايا GitHub لتتبع جميع الأخطاء وطلبات الميزات؛ لا تتردد في فتح
قضية إذا كنت قد وجدت خطأ أو ترغب في رؤية ميزة يتم تنفيذها.

في حال واجهتك مشكلات في استخدام هذه الحزمة، لا تتردد في إرسال تذكرة إلى
`تتبع الأخطاء <https://github.com/scikit-learn/scikit-learn/issues>`_. أنت أيضًا
مرحب بك في نشر طلبات الميزات أو طلبات السحب.

من المستحسن التحقق من امتثال قضيتك للقواعد
التالية قبل تقديمها:

-  التحقق من أن قضيتك لا يتم معالجتها حاليًا بواسطة قضايا أو
   `طلبات سحب <https://github.com/scikit-learn/scikit-learn/pulls?q=>`_ أخرى.

-  إذا كنت تقدم خوارزمية أو طلب ميزة، يرجى التحقق من أن الخوارزمية تفي بمتطلباتنا
   `متطلبات الخوارزمية الجديدة
   <https://scikit-learn.org/stable/faq.html#what-are-the-inclusion-criteria-for-new-algorithms>`_.

-  إذا كنت تقدم تقريرًا عن خطأ، فنحن نشجعك بشدة على اتباع الإرشادات في
   :ref:`filing_bugs`.

.. _filing_bugs:

كيفية كتابة تقرير جيد عن الأخطاء
-----------------------------

عند تقديم قضية إلى `GitHub
<https://github.com/scikit-learn/scikit-learn/issues>`__، يرجى بذل قصارى جهدك
للاتباع هذه الإرشادات! سيسهل ذلك علينا كثيرًا تقديم تعليقات مفيدة لك:

- تقرير الخطأ المثالي يحتوي على :ref:`شريحة قابلة للتكرار <minimal_reproducer>`، بهذه الطريقة يمكن لأي شخص أن يحاول بسهولة إعادة إنتاج الخطأ. إذا كانت شريحتك أطول من حوالي 50 سطرًا، فيرجى الرابط إلى `Gist
  <https://gist.github.com>`_ أو مستودع GitHub.

- إذا لم يكن من الممكن تضمين شريحة قابلة للتكرار، فيرجى التحديد بالتفصيل
  **المقدرات و/أو الوظائف المعنية وشكل البيانات**.

- إذا تم رفع استثناء، يرجى **توفير تتبع الاستثناء الكامل**.

- يرجى تضمين **نوع نظام التشغيل وإصداره**، بالإضافة إلى
  **إصدارات Python وscikit-learn وnumpy وscipy**. يمكن العثور على هذه المعلومات
  عن طريق تشغيل:

  .. prompt:: bash

    python -c "import sklearn; sklearn.show_versions()"

- يرجى التأكد من تنسيق **جميع شفرات البرنامج ورسائل الخطأ في كتل الأكواد المناسبة**.  راجع `إنشاء وتسليط الضوء على كتل الأكواد
  <https://help.github.com/articles/creating-and-highlighting-code-blocks>`_
  لمزيد من التفاصيل.

إذا كنت تريد المساعدة في تنظيم القضايا، فاقرأ عن :ref:`bug_triaging`.

المساهمة بالشيفرة
ملاحظة
--------

للتأكد من عدم تكرار العمل، يُنصح بشدة بالبحث في `قائمة المشكلات <https://github.com/scikit-learn/scikit-learn/issues>`_ و `قائمة طلبات السحب <https://github.com/scikit-learn/scikit-learn/pulls>`_. إذا كنت غير متأكد من تكرار العمل، أو إذا كنت تريد العمل على ميزة غير بسيطة، فيُنصح أولاً بفتح مشكلة في `قائمة المشكلات <https://github.com/scikit-learn/scikit-learn/issues>`_ للحصول على بعض التعليقات من المطورين الأساسيين.

تتمثل إحدى الطرق السهلة للعثور على مشكلة للعمل عليها في استخدام تسمية "help wanted" في بحثك. ستظهر لك قائمة بجميع المشكلات التي لم يتم المطالبة بها حتى الآن. وللمطالبة بمشكلة لنفسك، يرجى التعليق بـ ``/take`` بالضبط عليها حتى يتمكن CI من تعيين المشكلة لك تلقائيًا.

للحفاظ على جودة قاعدة التعليمات البرمجية وتسهيل عملية المراجعة، يجب أن يتوافق أي مساهمة مع `المبادئ التوجيهية للترميز <https://scikit-learn.org/dev/developers/contributing.html#coding-guidelines>`_ الخاصة بالمشروع، وخاصة:

- لا تعدل السطور غير ذات الصلة للحفاظ على تركيز طلب السحب على النطاق المحدد في الوصف أو المشكلة.
- اكتب التعليقات التوضيحية فقط التي تضيف قيمة وتجنب ذكر البديهيات: اشرح "السبب" بدلاً من "ماذا".
- **الأهم من ذلك**: لا تساهم بالرمز الذي لا تفهمه.

الموارد المرئية
---------------
هذه مقاطع فيديو توضح خطوة بخطوة كيفية المساهمة في
scikit-learn، وهي رفيق رائع للمبادئ التوجيهية النصية التالية.
يرجى التأكد من مراجعة مبادئنا التوجيهية أدناه، لأنها تصف أحدث سير عمل محدث.

- دورة مكثفة في المساهمة في Scikit-Learn ومشاريع المصادر المفتوحة:
  `فيديو <https://youtu.be/5OL8XoMMOfA>`__،
  `نسخة مكتوبة <https://github.com/data-umbrella/event-transcripts/blob/main/2020/05-andreas-mueller-contributing.md>`__

- مثال على تقديم طلب سحب إلى scikit-learn:
  `فيديو <https://youtu.be/PU1WyDPGePI>`__،
  `نسخة مكتوبة <https://github.com/data-umbrella/event-transcripts/blob/main/2020/06-reshama-shaikh-sklearn-pr.md>`__

- تعليمات خاصة بالسباقات ونصائح عملية:
  `فيديو <https://youtu.be/p_2Uw2BxdhA>`__،
  `نسخة مكتوبة <https://github.com/data-umbrella/data-umbrella-scikit-learn-sprint/blob/master/3_transcript_ACM_video_vol2.md>`__

- 3 مكونات مراجعة طلب السحب:
  `فيديو <https://youtu.be/dyxS9KKCNzA>`__،
  `نسخة مكتوبة <https://github.com/data-umbrella/event-transcripts/blob/main/2021/27-thomas-pr.md>`__

.. note::
  في يناير 2021، تم تغيير اسم الفرع الافتراضي من ``master`` إلى ``main``
  لمستودع GitHub الخاص بـ scikit-learn لاستخدام مصطلحات أكثر شمولاً.
  تم إنشاء هذه الفيديوهات قبل إعادة تسمية الفرع.
  بالنسبة للمساهمين الذين يشاهدون هذه الفيديوهات لإعداد بيئة عملهم وإرسال طلب سحب، يجب استبدال ``master`` بـ ``main``.

كيفية المساهمة
-----------------

الطريقة المفضلة للمساهمة في scikit-learn هي إنشاء نسخة من `المستودع الرئيسي <https://github.com/scikit-learn/scikit-learn/>`__ على GitHub،
ثم تقديم "طلب سحب" (PR).

في الخطوات القليلة الأولى، نشرح كيفية تثبيت scikit-learn محليًا، وكيفية إعداد مستودع Git الخاص بك:

1. `أنشئ حسابًا <https://github.com/join>`_ على
   GitHub إذا لم يكن لديك واحد بالفعل.

2. أنشئ نسخة من `مستودع المشروع <https://github.com/scikit-learn/scikit-learn>`__: انقر على زر "Fork"
   بالقرب من أعلى الصفحة. سيؤدي هذا إلى إنشاء نسخة من التعليمات البرمجية تحت حسابك على
   حساب مستخدم GitHub. لمزيد من التفاصيل حول كيفية إنشاء نسخة من مستودع، راجع `هذا الدليل <https://help.github.com/articles/fork-a-repo/>`_.

3. استنسخ نسخة من مستودع scikit-learn من حسابك على GitHub إلى القرص المحلي:

   .. prompt:: bash

      git clone git@github.com:YourLogin/scikit-learn.git  # add --depth 1 if your connection is slow
      cd scikit-learn

4. اتبع الخطوات من 2 إلى 6 في :ref:`install_bleeding_edge` لبناء scikit-learn في
   وضع التطوير والعودة إلى هذه الوثيقة.

5. قم بتثبيت التبعيات الخاصة بالتطوير:

   .. prompt:: bash

        pip install pytest pytest-cov ruff mypy numpydoc black==24.3.0

.. _upstream:

6. أضف المستودع البعيد ``upstream``. سيحفظ هذا مرجعًا للمستودع الرئيسي لـ scikit-learn، والذي يمكنك استخدامه لإبقاء مستودعك متزامنًا مع أحدث التغييرات:

   .. prompt:: bash

        git remote add upstream git@github.com:scikit-learn/scikit-learn.git

7. تحقق من أن أسماء المستودعات البعيدة ``upstream`` و ``origin`` تم تكوينها بشكل صحيح
   عن طريق تشغيل ``git remote -v`` الذي يجب أن يعرض:

   .. code-block:: text

        origin	git@github.com:YourLogin/scikit-learn.git (fetch)
        origin	git@github.com:YourLogin/scikit-learn.git (push)
        upstream	git@github.com:scikit-learn/scikit-learn.git (fetch)
        upstream	git@github.com:scikit-learn/scikit-learn.git (push)

يجب أن يكون لديك الآن تثبيتًا عاملًا لـ scikit-learn، ومستودع Git الخاص بك
مُهيأ بشكل صحيح. قد يكون من المفيد تشغيل بعض الاختبارات للتحقق من تثبيتك.
يرجى الرجوع إلى :ref:`pytest_tips` للحصول على أمثلة.

تصف الخطوات التالية عملية تعديل التعليمات البرمجية وتقديم طلب سحب:

8. قم بمزامنة فرع ``main`` الخاص بك مع فرع ``upstream/main``،
   للمزيد من التفاصيل راجع `وثائق GitHub <https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork>`_:

   .. prompt:: bash

        git checkout main
        git fetch upstream
        git merge upstream/main

9. قم بإنشاء فرع ميزة للاحتفاظ بتغييرات التطوير الخاصة بك:

   .. prompt:: bash

        git checkout -b my_feature

   وبدء إجراء التغييرات. استخدم دائمًا فرع ميزة. من الممارسات الجيدة ألا تعمل أبدًا على الفرع ``main``!

10. (**اختياري**) قم بتثبيت `pre-commit <https://pre-commit.com/#install>`_ لتشغيل
    فحوصات نمط التعليمات البرمجية قبل كل ارتكاب:

    .. prompt:: bash

          pip install pre-commit
          pre-commit install

    يمكن تعطيل فحوصات pre-commit لالتزام معين باستخدام
    ``git commit -n``.

11. قم بتطوير الميزة على فرع الميزة على جهاز الكمبيوتر الخاص بك، باستخدام Git للتحكم في الإصدار. عندما تنتهي من التحرير، أضف الملفات المعدلة باستخدام
    ``git add`` ثم ``git commit``:

    .. prompt:: bash

        git add modified_files
        git commit

    لتسجيل تغييراتك في Git، ثم أرسل التغييرات إلى حسابك على GitHub باستخدام:

    .. prompt:: bash

       git push -u origin my_feature

12. اتبع `هذه
    <https://help.github.com/articles/creating-a-pull-request-from-a-fork>`_
    التعليمات لإنشاء طلب سحب من نسختك. سيؤدي هذا إلى إرسال
    بريد إلكتروني إلى الملتزمين. قد ترغب في النظر في إرسال بريد إلكتروني إلى قائمة البريد للحصول على مزيد من الرؤية.

غالبًا ما يكون من المفيد الحفاظ على مزامنة فرع الميزة المحلية الخاص بك مع
أحدث التغييرات في مستودع scikit-learn الرئيسي:

.. prompt:: bash

    git fetch upstream
    git merge upstream/main

بعد ذلك، قد تحتاج إلى حل التعارضات. يمكنك الرجوع إلى
`توثيق Git المتعلق بحل تعارض الاندماج باستخدام سطر الأوامر
<https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/>`_.

.. topic:: تعلم Git

    تعد `وثائق Git <https://git-scm.com/documentation>`_ و
    http://try.github.io موارد ممتازة للبدء باستخدام Git،
    وفهم جميع الأوامر الموضحة هنا.

.. _pr_checklist:

قائمة مراجعة طلب السحب
قبل دمج طلب سحب (PR)، يجب أن يوافق عليه مطوران أساسيان. يجب وضع علامة على المساهمة غير المكتملة - حيث تتوقع إجراء المزيد من العمل قبل تلقي مراجعة كاملة - على أنها "مسودة طلب سحب" وتغييرها إلى "جاهزة للمراجعة" عند اكتمالها. قد تكون مسودات طلبات السحب مفيدة للإشارة إلى أنك تعمل على شيء ما لتجنب ازدواجية العمل، أو لطلب مراجعة واسعة لوظيفة أو واجهة برمجة تطبيقات (API)، أو للبحث عن متعاونين. غالبًا ما تستفيد مسودات طلبات السحب من تضمين "قائمة مهام" في وصف طلب السحب.

ولتسهيل عملية المراجعة، نوصي بأن تمتثل مساهمتك للقواعد التالية قبل وضع علامة "جاهز للمراجعة" على طلب السحب. القواعد **المكتوبة بخط عريض** مهمة بشكل خاص:

1. **أعط طلب السحب الخاص بك عنوانًا مفيدًا** يلخص ما تفعله مساهمتك. غالبًا ما يصبح هذا العنوان رسالة الالتزام بمجرد دمجها، لذا يجب أن يلخص مساهمتك للمستقبل. في بعض الحالات، يكون "إصلاح <عنوان المشكلة>" كافيًا. "إصلاح #<رقم المشكلة>" ليس أبدًا عنوانًا جيدًا.

2. **تأكد من اجتياز رمزك للاختبارات**. يمكن تشغيل جناح الاختبار بالكامل باستخدام pytest، ولكن لا يوصى بذلك عادةً لأنه يستغرق وقتًا طويلاً. غالبًا ما يكون من الكافي تشغيل الاختبار المتعلق بالتغييرات الخاصة بك فقط: على سبيل المثال، إذا قمت بتغيير شيء ما في sklearn/linear_model/_logistic.py، فإن تشغيل الأوامر التالية سيكون كافيًا عادةً:

   - pytest sklearn/linear_model/_logistic.py للتأكد من صحة أمثلة doctest
   - pytest sklearn/linear_model/tests/test_logistic.py لتشغيل الاختبارات المحددة للملف
   - pytest sklearn/linear_model لاختبار وحدة :mod: sklearn.linear_model بأكملها
   - pytest doc/modules/linear_model.rst للتأكد من صحة أمثلة دليل المستخدم.
   - pytest sklearn/tests/test_common.py -k LogisticRegression لتشغيل جميع فحوصاتنا للمقدّر (تحديدًا لـ LogisticRegression، إذا كان هذا هو المقدّر الذي قمت بتغييره).

   قد تكون هناك اختبارات فاشلة أخرى، ولكن سيتم اكتشافها بواسطة CI، لذلك لا تحتاج إلى تشغيل جناح الاختبار بالكامل محليًا. للحصول على إرشادات حول كيفية استخدام pytest بكفاءة، راجع :ref: pytest_tips.

3. **تأكد من التعليق على رمزك وتوثيقه بشكل صحيح**، **وتأكد من عرض الوثائق بشكل صحيح**. لبناء الوثائق، يرجى الرجوع إلى إرشاداتنا :ref: contribute_documentation. سيقوم CI أيضًا ببناء المستندات: يرجى الرجوع إلى :ref: generated_doc_CI.

4. **الاختبارات ضرورية لقبول التحسينات**. يجب توفير الإصلاحات العاجلة أو الميزات الجديدة مع "اختبارات عدم التراجع". تتحقق هذه الاختبارات من السلوك الصحيح للإصلاح أو الميزة. بهذه الطريقة، يُضمن أن تكون التعديلات الإضافية على قاعدة الكود متسقة مع السلوك المرغوب. في حالة الإصلاحات العاجلة، يجب أن تفشل اختبارات عدم التراجع وقت طلب السحب، بالنسبة لقاعدة الكود في الفرع "الرئيسي"، وتمريرها لرمز طلب السحب.

5. اتبع :ref: coding-guidelines.

6. عند الاقتضاء، استخدم أدوات البرامج النصية للتحقق في وحدة sklearn.utils. يمكن العثور على قائمة روتينات المساعدة المتاحة للمطورين في صفحة :ref: developers-utils.

7. غالبًا ما تحل طلبات السحب مشكلة واحدة أو أكثر (أو طلبات سحب). إذا كان دمج طلب السحب الخاص بك يعني أنه يجب إغلاق بعض القضايا/طلبات السحب الأخرى، فيجب عليك "استخدام كلمات رئيسية لإنشاء رابط إليها" (على سبيل المثال، "إصلاحات #1234"؛ يُسمح بعدد من القضايا/طلبات السحب طالما يسبق كل منها كلمة رئيسية). عند الدمج، سيتم إغلاق هذه القضايا/طلبات السحب تلقائيًا بواسطة GitHub. إذا كان طلب السحب الخاص بك مرتبطًا فقط ببعض القضايا/طلبات السحب الأخرى، أو إذا كان يحل الهدف المستهدف جزئيًا فقط، فقم بإنشاء رابط إليها دون استخدام الكلمات الرئيسية (على سبيل المثال، "نحو #1234").

8. يجب أن تبرر طلبات السحب غالبًا التغيير، من خلال معايير الأداء والكفاءة (راجع :ref: monitoring_performances) أو من خلال أمثلة الاستخدام. توضح الأمثلة أيضًا ميزات المكتبة ودقائقها للمستخدمين. الق نظرة على الأمثلة الأخرى في الدليل "الأمثلة/" للرجوع إليها. يجب أن توضح الأمثلة سبب كون الوظيفة الجديدة مفيدة في الممارسة العملية، وإذا أمكن، قم بمقارنتها بالطرق الأخرى المتاحة في مجموعة أدوات التعلم.

9. تفرض الميزات الجديدة بعض النفقات العامة للصيانة. نتوقع من مؤلفي طلبات السحب المشاركة في صيانة الكود الذي يقدمونه، على الأقل في البداية. يجب توضيح الميزات الجديدة بوثائق سردية في دليل المستخدم، مع مقتطفات صغيرة من التعليمات البرمجية. إذا كان ذلك مناسبًا، يرجى أيضًا إضافة مراجع في الأدبيات، مع روابط PDF عند الإمكان.

10. يجب أن يتضمن دليل المستخدم أيضًا التعقيد الزمني والمكاني المتوقع للخوارزمية وقابليتها للتطوير، على سبيل المثال، "يمكن أن يتوسع هذا الخوارزم في عدد كبير من العينات > 100000، ولكنه لا يتوسع في الأبعاد: من المتوقع أن يكون n_features أقل من 100".

يمكنك أيضًا التحقق من :ref: code_review لدينا لمعرفة ما يمكن أن يتوقعه المراجعون.

يمكنك التحقق من أخطاء البرمجة الشائعة باستخدام الأدوات التالية:

* الكود مع تغطية جيدة لاختبارات الوحدة (80% على الأقل، والأفضل 100%)، والتحقق باستخدام:

  .. prompt:: bash

    pip install pytest pytest-cov
    pytest --cov sklearn path/to/tests

  راجع أيضًا :ref: testing_coverage.

* قم بتشغيل التحليل الثابت باستخدام mypy:

  .. prompt:: bash

      mypy sklearn

  يجب ألا ينتج هذا أخطاء جديدة في طلب السحب الخاص بك. يمكن أن يكون استخدام التعليق # type: ignore حلًا مؤقتًا لبعض الحالات التي لا تدعمها mypy، خاصةً:

  - عند استيراد الوحدات النمطية C أو Cython،
  - على الخصائص مع الديكورات.

نقاط المكافأة للمساهمات التي تتضمن تحليل الأداء باستخدام نص برمجي للمقارنة ومخرجات التوصيف (راجع :ref: monitoring_performances). تحقق أيضًا من دليل :ref: performance-howto للحصول على مزيد من التفاصيل حول التوصيف وتحسينات Cython.

.. note::

  الحالة الحالية لقاعدة كود scikit-learn لا تمتثل لجميع هذه الإرشادات، ولكننا نتوقع أن يؤدي فرض هذه القيود على جميع المساهمات الجديدة إلى تحسين جودة قاعدة الكود بشكل عام.

.. seealso::

   للحصول على دليلين موثقين جيدًا ومفصلين بشكل أكبر حول سير عمل التطوير، يرجى زيارة قسم "سير عمل تطوير Scipy" <http://scipy.github.io/devdocs/dev/dev_quickstart.html> - وقسم "سير عمل Astropy للمطورين" <https://astropy.readthedocs.io/en/latest/development/workflow/development_workflow.html>.

التكامل المستمر (CI)
---------------------------

* تُستخدم خطوط أنابيب Azure لاختبار scikit-learn على Linux وMac وWindows، باستخدام تبعيات وإعدادات مختلفة.
* يستخدم CircleCI لبناء المستندات لعرضها.
* تُستخدم إجراءات GitHub لمهام مختلفة، بما في ذلك بناء العجلات والتوزيعات المصدرية.
* يستخدم Cirrus CI للبناء على ARM.

.. _commit_markers:

مؤشرات رسالة الالتزام
^^^^^^^^^^^^^^^^^^^^^^

يرجى ملاحظة أنه إذا ظهر أحد المؤشرات التالية في رسالة الالتزام الأخيرة، فسيتم اتخاذ الإجراءات التالية.

====================== ===================
مؤشر رسالة الالتزام  الإجراء المتخذ من قبل CI
====================== ===================
[ci skip]              يتم تخطي CI تمامًا
[cd build]             يتم تشغيل CD (يتم بناء العجلات والتوزيعات المصدرية)
[cd build gh]          يتم تشغيل CD فقط لإجراءات GitHub
[cd build cirrus]      يتم تشغيل CD فقط لـ Cirrus CI
[lint skip]            تخطي فحص النحو في خط أنابيب Azure
[scipy-dev]            البناء والاختبار باستخدام إصدارات التطوير من التبعيات (numpy وscipy، وما إلى ذلك).
[free-threaded]        البناء والاختبار باستخدام CPython 3.13 خيوط مجانية
[pyodide]              البناء والاختبار باستخدام Pyodide
[azure parallel]       تشغيل وظائف CI الموازية في Azure
[cirrus arm]           تشغيل اختبار Cirrus CI ARM
[float32]              تشغيل اختبارات float32 عن طريق تعيين SKLEARN_RUN_FLOAT32_TESTS=1. راجع :ref: environment_variable لمزيد من التفاصيل
[doc skip]             لا يتم بناء المستندات
[doc quick]            يتم بناء المستندات، ولكن يتم استبعاد مخططات معرض الأمثلة
[doc build]            يتم بناء المستندات بما في ذلك مخططات معرض الأمثلة (طويلة جدًا)
====================== ===================

يرجى ملاحظة أنه، بشكل افتراضي، يتم بناء الوثائق ولكن يتم تنفيذ الأمثلة التي يتم تعديلها مباشرة بواسطة طلب السحب فقط.

ملفات القفل
^^^^^^^^^^

تستخدم CI ملفات القفل لبناء البيئات بإصدارات محددة من التبعيات. عندما يحتاج طلب السحب إلى تعديل التبعيات أو إصداراتها، يجب تحديث ملفات القفل وفقًا لذلك. يمكن القيام بذلك عن طريق التعليق في طلب السحب:

.. code-block:: text

  @scikit-learn-bot update lock-files

سيقوم بوت بالدفع بالتزام إلى فرع طلب السحب الخاص بك بملفات القفل المحدثة في غضون دقائق قليلة. تأكد من تحديد خانة الاختيار "السماح بالتحرير من قبل المشرفين" الموجودة في أسفل الجانب الأيمن من طلب السحب. يمكنك أيضًا تحديد خيارات --select-build و--skip-build و--select-tag كما هو الحال في سطر الأوامر. استخدم --help في البرنامج النصي build_tools/update_environments_and_lock_files.py لمزيد من المعلومات. على سبيل المثال،

.. code-block:: text

  @scikit-learn-bot update lock-files --select-tag main-ci --skip-build doc

سيضيف البوت تلقائيًا :ref: commit message markers <commit_markers> إلى الالتزام لبعض العلامات. إذا كنت تريد إضافة المزيد من العلامات يدويًا، فيمكنك القيام بذلك باستخدام الخيار --commit-marker. على سبيل المثال، سيؤدي التعليق التالي إلى تشغيل البوت لتحديث ملفات القفل المتعلقة بالوثائق وإضافة العلامة "[doc build]" إلى الالتزام:

.. code-block:: text

  @scikit-learn-bot update lock-files --select-build doc --commit-marker "[doc build]"

.. _stalled_pull_request:

طلبات السحب المتوقفة
---------------------

نظرًا لأن المساهمة بميزة يمكن أن تكون عملية طويلة، فإن بعض طلبات السحب تبدو غير نشطة ولكنها غير مكتملة. في مثل هذه الحالة، فإن الاستيلاء عليها يعد خدمة رائعة للمشروع. تعد قواعد السلوك الجيدة للاستيلاء على ما يلي:

* **تحديد ما إذا كان طلب السحب متوقفًا**

  * قد يكون لطلب السحب علامة "متوقف" أو "مطلوب المساعدة" إذا كنا قد حددناه بالفعل كمرشح لمساهمين آخرين.

  * لتحديد ما إذا كان طلب السحب غير النشط متوقفًا، اسأل المساهم عما إذا كان/كانت تخطط لمواصلة العمل على طلب السحب في المستقبل القريب. عدم الرد خلال أسبوعين مع نشاط يدفع طلب السحب للأمام يشير إلى أن طلب السحب متوقف وسيؤدي إلى وضع علامة "مطلوب المساعدة" على طلب السحب.

    يرجى ملاحظة أنه إذا تلقى طلب السحب تعليقات على المساهمة لم يتم الرد عليها لمدة شهر، فمن الآمن افتراض أن طلب السحب متوقف ويمكن تقليل وقت الانتظار إلى يوم واحد.

    بعد سبرينت، سيتم التواصل مع المشاركين في سبرينت لمتابعة طلبات السحب غير المندمجة المفتوحة أثناء سبرينت، وسيتم وضع علامة "سبرينت" على طلبات السحب هذه. يمكن إعادة تعيين طلبات السحب التي تحمل علامة "سبرينت" أو إعلانها متوقفة من قبل قادة سبرينت.

* **الاستيلاء على طلب سحب متوقف**: من المهم التعليق على طلب السحب المتوقف للإشارة إلى أنك تستولي عليه ولإنشاء رابط من طلب السحب الجديد إلى القديم. يجب إنشاء طلب السحب الجديد عن طريق السحب من القديم.
بشكل عام، ستكون القضايا التي يمكن العمل عليها لها علامة "مساعدة مطلوبة". ومع ذلك، لن يكون لدى جميع القضايا التي تحتاج إلى مساهمين هذه العلامة، حيث أن علامة "مساعدة مطلوبة" ليست دائمًا محدثة مع حالة القضية. يمكن للمساهمين العثور على القضايا التي لا تزال متاحة من خلال اتباع الإرشادات التالية:

* أولاً، لتحديد ما إذا كانت القضية قد تم المطالبة بها:

  * التحقق من طلبات السحب المرتبطة
  * التحقق من المحادثة لمعرفة ما إذا كان أي شخص قد ذكر أنه يعمل على إنشاء طلب سحب

* إذا علق أحد المساهمين على قضية ليقول إنه يعمل عليها، فمن المتوقع تقديم طلب سحب خلال أسبوعين (لمساهم جديد) أو 4 أسابيع (لمساهم أو مطور أساسي)، ما لم يتم منح إطار زمني أكبر بشكل صريح. بعد ذلك الوقت، يمكن لمساهم آخر أخذ القضية وتقديم طلب سحب لها. نشجع المساهمين على التعليق مباشرة على القضية المتوقفة أو غير المطالب بها لإبلاغ أعضاء المجتمع بأنهم سيعملون عليها.

* إذا كانت القضية مرتبطة بـ "طلب سحب متوقف"، فإننا نوصي بأن يتبع المساهمون الإجراء الموصوف في قسم "طلب السحب المتوقف" بدلاً من العمل مباشرة على القضية.

.. _new_contributors:

القضايا للمساهمين الجدد
---------------------------

ينبغي على المساهمين الجدد البحث عن العلامات التالية عند البحث عن القضايا. نوصي بشدة بأن يتناول المساهمون الجدد القضايا "السهلة" أولاً: يساعد هذا المساهم على التعرف على سير عمل المساهمة، وعلى المطورين الأساسيين التعرف على المساهم؛ بالإضافة إلى ذلك، فإننا غالبًا ما نقلل من مدى سهولة حل مشكلة ما!

- **علامة Good first issue**

  هناك طريقة رائعة للبدء في المساهمة في scikit-learn وهي اختيار عنصر من قائمة "good first issues" في متتبع القضايا. يسمح حل هذه القضايا بالبدء في المساهمة في المشروع دون معرفة مسبقة كثيرة. إذا كنت قد ساهمت بالفعل في scikit-learn، فيجب عليك النظر في القضايا السهلة بدلاً من ذلك.

- **علامة Easy**

  إذا كنت قد ساهمت بالفعل في scikit-learn، فهناك طريقة رائعة أخرى للمساهمة في scikit-learn وهي اختيار عنصر من قائمة "Easy issues" في متتبع القضايا. ستكون مساعدتك في هذا المجال موضع تقدير كبير من قبل المطورين الأكثر خبرة حيث تساعدهم على تحرير وقتهم للتركيز على قضايا أخرى.

- **علامة Help wanted**

  غالبًا ما نستخدم علامة "مساعدة مطلوبة" لوضع علامة على القضايا بغض النظر عن صعوبتها. بالإضافة إلى ذلك، نستخدم علامة "مساعدة مطلوبة" لوضع علامة على طلبات السحب التي تم التخلي عنها من قبل المساهم الأصلي وهي متاحة لشخص ما لمتابعة المكان الذي توقف فيه المساهم الأصلي. يمكن العثور على قائمة القضايا التي تحتوي على علامة "مساعدة مطلوبة" هنا. لاحظ أن ليس كل القضايا التي تحتاج إلى مساهمين سيكون لها هذه العلامة.

.. _contribute_documentation:

الوثائق
يسعدنا قبول أي نوع من أنواع الوثائق:

* **توثيق الدوال/الطرق/الصفوف**: المعروف أيضًا باسم "توثيق واجهة برمجة التطبيقات"، يصف هذا النوع ما تقوم به الكائنات وتفاصيل أي معلمات أو سمات أو طرق. وتعيش وثائق التوثيق هذه جنبًا إلى جنب مع الكود في sklearn/ <https://github.com/scikit-learn/scikit-learn/tree/main/sklearn> _، ويتم إنشاؤها وفقًا لـ doc/api_reference.py <https://github.com/scikit-learn/scikit-learn/blob/main/doc/api_reference.py> _. للقيام بإضافة أو تحديث أو إزالة أو إيقاف استخدام واجهة برمجة تطبيقات عامة مدرجة في: ref: api_ref، فهذا هو المكان الذي يجب البحث فيه.

* **دليل المستخدم**: توفر هذه الوثائق معلومات أكثر تفصيلاً حول الخوارزميات المنفذة في سكيت-ليرن وعادة ما توجد في دليل الجذر doc/ <https://github.com/scikit-learn/scikit-learn/tree/main/doc> _ و doc/modules/ <https://github.com/scikit-learn/scikit-learn/tree/main/doc/modules> _.

* **الأمثلة**: توفر هذه الوثائق أمثلة كاملة للكود والتي قد توضح استخدام وحدات سكيت-ليرن، أو تقارن خوارزميات مختلفة، أو تناقش تفسيرها، وما إلى ذلك. ويمكن العثور على الأمثلة في examples/ <https://github.com/scikit-learn/scikit-learn/tree/main/examples> _.

* **وثائق ReStructuredText الأخرى**: توفر هذه الوثائق معلومات مفيدة مختلفة (مثل: ref: contributing guide) وتوجد في doc/ <https://github.com/scikit-learn/scikit-learn/tree/main/doc> _.

.. dropdown:: المبادئ التوجيهية لكتابة وثائق التوثيق

  * عند توثيق المعلمات والسمات، إليك قائمة ببعض الأمثلة ذات التنسيق الجيد:

    .. code-block:: text

      n_clusters : int, default=3
          عدد المجموعات التي يكتشفها الخوارزم.

      some_param : {"hello", "goodbye"}, bool or int, default=True
          يذهب وصف المعلمة هنا، والذي يمكن أن يكون إما سلسلة نصية
          (إما "hello" أو "goodbye")، أو قيمة منطقية، أو عدد صحيح. والقيمة
          الافتراضية هي True.

      array_parameter : {array-like, sparse matrix} of shape (n_samples, n_features) \
          or (n_samples,)
          تقبل هذه المعلمة البيانات بأي من الأشكال المذكورة، مع أحد
          الأشكال المذكورة. والقيمة الافتراضية هي np.ones(shape=(n_samples,)).

      list_param : list of int

      typed_ndarray : ndarray of shape (n_samples,), dtype=np.int32

      sample_weight : array-like of shape (n_samples,), default=None

      multioutput_array : ndarray of shape (n_samples, n_classes) or list of such arrays

    بشكل عام، ضع في اعتبارك ما يلي:

    * استخدم الأنواع الأساسية في بايثون. (bool بدلاً من boolean)
    * استخدم الأقواس لتعريف الأشكال: array-like of shape (n_samples,)
      أو array-like of shape (n_samples, n_features)
    * بالنسبة للسلاسل النصية مع خيارات متعددة، استخدم الأقواس المجعدة: input: {'log',
      'squared', 'multinomial'}
    * يمكن أن تكون البيانات أحادية أو ثنائية الأبعاد مجموعة فرعية من {array-like,
      ndarray, sparse matrix, dataframe}. لاحظ أن "array-like" يمكن أن تكون أيضًا
      "list"، في حين أن "ndarray" هي صراحةً "numpy.ndarray".
    * حدد "dataframe" عند استخدام ميزات "frame-like"، مثل أسماء الأعمدة.
    * عند تحديد نوع البيانات لقائمة، استخدم "of" كفاصل: list of int. وعند دعم
      المعلمة للمصفوفات، يمكنك إعطاء تفاصيل حول الشكل و/أو نوع البيانات وقائمة
      من هذه المصفوفات، ويمكنك استخدام أحد الخيارات التالية: array-like of shape
      (n_samples,) or list of such arrays.
    * عند تحديد نوع البيانات لـ "ndarray"، استخدم np.int32 لتحديد الشكل:
      ndarray of shape (n_samples,), dtype=np.int32. يمكنك تحديد أنواع بيانات
      متعددة كمجموعة: array-like of shape (n_samples,), dtype={np.float64,
      np.float32}. إذا كنت تريد ذكر الدقة العشوائية، استخدم "integral" و
      "floating" بدلاً من أنواع البيانات في بايثون "int" و "float". وعندما يكون
      كلا الخيارين "int" و "floating" مدعومين، لا توجد حاجة لتحديد نوع البيانات.
    * عندما تكون القيمة الافتراضية هي "None"، يجب تحديد "None" فقط في النهاية
      باستخدام default=None. تأكد من تضمين ما يعنيه أن تكون المعلمة أو السمة
      "None" في وثائق التوثيق.

  * أضف "انظر أيضًا" في وثائق التوثيق للصفوف/الدوال ذات الصلة.

  * يجب أن يكون "انظر أيضًا" في وثائق التوثيق عبارة عن سطر واحد لكل مرجع، مع
    علامة استعمار وفسرير، على سبيل المثال:

    .. code-block:: text

      انظر أيضًا
      --------
      SelectKBest : حدد الميزات بناءً على أعلى k نقاط.
      SelectFpr : حدد الميزات بناءً على اختبار معدل الإيجابيات الخاطئة.

  * أضف مقتطف أو اثنين من الكود في قسم "مثال" لإظهار كيفية استخدامه.

.. dropdown:: المبادئ التوجيهية لكتابة دليل المستخدم ووثائق ReStructuredText الأخرى

  من المهم الحفاظ على حل وسط جيد بين التفاصيل الرياضية والخوارزمية، وإعطاء
    الحدس للقارئ حول ما يفعله الخوارزم.

  * ابدأ بشرح موجز وواضح لما يفعله الخوارزم/الكود بالبيانات.

  * أبرز فائدة الميزة وتطبيقها الموصى به. ضع في اعتبارك تضمين تعقيد الخوارزمية
    (:math:`O\left(g\left(n\right)\right)`) إذا كان متاحًا، حيث يمكن أن تكون
    "قواعد الإبهام" خاصة جدًا بالآلة. فقط إذا كانت هذه التعقيدات غير متاحة،
    فيمكن حينها توفير "قواعد الإبهام" بدلاً من ذلك.

  * أدرج صورة ذات صلة (تم إنشاؤها من مثال) لتوفير حدس.

  * أدرج مثال أو مثالين قصيرين من الكود لتوضيح استخدام الميزة.

  * قدم أي معادلات رياضية ضرورية، تليها المراجع. من خلال تأجيل الجوانب
    الرياضية، تصبح الوثائق أكثر سهولة للوصول إليها من قبل المستخدمين
    المهتمين بشكل أساسي بفهم الآثار العملية للميزة بدلاً من آلياتها
    الأساسية.

  * عند تحرير ملفات ReStructuredText (".rst")، حاول الحفاظ على طول السطر أقل
    من 88 حرفًا عندما يكون ذلك ممكنًا (تعتبر الروابط والجداول استثناءات).

  * في ملفات ReStructuredText في سكيت-ليرن، يؤدي استخدام علامات الاقتباس
    الخلفية المفردة أو المزدوجة حول النص إلى عرضه كنص حرفي متداخل (يستخدم
    غالبًا للكود، على سبيل المثال، "list"). ويرجع ذلك إلى تكوينات محددة
    قمنا بضبطها. يجب استخدام علامات الاقتباس المفردة في الوقت الحالي.

  * تؤدي وفرة المعلومات إلى صعوبة وصول المستخدمين إلى المحتوى الذي يهمهم.
    استخدم قوائم التصفح لتصنيفها باستخدام بناء الجملة التالي:

    .. code-block:: rst

      .. dropdown:: عنوان قائمة التصفح

        محتوى قائمة التصفح.

    ستؤدي الشفرة القصيرة أعلاه إلى ظهور قائمة التصفح التالية:

    .. dropdown:: عنوان قائمة التصفح

      محتوى قائمة التصفح.

  * المعلومات التي يمكن إخفاؤها افتراضيًا باستخدام قوائم التصفح هي:

    * أقسام التسلسل الهرمي المنخفض مثل "المراجع" و "الخصائص"، وما إلى ذلك (راجع
      على سبيل المثال الأقسام الفرعية في: ref: det_curve)؛

    * التفاصيل الرياضية المعمقة؛

    * السرد القصصي المحدد للاستخدام؛

    * بشكل عام، السرد القصصي الذي قد يهم المستخدمين الذين يرغبون في تجاوز
      براغماتية أداة معينة.

  * لا تستخدم قوائم التصفح لقسم المستوى المنخفض "أمثلة"، حيث يجب أن يظل
    مرئيًا لجميع المستخدمين. تأكد من أن قسم "الأمثلة" يأتي مباشرة بعد
    المناقشة الرئيسية مع أقل عدد ممكن من الأقسام المطوية بينهما.

  * كن على دراية بأن قوائم التصفح تكسر المراجع المتقاطعة. إذا كان ذلك منطقيًا،
    فقم بإخفاء المرجع مع النص الذي يشير إليه. وإلا، فلا تستخدم قوائم التصفح.

.. dropdown:: المبادئ التوجيهية لكتابة المراجع

  * عندما تكون المراجع الببليوغرافية متاحة بأرقام تعريف "arxiv
    <https://arxiv.org/>" أو "Digital Object Identifier
    <https://www.doi.org/>"، استخدم توجيهات سفينكس: arxiv: أو: doi:. على سبيل
    المثال، راجع المراجع في: ref: spectral_clustering_graph.

  * بالنسبة لقسم "المراجع" في وثائق التوثيق، راجع: func:
    sklearn.metrics.silhouette_score كمثال.

  * للرجوع إلى صفحات أخرى في وثائق سكيت-ليرن، استخدم بناء جملة المراجع
    المتقاطعة ReStructuredText:

    * **القسم**: للرجوع إلى قسم عشوائي في الوثائق، استخدم تسميات المرجع (راجع
      "وثائق سفينكس
      <https://www.sphinx-doc.org/en/master/usage/restructuredtext/roles.html#ref-role>
      "). على سبيل المثال:

      .. code-block:: rst

          .. _my-section:

          My section
          ----------

          هذا هو نص القسم.

          للرجوع إلى نفسه، استخدم: ref: my-section.

      لا يجب عليك تعديل تسميات مرجع سفينكس الموجودة مسبقًا حيث أن ذلك قد
      يكسر المراجع المتقاطعة والروابط الخارجية الموجودة التي تشير إلى أقسام
      محددة في وثائق سكيت-ليرن.

    * **المسرد**: للرجوع إلى مصطلح في: ref: glossary:

      .. code-block:: rst

          :term:`cross_validation`

    * **الدالة**: للرجوع إلى وثائق دالة، استخدم مسار الاستيراد الكامل إلى
      الدالة:

      .. code-block:: rst

          :func:`~sklearn.model_selection.cross_val_score`

      ومع ذلك، إذا كان هناك توجيه ".. currentmodule::" أعلاه في المستند،
      فستحتاج فقط إلى استخدام المسار إلى الدالة بعد الوحدة الحالية المحددة.
      على سبيل المثال:

      .. code-block:: rst

          .. currentmodule:: sklearn.model_selection

          :func:`cross_val_score`

    * **الصف**: للرجوع إلى وثائق صف، استخدم مسار الاستيراد الكامل إلى الصف،
      ما لم يكن هناك توجيه ".. currentmodule::" في المستند أعلاه (راجع
      أعلاه):

      .. code-block:: rst

          :class:`~sklearn.preprocessing.StandardScaler`

يمكنك تحرير الوثائق باستخدام أي محرر نصوص، ثم إنشاء إخراج HTML باتباع: ref:
  building_documentation. سيتم وضع ملفات HTML الناتجة في "_build/html/" ويمكن
  عرضها في متصفح ويب، على سبيل المثال من خلال فتح الملف المحلي
  "_build/html/index.html" أو عن طريق تشغيل خادم محلي:

.. prompt:: bash

  python -m http.server -d _build/html


.. _building_documentation:

بناء الوثائق
**قبل إرسال طلب سحب، تحقق مما إذا كانت تعديلاتك قد أدخلت أي تحذيرات جديدة من Sphinx من خلال بناء الوثائق محليًا وحاول إصلاحها.**

أولاً، تأكد من أنك قمت بتثبيت نسخة التطوير :ref:`بشكل صحيح <install_bleeding_edge>`. بالإضافة إلى ذلك، يتطلب بناء الوثائق تثبيت بعض الحزم الإضافية:

..
    لا تكون الحزمة مطلوبة بمجرد أن تبدأ setuptools في شحن packaging>=17.0

.. prompt:: bash

    pip install sphinx sphinx-gallery numpydoc matplotlib Pillow pandas \
                polars scikit-image packaging seaborn sphinx-prompt \
                sphinxext-opengraph sphinx-copybutton plotly pooch \
                pydata-sphinx-theme sphinxcontrib-sass sphinx-design \
                sphinx-remove-toctrees

للبناء الوثائق، تحتاج إلى أن تكون في مجلد ``doc``:

.. prompt:: bash

    cd doc

في الغالبية العظمى من الحالات، تحتاج فقط إلى إنشاء موقع الويب الكامل،
بدون معرض الأمثلة:

.. prompt:: bash

    make

ستتم توليد الوثائق في دليل ``_build/html/stable``
ويمكن عرضها في مستعرض ويب، على سبيل المثال من خلال فتح ملف
``_build/html/stable/index.html`` المحلي.
لإنشاء معرض الأمثلة أيضًا، يمكنك استخدام:

.. prompt:: bash

    make html

سيؤدي هذا إلى تشغيل جميع الأمثلة، وهو ما يستغرق بعض الوقت. إذا كنت تريد فقط إنشاء بعض الأمثلة، وهو ما سيكون مفيدًا بشكل خاص إذا كنت تعدل عددًا قليلاً من الأمثلة، فيمكنك استخدام:

.. prompt:: bash

    EXAMPLES_PATTERN=your_regex_goes_here make html

قم بتعيين متغير البيئة `NO_MATHJAX=1` إذا كنت تنوي عرض الوثائق
في إعداد غير متصل بالإنترنت. لبناء دليل PDF، قم بتشغيل:

.. prompt:: bash

    make latexpdf

.. admonition:: إصدار Sphinx
   :class: تحذير

   في حين أننا نبذل قصارى جهدنا لبناء الوثائق في أكبر عدد ممكن
   من إصدارات Sphinx، فإن الإصدارات المختلفة تميل إلى
   التصرف بشكل مختلف قليلاً. للحصول على أفضل النتائج، يجب عليك
   استخدام نفس الإصدار الذي استخدمناه على CircleCI. انظر إلى هذا
   `بحث GitHub <https://github.com/search?q=repo%3Ascikit-learn%2Fscikit-learn+%2F%5C%2Fsphinx-%5B0-9.%5D%2B%2F+path%3Abuild_tools%2Fcircle%2Fdoc_linux-64_conda.lock&type=code>`_
   لمعرفة الإصدار الدقيق.


.. _generated_doc_CI:

الوثائق المولدة على GitHub Actions
-----------------------------------------

عندما تقوم بتغيير الوثائق في طلب سحب، فإن GitHub Actions يقوم تلقائيًا
ببنائها. لعرض الوثائق التي تم إنشاؤها بواسطة GitHub Actions، انتقل ببساطة إلى
أسفل صفحة طلب السحب الخاص بك، وابحث عن العنصر "تحقق من الوثائق المعروضة هنا!" وانقر فوق "التفاصيل" بجانبه:

.. image:: ../images/generated-doc-ci.png
   :align: center

.. _testing_coverage:

الاختبار وتحسين تغطية الاختبار
يعد إجراء اختبارات الوحدات عالية الجودة ركنًا أساسيًا في عملية تطوير سكيت-ليرن. ولهذا الغرض، نستخدم حزمة "باي تيست". وتكون الاختبارات عبارة عن وظائف مسماة بشكل مناسب، وموجودة في مجلدات "الاختبارات" الفرعية، والتي تتحقق من صحة الخوارزميات والخيارات المختلفة للكود.

ويؤدي تشغيل "باي تيست" في مجلد ما إلى تشغيل جميع اختبارات الحزم الفرعية المقابلة. وللحصول على سير عمل أكثر تفصيلاً لـ "باي تيست"، يرجى الرجوع إلى: القائمة المرجعية لطلبات السحب.

نتوقع أن تكون تغطية الكود للميزات الجديدة حوالي 90% على الأقل.

اختبارات متعلقة بمكتبة ماتبلوتليب:
تضمن اختبارات التهيئة أن مجموعة من الاختبارات سيتم تنفيذها مع التهيئة والتنظيف المناسبين. وينفذ برنامج اختبار سكيت-ليرن مجموعة اختبارات "بايبلوت" التي يمكن استخدامها مع "ماتبلوتليب".

وينبغي استخدام مجموعة اختبارات "بايبلوت" عندما تتعامل وظيفة الاختبار مع "ماتبلوتليب". وتعد "ماتبلوتليب" اعتمادًا اختياريًا وليست مطلوبة. وتكون مجموعة الاختبارات هذه مسؤولة عن تخطي الاختبارات إذا لم يتم تثبيت "ماتبلوتليب". بالإضافة إلى ذلك، سيتم إغلاق الأشكال التي تم إنشاؤها أثناء الاختبارات تلقائيًا بمجرد تنفيذ وظيفة الاختبار.

ولاستخدام مجموعة الاختبارات هذه في وظيفة الاختبار، يجب تمريرها كحجة:

اختبار يتطلب مجموعة اختبارات ماتبلوتليب:

سير عمل لتحسين تغطية الاختبارات:
لاختبار تغطية الكود، تحتاج إلى تثبيت حزمة "كوفيراج" بالإضافة إلى "باي تيست".

1. قم بتشغيل الأمر "باي تيست --كوف سكيليرن /بات/تو/تستس". وتدرج النتيجة مخرجات لأرقام الأسطر غير المختبرة لكل ملف.

2. ابحث عن ثمرة سهلة المنال، من خلال النظر إلى أرقام الأسطر غير المختبرة، واكتب أو عدل الاختبار خصيصًا لهذه الأسطر.

3. كرر الخطوتين 1 و2 حتى تصل إلى مستوى التغطية المطلوب.

مراقبة الأداء:
عند اقتراح تغييرات على قاعدة الكود الحالية، من المهم التأكد من أنها لا تسبب تراجعًا في الأداء. ويستخدم سكيت-ليرن "معايير إيه إس في" لمراقبة أداء مجموعة مختارة من التقديرات والوظائف الشائعة. ويمكنك عرض هذه المعايير على صفحة معايير سكيت-ليرن. وتوجد مجموعة المعايير المقابلة في دليل "إيه إس في_بينشمارك".

ولاستخدام جميع ميزات "إيه إس في"، ستحتاج إلى إما "كوندا" أو "فيرتشوال إنف". لمزيد من التفاصيل، يرجى التحقق من صفحة تثبيت "إيه إس في".

أولاً، تحتاج إلى تثبيت الإصدار التنموي من "إيه إس في":

ثم انتقل إلى دليل "إيه إس في_بينشمارك":

تم تكوين مجموعة معايير الأداء للعمل مقابل النسخة المحلية المستنسخة من سكيت-ليرن. تأكد من أنها محدثة:

في مجموعة معايير الأداء، يتم تنظيم المعايير وفقًا لنفس هيكل سكيت-ليرن. على سبيل المثال، يمكنك مقارنة أداء مُقدر محدد بين "أبستريم/ماين" وفرع العمل الذي تقوم به:

يستخدم الأمر افتراضيًا برنامج "كوندا" لإنشاء بيئات معايير الأداء. إذا كنت تريد استخدام "فيرتشوال إنف" بدلاً من ذلك، استخدم العلم "-إي":

يمكنك أيضًا تحديد نموذج كامل لمعايرته:

يمكنك استبدال "هيد" بأي فرع محلي. وبشكل افتراضي، لن يبلغ سوى عن المعايير التي تغيرت بنسبة 10% على الأقل. يمكنك التحكم في هذه النسبة باستخدام العلم "-إف".

لتشغيل مجموعة معايير الأداء الكاملة، ما عليك سوى إزالة العلم "-بي":

ومع ذلك، يمكن أن يستغرق ذلك ما يصل إلى ساعتين. ويقبل العلم "-بي" أيضًا تعبيرًا منتظمًا لمجموعة فرعية أكثر تعقيدًا من معايير الأداء لتشغيلها.

لتشغيل معايير الأداء دون مقارنتها بفرع آخر، استخدم الأمر "ران":

يمكنك أيضًا تشغيل مجموعة معايير الأداء باستخدام إصدار سكيت-ليرن المثبت بالفعل في بيئة بايثون الحالية:

وهو مفيد بشكل خاص عندما قمت بتثبيت سكيت-ليرن في وضع التحرير لتجنب إنشاء بيئة جديدة في كل مرة تقوم فيها بتشغيل معايير الأداء. وبشكل افتراضي، لا يتم حفظ النتائج عند استخدام تثبيت موجود. لحفظ النتائج، يجب عليك تحديد هاش الالتزام:

يتم حفظ معايير الأداء وتنظيمها حسب الجهاز والبيئة والالتزام. لعرض قائمة بجميع معايير الأداء المحفوظة:

ولعرض تقرير تشغيل محدد:

عند تشغيل معايير الأداء لطلب سحب تعمل عليه، يرجى الإبلاغ عن النتائج على جيثب.

تدعم مجموعة معايير الأداء خيارات تكوين إضافية يمكن تعيينها في ملف تكوين "بينشمارك/كونفيج.جسون". على سبيل المثال، يمكن أن تعمل المعايير لمجموعة قيم مقدمة لمعلمة "إن_جوبس".

يمكن العثور على مزيد من المعلومات حول كيفية كتابة معيار أداء وكيفية استخدام "إيه إس في" في وثائق "إيه إس في".

علامات متعقب القضايا:
يجب أن تحتوي جميع القضايا وطلبات السحب على متعقب جيثب على (على الأقل) واحدة من العلامات التالية:

:باج:
يحدث شيء ما لا يجب أن يحدث بوضوح. تذهب النتائج الخاطئة بالإضافة إلى الأخطاء غير المتوقعة من التقديرات هنا.

:إنهانسمنت:
تحسين الأداء أو قابلية الاستخدام أو الاتساق.

:دوكومنتاشن:
وثائق أو أمثلة مفقودة أو غير صحيحة أو دون المستوى المطلوب.

:نيو فيتشر:
طلبات الميزات وطلبات السحب التي تنفذ ميزة جديدة.

هناك أربع علامات أخرى لمساعدة المساهمين الجدد:

:جود فيرست إيشو:
هذه القضية مثالية للمساهمة الأولى في سكيت-ليرن. اطلب المساعدة إذا كانت الصياغة غير واضحة. إذا كنت قد ساهمت بالفعل في سكيت-ليرن، فراجع القضايا السهلة بدلاً من ذلك.

:إيزي:
يمكن التعامل مع هذه القضية دون الكثير من الخبرة السابقة.

:موديرات:
قد تحتاج إلى بعض المعرفة بمجال التعلم الآلي أو الحزمة، ولكنها لا تزال في متناول شخص جديد للمشروع.

:هيلب وانتد:
هذه العلامة تحدد قضية تفتقر حاليًا إلى مساهم أو طلب سحب يحتاج إلى مساهم آخر لتولي العمل. ويمكن أن تتراوح هذه القضايا في الصعوبة، وقد لا تكون في متناول المساهمين الجدد. يرجى ملاحظة أن القضايا التي تحتاج إلى مساهمين لن يكون لها جميعها هذه العلامة.

التوافق مع الإصدارات السابقة:
بالتأكيد! فيما يلي ترجمة لنص ReStructuredText إلى اللغة العربية:

===================================

.. _contributing_deprecation:

إهمال الوظائف والخصائص
--------------------------

إذا تم إعادة تسمية أي فئة أو دالة أو طريقة أو خاصية أو معلمة يمكن الوصول إليها بشكل عام،
فإننا لا نزال ندعم الإصدار القديم لمدة إصدارين ونصدر تحذيرًا بالإهمال عند استدعائه أو تمريره أو الوصول إليه.

.. rubric:: إهمال فئة أو دالة

لنفترض أن الدالة ``zero_one`` أعيدت تسميتها إلى ``zero_one_loss``، فنضيف الزخرفة
:class: `utils.deprecated` إلى ``zero_one`` ونستدعي ``zero_one_loss`` من تلك
الدالة::

    from ..utils import deprecated

    def zero_one_loss(y_true, y_pred, normalize=True):
        # actual implementation
        pass

    @deprecated(
        "تمت إعادة تسمية الدالة `zero_one` إلى `zero_one_loss` في الإصدار 0.13 وسيتم
إزالتها في الإصدار 0.15. تم تغيير السلوك الافتراضي من `normalize=False` إلى
`normalize=True`"
    )
    def zero_one(y_true, y_pred, normalize=False):
        return zero_one_loss(y_true, y_pred, normalize)

يجب أيضًا نقل ``zero_one`` من ``API_REFERENCE`` إلى
``DEPRECATED_API_REFERENCE`` وإضافة ``zero_one_loss`` إلى ``API_REFERENCE`` في
ملف ``doc/api_reference.py`` ليعكس التغييرات في :ref: 'api_ref'.

.. rubric:: إهمال خاصية أو طريقة

إذا كان من المقرر إهمال خاصية أو طريقة، فيجب استخدام الزخرفة
:class: `~utils.deprecated` على الخاصية. يرجى ملاحظة أن
زخرفة :class: `~utils.deprecated` يجب أن توضع قبل زخرفة ``property``
إذا كان هناك واحد، بحيث يمكن عرض التوثيق بشكل صحيح. على سبيل المثال، يمكن إعادة تسمية
خاصية ``labels_`` إلى ``classes_`` كما يلي::

    @deprecated(
        "تم إهمال الخاصية `labels_` في الإصدار 0.13 وسيتم إزالتها في الإصدار 0.15. استخدم
`classes_` بدلاً من ذلك"
    )
    @property
    def labels_(self):
        return self.classes_

.. rubric:: إهمال معلمة

إذا كان يجب إهمال معلمة، فيجب رفع تحذير "FutureWarning"
يدويًا. في المثال التالي، يتم إهمال المعلمة ``k`` وتعاد تسميتها إلى ``n_clusters``::

    import warnings

    def example_function(n_clusters=8, k="deprecated"):
        if k != "deprecated":
            warnings.warn(
                "تمت إعادة تسمية `k` إلى `n_clusters` في الإصدار 0.13 وسيتم إزالتها في الإصدار 0.15"،
                FutureWarning،
            )
            n_clusters = k

عندما يكون التغيير في فئة، فإننا نتحقق من صحة ونرفع التحذير في ``fit``::

  import warnings

  class ExampleEstimator(BaseEstimator):
      def __init__(self, n_clusters=8, k='deprecated'):
          self.n_clusters = n_clusters
          self.k = k

      def fit(self, X, y):
          if self.k != "deprecated":
              warnings.warn(
                  "تمت إعادة تسمية `k` إلى `n_clusters` في الإصدار 0.13 وسيتم إزالتها في الإصدار 0.15.",
                  FutureWarning،
              )
              self._n_clusters = self.k
          else:
              self._n_clusters = self.n_clusters

كما هو الحال في هذه الأمثلة، يجب أن توفر رسالة التحذير دائمًا كل من
الإصدار الذي حدث فيه الإهمال والإصدار الذي سيتم إزالة السلوك القديم فيه. إذا حدث الإهمال
في الإصدار 0.x-dev، فيجب أن تشير الرسالة إلى أن الإهمال حدث في الإصدار 0.x وأن الإزالة ستكون
في 0. (x+2)، بحيث يكون لدى المستخدمين وقت كافٍ

لتكييف رمزها مع السلوك الجديد. على سبيل المثال، إذا حدث الإهمال
في الإصدار 0.18-dev، يجب أن تشير الرسالة إلى أنها حدثت في الإصدار 0.18
وسيتم إزالة السلوك القديم في الإصدار 0.20.

يجب أن تتضمن رسالة التحذير أيضًا تفسيرًا موجزًا للتغيير وتوجيه المستخدمين إلى بديل.

بالإضافة إلى ذلك، يجب إضافة ملاحظة حول الإهمال في التوثيق، مع تذكر
نفس المعلومات كما هو موضح أعلاه في تحذير الإهمال. استخدم التوجيه
``.. deprecated::``:

.. code-block:: rst

  .. deprecated:: 0.13
     تمت إعادة تسمية ``k`` إلى ``n_clusters`` في الإصدار 0.13 وسيتم إزالتها
     في الإصدار 0.15.

علاوة على ذلك، يتطلب الإهمال اختبارًا يضمن رفع التحذير في الحالات ذات الصلة ولكن ليس في الحالات الأخرى. يجب
التقاط التحذير في جميع الاختبارات الأخرى (باستخدام على سبيل المثال، ``@pytest.mark.filterwarnings``)،
وينبغي ألا يكون هناك أي تحذير في الأمثلة.


تغيير القيمة الافتراضية لمعلمة
---------------------------------------

إذا كان يجب تغيير القيمة الافتراضية لمعلمة، فيرجى استبدال
القيمة الافتراضية بقيمة محددة (على سبيل المثال، ``"warn"``) ورفع
``FutureWarning`` عندما يستخدم المستخدمون القيمة الافتراضية. يفترض المثال التالي
أن الإصدار الحالي هو 0.20 وأننا نغير القيمة الافتراضية لـ ``n_clusters`` من 5 (القيمة الافتراضية القديمة لـ 0.20) إلى 10
(القيمة الافتراضية الجديدة لـ 0.22)::

    import warnings

    def example_function(n_clusters="warn"):
        if n_clusters == "warn":
            warnings.warn(
                "ستتغير القيمة الافتراضية لـ `n_clusters` من 5 إلى 10 في الإصدار 0.22.",
                FutureWarning،
            )
            n_clusters = 5

عندما يكون التغيير في فئة، فإننا نتحقق من صحة ونرفع التحذير في ``fit``::

  import warnings

  class ExampleEstimator:
      def __init__(self, n_clusters="warn"):
          self.n_clusters = n_clusters

      def fit(self, X, y):
          if self.n_clusters == "warn":
              warnings.warn(
                  "ستتغير القيمة الافتراضية لـ `n_clusters` من 5 إلى 10 في الإصدار 0.22.",
                  FutureWarning،
              )
              self._n_clusters = 5

مثل حالات الإهمال، يجب أن توفر رسالة التحذير دائمًا كل من
الإصدار الذي حدث فيه التغيير والإصدار الذي سيتم إزالة السلوك القديم فيه.

يجب تحديث وصف المعلمة في التوثيق وفقًا لذلك عن طريق إضافة
توجيه ``versionchanged`` بالقيمة الافتراضية القديمة والجديدة، مع الإشارة إلى
الإصدار الذي سيكون التغيير فيه فعالاً:

.. code-block:: rst

    .. versionchanged:: 0.22
       ستتغير القيمة الافتراضية لـ `n_clusters` من 5 إلى 10 في الإصدار 0.22.

أخيرًا، نحتاج إلى اختبار يضمن رفع التحذير في الحالات ذات الصلة ولكن ليس في الحالات الأخرى. يجب
التقاط التحذير في جميع الاختبارات الأخرى
(باستخدام على سبيل المثال، ``@pytest.mark.filterwarnings``)،
وينبغي ألا يكون هناك أي تحذير في الأمثلة.

.. _code_review:

مبادئ توجيهية لمراجعة التعليمات البرمجية
======================

تعد مراجعة التعليمات البرمجية المساهمة في المشروع على شكل طلبات سحب (PRs) مكونًا أساسيًا
من تطوير Scikit-learn. نشجع أي شخص على بدء مراجعة تعليمات برمجية لمطورين آخرين. عملية مراجعة التعليمات البرمجية
مفيدة للغاية لكل من المشاركين. هذا مناسب بشكل خاص إذا كانت ميزة تود استخدامها، ويمكنك بالتالي الرد
بانتقاد ما إذا كان طلب السحب يلبي احتياجاتك. في حين
تحتاج كل عملية سحب إلى موافقة مطورين أساسيين، يمكنك تسريع
هذه العملية من خلال تقديم ملاحظاتك.

.. note::

  الفرق بين التحسين الموضوعي والتحسين الذاتي ليس
  دائمًا واضحًا. يجب على المراجعين أن يتذكروا أن مراجعة التعليمات البرمجية تتعلق بشكل أساسي
  تقليل المخاطر في المشروع. عند مراجعة التعليمات البرمجية، يجب أن تهدف إلى
  منع المواقف التي قد تتطلب إصلاح خطأ أو إهمال أو سحب. فيما يتعلق بالوثائق: الأخطاء المطبعية،
  مشكلات قواعد اللغة والتوضيحات من الأفضل معالجتها على الفور.

.. dropdown:: الجوانب المهمة التي يجب تغطيتها في أي مراجعة للتعليمات البرمجية

  فيما يلي بعض الجوانب المهمة التي يجب تغطيتها في أي مراجعة للتعليمات البرمجية،
  من الأسئلة رفيعة المستوى إلى قائمة مراجعة أكثر تفصيلاً.

  - هل نريدها في المكتبة؟ هل من المحتمل استخدامه؟ هل أنت،
    كمستخدم لـ Scikit-learn، تحب التغيير وتنوي استخدامه؟ هل هو في
    نطاق Scikit-learn؟ هل ستكون تكلفة الحفاظ على ميزة جديدة جديرة بالفوائد؟

  - هل التعليمات البرمجية متسقة مع واجهة برمجة التطبيقات (API) لـ Scikit-learn؟ هل
    الوظائف/الفئات/المعلمات العامة مسماة بشكل جيد ومصممة بشكل بديهي؟

  - هل جميع الوظائف/الفئات العامة ومعلماتها، وأنواع الإرجاع، و
    تم تسمية السمات المخزنة وفقًا لاتفاقيات Scikit-learn وتوثيقها بوضوح؟

  - هل يتم وصف أي وظائف جديدة في الدليل التوضيحي وتوضيحها بأمثلة؟

  - هل يتم اختبار كل وظيفة/فئة عامة؟ هل يتم اختبار مجموعة معقولة من
    المعلمات، وقيمها، وأنواع القيم، والمجموعات؟ هل
    الاختبارات تتحقق من أن التعليمات البرمجية صحيحة، أي أنها تفعل ما تقوله الوثائق؟ إذا كان التغيير هو إصلاح خطأ،
    هل تم تضمين اختبار عدم الرجوع؟ راجع هذا الرابط
    <https://jeffknupp.com/blog/2013/12/09/improve-your-python-understanding-unit-testing/> لمعرفة المزيد عن الاختبار في Python.

  - هل تجتاز الاختبارات في عملية البناء للتكامل المستمر؟ إذا
    كان ذلك مناسبًا، فساعد المساهم على فهم سبب فشل الاختبارات.

  - هل تغطي الاختبارات كل سطر من التعليمات البرمجية (راجع تقرير التغطية في سجل البناء)؟ إذا لم يكن كذلك،
    هل الأسطر المفقودة من التغطية استثناءات جيدة؟

  - هل التعليمات البرمجية سهلة القراءة وخالية من التكرار؟ هل يجب تحسين أسماء المتغيرات
    من أجل الوضوح أو الاتساق؟ هل يجب إضافة تعليقات؟ هل
    يجب إزالة التعليقات باعتبارها غير مفيدة أو غير ضرورية؟

  - هل يمكن إعادة كتابة التعليمات البرمجية بسهولة لتعمل بكفاءة أكبر
    للإعدادات ذات الصلة؟

  - هل التعليمات البرمجية متوافقة مع الإصدارات السابقة مع الإصدارات السابقة؟ (أو هل
    دورة الإهمال ضرورية؟)

  - هل ستضيف التعليمات البرمجية الجديدة أي تبعيات على المكتبات الأخرى؟ (هذا
    من غير المرجح أن يتم قبوله)

  - هل يتم عرض الوثائق بشكل صحيح (راجع القسم: ref: 'contribute_documentation' لمزيد من التفاصيل)، وهل الرسوم البيانية
    تعليمي؟

  :ref: 'saved_replies' يتضمن بعض التعليقات المتكررة التي قد يقدمها المراجعون.

.. _communication:

.. dropdown:: مبادئ توجيهية للتواصل

  تساعد مراجعة طلبات السحب المفتوحة (PRs) في المضي قدمًا بالمشروع. إنها طريقة رائعة
  للتعرف على قاعدة التعليمات البرمجية ويجب أن تحفز المساهم على الاستمرار في المشاركة في المشروع. [1]_

  - كل طلب سحب، جيدًا كان أم سيئًا، هو عمل من أعمال الكرم. بدءًا بتعليق إيجابي
    سيساعد المؤلف على الشعور بالمكافأة، وقد يتم سماع ملاحظاتك اللاحقة بشكل أوضح. قد تشعر أيضًا بالرضا.
  - ابدأ إذا أمكن مع القضايا واسعة النطاق، حتى يعرف المؤلف أنها تم
    فهمها. قاوم الرغبة في الذهاب على الفور سطرًا تلو الآخر، أو البدء في قضايا صغيرة شائعة.
  - لا تدع الكمال يكون عدو الجيد. إذا وجدت نفسك تقوم بذلك
    العديد من الاقتراحات الصغيرة التي لا تقع ضمن: ref: 'code_review'، فكر في
    النهج التالية:

    - الامتناع عن تقديم هذه الاقتراحات.
    - قم بوضع علامة عليها على أنها "Nit" حتى يعرف المساهم أنه من الجيد عدم معالجتها.
    - تابعها في طلب سحب لاحق، من باب المجاملة، قد ترغب في إبلاغ
      المساهم الأصلي.

  - لا تتسرع، خذ الوقت الكافي لجعل تعليقاتك واضحة وبرر اقتراحاتك.
  - أنت واجهة المشروع. تحدث أيام سيئة للجميع، في هذه المناسبة أنت تستحق استراحة: حاول أن تأخذ وقتك والابتعاد عن الإنترنت.

  .. [1] تم تكييفه من مبادئ توجيهية للتواصل في NumPy
        <https://numpy.org/devdocs/dev/reviewer_guidelines.html#communication-guidelines>`_.

قراءة قاعدة التعليمات البرمجية الموجودة
قراءة واستيعاب قاعدة كود موجودة مسبقًا هي دائمًا عملية صعبة تستغرق وقتًا وخبرة لإتقانها. على الرغم من أننا نحاول كتابة كود بسيط بشكل عام، إلا أن فهم الكود قد يبدو ساحقًا في البداية، نظرًا لحجم المشروع الهائل. فيما يلي قائمة بالنصائح التي قد تساعد في تسهيل هذه المهمة وتسريعها (دون ترتيب معين).

- تعرف على :ref:`api_overview`: افهم ما هي :term:`fit`، و :term:`predict`، و :term:`transform`، وما إلى ذلك، وما هي استخداماتها.
- قبل الغوص في قراءة كود دالة/فصل، قم بقراءة التوثيقات (docstrings) أولاً وحاول الحصول على فكرة عن الغرض من كل معلمة/خاصية. قد يكون من المفيد أيضًا التوقف لدقيقة والتفكير في كيفية القيام بذلك بنفسك إذا اضطررت إلى ذلك.
- غالبًا ما يكون أصعب شيء هو تحديد أجزاء الكود ذات الصلة والأجزاء غير ذات الصلة. في مجموعة أدوات التعلم الآلي **scikit-learn**، يتم تنفيذ الكثير من التحقق من صحة الإدخال، خاصة في بداية طرق :term:`fit`. في بعض الأحيان، يكون جزء صغير جدًا من الكود هو الذي يقوم بالمهمة الفعلية. على سبيل المثال، عند النظر في طريقة :meth:`~linear_model.LinearRegression.fit` للفصل :class:`~linear_model.LinearRegression`، فقد يكون ما تبحث عنه هو مجرد استدعاء للدالة :func:`scipy.linalg.lstsq`، ولكنها مدفونة في عدة أسطر من التحقق من صحة الإدخال ومعالجة أنواع مختلفة من المعلمات.
- بسبب استخدام `الوراثة <https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)>`_، قد يتم تنفيذ بعض الطرق في الفصول الأب (الأساسية). يرث جميع المقدرات (estimators) من فصل :class:`~base.BaseEstimator` على الأقل، ومن فصل ``Mixin`` (مثل :class:`~base.ClassifierMixin`) الذي يمكّن السلوك الافتراضي اعتمادًا على طبيعة المقدر (مصنف، أو مرجع، أو محول، وما إلى ذلك).
- في بعض الأحيان، قد تعطيك قراءة الاختبارات لدالة معينة فكرة عن الغرض المقصود منها. يمكنك استخدام ``git grep`` (انظر أدناه) للعثور على جميع الاختبارات المكتوبة لدالة ما. وتوضع معظم الاختبارات لدالة/فصل محددين في مجلد ``tests/`` الخاص بالنموذج.
- غالبًا ما سترى كودًا يشبه هذا: ``out = Parallel(...)(delayed(some_function)(param) for param in some_iterable)``. وهذا يشغل ``some_function`` بالتوازي باستخدام `Joblib <https://joblib.readthedocs.io/>`_. ثم تكون ``out`` عبارة عن مجموعة من العناصر القابلة للتحديد (iterable) تحتوي على القيم التي تعيدها ``some_function`` لكل استدعاء.
- نستخدم `Cython <https://cython.org/>`_ لكتابة كود سريع. يوجد كود Cython في ملفات ``.pyx`` و ``.pxd``. وللكود Cython نكهة أكثر تشابهًا مع لغة C: فنحن نستخدم المؤشرات، ونقوم بتخصيص الذاكرة يدويًا، وما إلى ذلك. ومن الضروري هنا أن يكون لديك بعض الخبرة، ولو قليلة، في لغات C/C++. لمزيد من المعلومات، راجع :ref:`cython`.
- أتقن أدواتك:

  - مع مشروع بهذا الحجم، فإن الكفاءة في استخدام محرر أو بيئة التطوير المتكاملة (IDE) المفضل لديك ستفيدك كثيرًا في استيعاب قاعدة الكود. وتساعدك القدرة على القفز (أو *الاطلاع*) بسرعة إلى تعريف دالة/فصل/خاصية بشكل كبير. كما أن القدرة على رؤية مكان استخدام اسم معين في ملف ما بسرعة مفيدة أيضًا.
  - يحتوي Git أيضًا على بعض الميزات المدمجة الرائعة. وغالبًا ما يكون من المفيد فهم كيفية تغيير ملف معين بمرور الوقت، باستخدام ``git blame`` على سبيل المثال (`دليل الاستخدام <https://git-scm.com/docs/git-blame>`_). ويمكن القيام بذلك مباشرة على GitHub. كما أن ``git grep`` (`أمثلة <https://git-scm.com/docs/git-grep#_examples>`_) مفيد للغاية أيضًا لرؤية كل ظهور لنمط (مثل استدعاء دالة أو متغير) في قاعدة الكود.

- قم بضبط إعدادات ``git blame`` لتجاهل الالتزام (commit) الذي قام بتهيئة نمط الكود إلى ``black``.

  .. prompt:: bash

      git config blame.ignoreRevsFile .git-blame-ignore-revs

  يمكنك معرفة المزيد من المعلومات في وثائق ``black`` حول `تجنب إفساد git blame <https://black.readthedocs.io/en/stable/guides/introducing_black_to_your_project.html#avoiding-ruining-git-blame>`_.