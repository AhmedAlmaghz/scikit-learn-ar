هذا النص مكتوب بتنسيق ReStructuredText، وهو يستخدم لتحديد عنوان "Model persistence" (استمرارية النموذج) كمرجع يمكن استخدامه في أجزاء أخرى من الوثيقة. الترجمة العربية للنص هي:

".. _model_persistence:

=================
استمرارية النموذج"
ملخص طرق حفظ النماذج
=================

.. list-table::
   :widths: 25 50 50
   :header-rows: 1

   * - طريقة الحفظ
     - الإيجابيات
     - السلبيات والمخاطر
   * - :ref:`ONNX <onnx_persistence>`
     - * تشغيل النماذج بدون بيئة Python
       * بيئات التشغيل والتدريب مستقلة عن بعضها البعض
       * أكثر الخيارات أمانًا
     - * لا تدعم ONNX جميع نماذج scikit-learn
       * تتطلب النماذج المخصصة مزيدًا من العمل لدعمها
       * يتم فقدان كائن Python الأصلي ولا يمكن إعادة بنائه
   * - :ref:`skops_persistence`
     - * أكثر أمانًا من التنسيقات المعتمدة على pickle
       * يمكن التحقق جزئيًا من المحتويات دون تحميل
     - * ليست سريعة مثل التنسيقات المعتمدة على pickle
       * تدعم أنواعًا أقل من التنسيقات المعتمدة على pickle
       * يتطلب نفس بيئة التدريب
   * - :mod:`pickle`
     - * أصلي في Python
       * يمكنه تسلسل معظم كائنات Python
       * كفاءة استخدام الذاكرة مع `protocol=5`
     - * يمكن للتحميل تنفيذ تعليمات برمجية تعسفية
       * يتطلب نفس بيئة التدريب
   * - :mod:`joblib`
     - * كفاءة استخدام الذاكرة
       * يدعم التخطيط للذاكرة
       * اختصارات سهلة للضغط وفك الضغط
     - * تنسيق يعتمد على pickle
       * يمكن للتحميل تنفيذ تعليمات برمجية تعسفية
       * يتطلب نفس بيئة التدريب
   * - `cloudpickle`_
     - * يمكنه تسلسل التعليمات البرمجية Python المخصصة وغير المعبأة
       * كفاءة تحميل مماثلة لـ :mod:`pickle` مع `protocol=5`
     - * تنسيق يعتمد على pickle
       * يمكن للتحميل تنفيذ تعليمات برمجية تعسفية
       * لا توجد ضمانات للتوافق المستقبلي
       * يتطلب نفس بيئة التدريب

بعد تدريب نموذج scikit-learn، من المستحسن وجود طريقة لحفظ
النموذج للاستخدام المستقبلي دون الحاجة إلى إعادة التدريب. بناءً على حالتك
الاستخدامية، هناك بضع طرق مختلفة لحفظ نموذج scikit-learn، وسنساعدك هنا على
اختيار الطريقة الأنسب لك. من أجل اتخاذ القرار، تحتاج إلى الإجابة عن الأسئلة
التالية:

1. هل تحتاج إلى كائن Python بعد الحفظ، أم أنك تحتاج فقط إلى حفظ النموذج من أجل
تشغيله والحصول على تنبؤات منه؟

إذا كنت بحاجة فقط إلى تشغيل النموذج ولا يلزم إجراء مزيد من التحقيق على كائن
Python نفسه، فقد يكون :ref:`ONNX <onnx_persistence>` هو الأنسب لك. لاحظ أن ONNX
لا تدعم جميع النماذج.

في حالة عدم ملاءمة ONNX لحالتك الاستخدامية، يكون السؤال التالي هو:

2. هل تثق تمامًا بمصدر النموذج، أم أن هناك مخاوف أمنية تتعلق بمصدر النموذج
المحفوظ؟

إذا كانت لديك مخاوف أمنية، فيجب عليك النظر في استخدام :ref:`skops.io
<skops_persistence>` الذي يعيد إليك كائن Python، ولكن على عكس حلول الحفظ
المعتمدة على pickle، فإن تحميل النموذج المحفوظ لا يسمح تلقائيًا بتنفيذ تعليمات
برمجية تعسفية. لاحظ أن هذا يتطلب فحصًا يدويًا للملف المحفوظ، والذي يسمح لك
به :mod:`skops.io`.

تفترض الحلول الأخرى أنك تثق تمامًا بمصدر الملف الذي سيتم تحميله، لأنها جميعًا
عرضة لتنفيذ تعليمات برمجية تعسفية عند تحميل الملف المحفوظ نظرًا لاستخدامها
بروتوكول pickle في الخلفية.

3. هل تهتم بأداء تحميل النموذج، ومشاركته بين العمليات حيث تكون كائنات الذاكرة
المخططة على القرص مفيدة؟

إذا كانت الإجابة بنعم، فيمكنك النظر في استخدام :ref:`joblib <pickle_persistence>`.
إذا لم يكن هذا مصدر قلق كبير بالنسبة لك، فيمكنك استخدام وحدة :mod:`pickle`
المدمجة.

4. هل جربت استخدام :mod:`pickle` أو :mod:`joblib` ووجدت أنه لا يمكن حفظ النموذج؟
يمكن أن يحدث هذا، على سبيل المثال، عندما تكون لديك وظائف محددة من قبل المستخدم
في نموذجك.

إذا كانت الإجابة بنعم، فيمكنك استخدام `cloudpickle`_ الذي يمكنه تسلسل كائنات
معينة لا يمكن تسلسلها باستخدام :mod:`pickle` أو :mod:`joblib`.

نظرة عامة على سير العمل
-----------------

في سير العمل النموذجي، تتمثل الخطوة الأولى في تدريب النموذج باستخدام scikit-learn
والمكتبات المتوافقة مع scikit-learn. لاحظ أن دعم scikit-learn ومقدّري الطرف
الثالث يختلف باختلاف طرق الحفظ.

تدريب النموذج وحفظه
...........................

يعتمد إنشاء نموذج مناسب على حالتك الاستخدامية. على سبيل المثال، هنا نقوم بتدريب
:class:`sklearn.ensemble.HistGradientBoostingClassifier` على مجموعة بيانات
الأيريس::

  >>> from sklearn import ensemble
  >>> from sklearn import datasets
  >>> clf = ensemble.HistGradientBoostingClassifier()
  >>> X, y = datasets.load_iris(return_X_y=True)
  >>> clf.fit(X, y)
  HistGradientBoostingClassifier()

بمجرد تدريب النموذج، يمكنك حفظه باستخدام الطريقة التي تفضلها، ثم يمكنك تحميل
النموذج في بيئة منفصلة والحصول على تنبؤات منه بناءً على بيانات الإدخال. هناك
مساران رئيسيان اعتمادًا على طريقة حفظ النموذج والتخطيط لتشغيله:

- :ref:`ONNX <onnx_persistence>`: تحتاج إلى وقت تشغيل ONNX وبيئة بها تبعيات
مناسبة مثبتة لتحميل النموذج واستخدام وقت التشغيل للحصول على تنبؤات. يمكن أن
تكون هذه البيئة بسيطة ولا تتطلب بالضرورة تثبيت Python لتحميل النموذج وحساب
التنبؤات. لاحظ أيضًا أن `onnxruntime` عادة ما يتطلب ذاكرة وصول عشوائي أقل بكثير
من Python لحساب التنبؤات من النماذج الصغيرة.

- :mod:`skops.io`، :mod:`pickle`، :mod:`joblib`، `cloudpickle`_: تحتاج إلى بيئة
Python بها التبعيات المناسبة المثبتة لتحميل النموذج والحصول على تنبؤات منه.
يجب أن تحتوي هذه البيئة على نفس **الحزم** ونفس **الإصدارات** مثل البيئة التي
تم فيها تدريب النموذج. لاحظ أن أيا من هذه الطرق لا تدعم تحميل نموذج تم تدريبه
باستخدام إصدار مختلف من scikit-learn، وربما إصدارات مختلفة من التبعيات الأخرى
مثل `numpy` و`scipy`. قد يكون أحد الشواغل الأخرى هو تشغيل النموذج المحفوظ على
أجهزة مختلفة، وفي معظم الحالات يجب أن تتمكن من تحميل نموذجك المحفوظ على
أجهزة مختلفة.

.. _onnx_persistence:

ONNX
----

تنسيق `ONNX`، أو `Open Neural Network Exchange <https://onnx.ai/>`__، هو الأنسب
لحالات الاستخدام التي تحتاج إلى حفظ النموذج ثم استخدام المحفوظات للحصول على
تنبؤات دون الحاجة إلى تحميل كائن Python نفسه. وهو مفيد أيضًا في الحالات التي
تحتاج فيها بيئة التشغيل إلى أن تكون بسيطة وقليلة المتطلبات، حيث لا يتطلب وقت
تشغيل ONNX وجود Python.

ONNX هو تسلسل ثنائي للنموذج. وقد تم تطويره لتحسين قابلية استخدام التمثيل
المتبادل لنماذج البيانات. تهدف إلى تسهيل تحويل نماذج البيانات بين أطر عمل
التعلم الآلي المختلفة، وتحسين قابلية نقلها على مختلف البنى الحاسوبية. تتوفر
تفاصيل أكثر من `دليل ONNX التعليمي <https://onnx.ai/get-started.html>`__. لتحويل
نموذج scikit-learn إلى ONNX، تم تطوير `sklearn-onnx
<http://onnx.ai/sklearn-onnx/>`__. ومع ذلك، لا تدعم ONNX جميع نماذج scikit-learn،
وهي تقتصر على جوهر scikit-learn ولا تدعم معظم مقدري الطرف الثالث. يمكن للمرء
أن يكتب محولًا مخصصًا لمقدري الطرف الثالث أو المخصصين، ولكن الوثائق للقيام بذلك
محدودة وقد يكون من الصعب القيام بذلك.

.. dropdown:: استخدام ONNX

  لتحويل النموذج إلى تنسيق ONNX، يجب عليك تزويد المحول ببعض المعلومات حول
الإدخال أيضًا، والتي يمكنك قراءة المزيد عنها `هنا
<http://onnx.ai/sklearn-onnx/index.html>`__::

      from skl2onnx import to_onnx
      onx = to_onnx(clf, X[:1].astype(numpy.float32), target_opset=12)
      with open("filename.onnx", "wb") as f:
          f.write(onx.SerializeToString())

  يمكنك تحميل النموذج في Python واستخدام وقت تشغيل ONNX للحصول على تنبؤات::

      from onnxruntime import InferenceSession
      with open("filename.onnx", "rb") as f:
          onx = f.read()
      sess = InferenceSession(onx, providers=["CPUExecutionProvider"])
      pred_ort = sess.run(None, {"X": X_test.astype(numpy.float32)})[0]

.. _skops_persistence:

`skops.io`
----------

يتجنب :mod:`skops.io` استخدام :mod:`pickle` ولا يحمل سوى الملفات التي تحتوي على
أنواع وإشارات إلى وظائف موثوق بها إما بشكل افتراضي أو من قبل المستخدم. لذلك،
فهو يوفر تنسيقًا أكثر أمانًا من :mod:`pickle`، :mod:`joblib`، و`cloudpickle`_.


.. dropdown:: استخدام skops

  واجهة برمجة التطبيقات (API) مشابهة جدًا لـ :mod:`pickle`، ويمكنك حفظ نماذجك كما
هو موضح في `الوثائق
<https://skops.readthedocs.io/en/stable/persistence.html>`__ باستخدام
:func:`skops.io.dump` و:func:`skops.io.dumps`::

      import skops.io as sio
      obj = sio.dump(clf, "filename.skops")

  ويمكنك تحميلها مرة أخرى باستخدام :func:`skops.io.load` و:func:`skops.io.loads`.
ومع ذلك، يجب عليك تحديد الأنواع التي تثق بها. يمكنك الحصول على الأنواع غير
المعروفة الموجودة في كائن / ملف محفوظ باستخدام
:func:`skops.io.get_untrusted_types`، وبعد التحقق من محتوياته، قم بتمريره إلى
دالة التحميل::

      unknown_types = sio.get_untrusted_types(file="filename.skops")
      # التحقق من محتويات unknown_types، ولا تقم بالتحميل إلا إذا كنت تثق
      # بكل ما تراه.
      clf = sio.load("filename.skops", trusted=unknown_types)

  يرجى الإبلاغ عن المشكلات وطلبات الميزات المتعلقة بهذا التنسيق في `مسجل
مشكلات skops <https://github.com/skops-dev/skops/issues>`__.

.. _pickle_persistence:

`pickle`، `joblib`، و`cloudpickle`
-------------------------------------

تستخدم هذه الوحدات الثلاث / الحزم بروتوكول pickle في الخلفية، ولكنها تأتي مع
تنويعات طفيفة:

- :mod:`pickle` هي وحدة نمطية من مكتبة Python القياسية. يمكنه تسلسل وإلغاء
تسلسل أي كائن Python، بما في ذلك الفئات والكائنات المخصصة في Python.
- :mod:`joblib` أكثر كفاءة من pickle عند العمل مع نماذج التعلم الآلي الكبيرة
أو مصفوفات Numpy الكبيرة.
- `cloudpickle`_ يمكنه تسلسل كائنات معينة لا يمكن تسلسلها باستخدام :mod:`pickle`
أو :mod:`joblib`، مثل وظائف المستخدم المحددة ووظائف lambda. يمكن أن يحدث هذا،
على سبيل المثال، عند استخدام :class:`~sklearn.preprocessing.FunctionTransformer`
واستخدام وظيفة مخصصة لتحويل البيانات.

.. dropdown:: استخدام `pickle`، `joblib`، أو `cloudpickle`

  اعتمادًا على حالتك الاستخدامية، يمكنك اختيار إحدى هذه الطرق الثلاث لحفظ
نموذج scikit-learn الخاص بك وتحميله، وكلها تتبع نفس واجهة برمجة التطبيقات
(API)::

      # هنا يمكنك استبدال pickle بـ joblib أو cloudpickle
      from pickle import dump
      with open("filename.pkl", "wb") as f:
          dump(clf, f, protocol=5)

  يُنصح باستخدام `protocol=5` لتقليل استخدام الذاكرة وجعلها أسرع لتخزين أي
مصفوفة Numpy كبيرة مخزنة كسمة ملائمة في النموذج واسترجاعها. يمكنك أيضًا تمرير
`protocol=pickle.HIGHEST_PROTOCOL` وهو ما يعادل `protocol=5` في Python 3.8
والإصدارات الأحدث (في وقت الكتابة).

  وفي وقت لاحق عند الحاجة، يمكنك تحميل نفس الكائن من الملف المحفوظ::

      # هنا يمكنك استبدال pickle بـ joblib أو cloudpickle
      from pickle import load
      with open("filename.pkl", "rb") as f:
          clf = load(f)

.. _persistence_limitations:

القيود الأمنية وقيود الصيانة
بالرغم من أن نماذج scikit-learn المدربة يمكن أن تكون كبيرة في بعض الأحيان، إلا أن هناك عدة طرق لحفظها في ملف واستعادتها لاحقًا. في ما يلي، نقدم نظرة عامة على الخيارات المختلفة لحفظ النماذج واستعادتها، ونناقش مزايا وعيوب كل منها.

:mod:`pickle` (وبالتمديد :mod:`joblib` و:mod:`clouldpickle`)، لديه العديد من نقاط الضعف الأمنية الموثقة بالتصميم ويجب ألا يستخدم إلا إذا كان الأثر، أي ملف pickle، قادمًا من مصدر موثوق ومتحقق منه. يجب ألا تقوم مطلقًا بتحميل ملف pickle من مصدر غير موثوق، تمامًا كما يجب ألا تقوم مطلقًا بتنفيذ تعليمات برمجية من مصدر غير موثوق.

لاحظ أيضًا أنه يمكن تمثيل الحسابات التعسفية باستخدام تنسيق ONNX، ولذلك يوصى باستخدام النماذج التي تستخدم ONNX في بيئة معزولة للحماية من استغلال الحسابات والذاكرة.

لاحظ أيضًا أنه لا توجد طرق مدعومة لتحميل نموذج مدرب باستخدام إصدار مختلف من scikit-learn. في حين أنه عند استخدام :mod:`skops.io` أو :mod:`joblib` أو :mod:`pickle` أو `cloudpickle`، قد يتم تحميل النماذج المحفوظة باستخدام إصدار واحد من scikit-learn في إصدارات أخرى، إلا أن هذا غير مدعوم وغير مستحسن على الإطلاق. يجب أيضًا مراعاة أن العمليات التي يتم تنفيذها على مثل هذه البيانات قد تعطي نتائج مختلفة وغير متوقعة، أو حتى تتسبب في تعطل عملية Python الخاصة بك.

من أجل إعادة بناء نموذج مشابه باستخدام الإصدارات المستقبلية من scikit-learn، يجب حفظ البيانات الوصفية الإضافية إلى جانب النموذج المحفوظ:

* بيانات التدريب، على سبيل المثال، مرجع إلى لقطة ثابتة
* كود Python المصدر المستخدم لتوليد النموذج
* إصدارات scikit-learn واعتماداته
* نتيجة التحقق من الصحة المتقاطعة التي تم الحصول عليها على بيانات التدريب

يجب أن يجعل هذا من الممكن التحقق من أن نتيجة التحقق من الصحة المتقاطعة تقع في نفس النطاق كما كان من قبل.

باستثناء بعض الحالات، يجب أن تكون النماذج المحفوظة قابلة للنقل عبر أنظمة التشغيل وهندسات الأجهزة بافتراض استخدام نفس الإصدارات من التبعيات وPython. إذا صادفت مُقدرًا غير قابل للنقل، يرجى فتح قضية على GitHub. غالبًا ما يتم نشر النماذج المحفوظة في الإنتاج باستخدام الحاويات مثل Docker، لتجميد البيئة والاعتمادات.

إذا كنت تريد معرفة المزيد عن هذه المشكلات، يرجى الرجوع إلى هذه المحادثات:

- `Adrin Jalali: Let's exploit pickle, and skops to the rescue! | PyData
  Amsterdam 2023 <https://www.youtube.com/watch?v=9w_H5OSTO9A>`__.
- `Alex Gaynor: Pickles are for Delis, not Software - PyCon 2014
  <https://pyvideo.org/video/2566/pickles-are-for-delis-not-software>`__.


.. _serving_environment:

تكرار بيئة التدريب في الإنتاج
..................................................

إذا اختلفت إصدارات التبعيات المستخدمة بين التدريب والإنتاج، فقد يؤدي ذلك إلى حدوث سلوك غير متوقع وأخطاء عند استخدام النموذج المدرب. لمنع مثل هذه المواقف، يوصى باستخدام نفس التبعيات والإصدارات في كل من بيئة التدريب والإنتاج. يمكن تثبيت هذه التبعيات العابرة باستخدام أدوات إدارة الحزم مثل `pip` أو `mamba` أو `conda` أو `poetry` أو `conda-lock` أو `pixi`، وما إلى ذلك.

ليس من الممكن دائمًا تحميل نموذج مدرب باستخدام الإصدارات القديمة من مكتبة scikit-learn واعتماداتها في بيئة برامج محدثة. بدلاً من ذلك، قد تحتاج إلى إعادة تدريب النموذج باستخدام الإصدارات الجديدة من جميع المكتبات. لذلك، عند تدريب نموذج، من المهم تسجيل وصفة التدريب (مثل نص برمجي بلغة Python) ومعلومات مجموعة التدريب، والبيانات الوصفية حول جميع التبعيات لتكون قادرًا على إعادة بناء بيئة التدريب تلقائيًا لبرنامج البرنامج المحدث.

.. dropdown:: InconsistentVersionWarning

  عندما يتم تحميل مُقدر باستخدام إصدار scikit-learn غير متوافق مع الإصدار الذي تم حفظ المُقدر به، يتم رفع تحذير :class:`~sklearn.exceptions.InconsistentVersionWarning`. يمكن التقاط هذا التحذير للحصول على الإصدار الأصلي الذي تم حفظ المُقدر به::

    from sklearn.exceptions import InconsistentVersionWarning
    warnings.simplefilter("error", InconsistentVersionWarning)

    try:
        with open("model_from_prevision_version.pickle", "rb") as f:
            est = pickle.load(f)
    except InconsistentVersionWarning as w:
        print(w.original_sklearn_version)


تقديم أثر النموذج
..........................

الخطوة الأخيرة بعد تدريب نموذج scikit-learn هي تقديم النموذج.
بمجرد تحميل النموذج المدرب بنجاح، يمكن تقديمه لإدارة طلبات التنبؤ المختلفة. يمكن أن ينطوي هذا على نشر النموذج كخدمة ويب باستخدام الحاويات، أو استراتيجيات نشر النماذج الأخرى، وفقًا للمواصفات.


تلخيص النقاط الرئيسية
--------------------------

بناءً على النهج المختلفة لحفظ النماذج، يمكن تلخيص النقاط الرئيسية لكل نهج على النحو التالي:

* `ONNX`: يوفر تنسيقًا موحدًا لحفظ أي نموذج تعلم آلي أو تعلم عميق (بخلاف scikit-learn) وهو مفيد لاستنتاج النموذج (التنبؤات). ومع ذلك، قد يؤدي إلى مشكلات توافق مع أطر العمل المختلفة.
* :mod:`skops.io`: يمكن مشاركة نماذج scikit-learn المدربة بسهولة ووضعها في الإنتاج باستخدام :mod:`skops.io`. إنه أكثر أمانًا مقارنة بالنهج البديلة المستندة إلى :mod:`pickle` لأنه لا يحمل التعليمات البرمجية التعسفية ما لم يطلب المستخدم ذلك بشكل صريح. يجب تعبئة مثل هذه التعليمات البرمجية وتكون قابلة للاستيراد في بيئة Python المستهدفة.
* :mod:`joblib`: تجعل تقنيات تعيين الذاكرة الفعالة الأمر أسرع عند استخدام نفس النموذج المحفوظ في عمليات Python متعددة عند استخدام `mmap_mode="r"`. كما يوفر اختصارات سهلة لضغط وفك ضغط الكائن المحفوظ دون الحاجة إلى كود إضافي. ومع ذلك، فقد يؤدي إلى تشغيل التعليمات البرمجية الضارة عند تحميل نموذج من مصدر غير موثوق كما هو الحال مع أي آلية حفظ تعتمد على pickle.
* :mod:`pickle`: هو أصلي في Python ويمكن تسلسل معظم كائنات Python وإلغاء تسلسلها باستخدام :mod:`pickle`، بما في ذلك فئات Python المخصصة والوظائف طالما تم تعريفها في حزمة يمكن استيرادها في البيئة المستهدفة. في حين أن :mod:`pickle` يمكن استخدامه لحفظ نماذج scikit-learn وتحميلها بسهولة، إلا أنه قد يؤدي إلى تشغيل التعليمات البرمجية الضارة عند تحميل نموذج من مصدر غير موثوق. يمكن أن يكون :mod:`pickle` أيضًا فعالًا للغاية من حيث الذاكرة إذا تم حفظ النموذج باستخدام `protocol=5` ولكنه لا يدعم تعيين الذاكرة.
* `cloudpickle`_: لديه كفاءة تحميل مماثلة لـ :mod:`pickle` و:mod:`joblib` (بدون تعيين الذاكرة)، ولكنه يوفر مرونة إضافية لتوصيل التعليمات البرمجية المخصصة لـ Python مثل التعبيرات lambda والوظائف والفئات المعرفة بشكل تفاعلي. قد يكون الملاذ الأخير لحفظ خطوط الأنابيب بمكونات Python المخصصة مثل :class:`sklearn.preprocessing.FunctionTransformer` التي تغلف دالة محددة في نص البرمجة نفسه أو بشكل عام خارج أي حزمة Python قابلة للاستيراد. لاحظ أن `cloudpickle`_ لا يقدم أي ضمانات للتوافق المستقبلي وقد تحتاج إلى نفس الإصدار من `cloudpickle`_ لتحميل النموذج المحفوظ إلى جانب نفس الإصدار من جميع المكتبات المستخدمة لتحديد النموذج. مثل آليات الحفظ الأخرى التي تعتمد على pickle، فقد يؤدي إلى تشغيل التعليمات البرمجية الضارة عند تحميل نموذج من مصدر غير موثوق.

.. _cloudpickle: https://github.com/cloudpipe/cloudpickle