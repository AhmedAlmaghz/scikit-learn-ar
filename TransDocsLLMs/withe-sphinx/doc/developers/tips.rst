.. _developers-tips:

============================
نصائح وحيل المطورين
============================

نصائح للحفاظ على الإنتاجية والعقلانية
=======================================

في هذا القسم، نقدم بعض النصائح والأدوات المفيدة التي قد تزيد من جودة حياتك عند مراجعة طلبات السحب، وتشغيل اختبارات الوحدة، وما إلى ذلك. تتكون بعض هذه الحيل من تعليمات برمجية للمستخدمين تتطلب امتدادًا للمتصفح مثل `TamperMonkey`_ أو `GreaseMonkey`_؛ لإعداد التعليمات البرمجية للمستخدمين، يجب أن يكون لديك أحد هذه الامتدادات مثبتًا ومُمكنًا ومُشغلًا. نوفر تعليمات برمجية للمستخدمين على شكل GitHub gists؛ لتثبيتها، انقر فوق الزر "Raw" على صفحة Gist.

.. _TamperMonkey: https://tampermonkey.net/
.. _GreaseMonkey: https://www.greasespot.net/

طي وفتح الفروق القديمة في طلبات السحب
-----------------------------------------------------

يخفي GitHub المناقشات حول طلبات السحب عندما يتم تغيير سطور الكود المقابلة في هذه الأثناء. يوفر هذا `تعليم برمجي للمستخدم <https://raw.githubusercontent.com/lesteve/userscripts/master/github-expand-all.user.js>`__ اختصارًا (Control-Alt-P في وقت الكتابة ولكن راجع الكود للتأكد) لفتح جميع هذه المناقشات المخفية مرة واحدة، حتى تتمكن من اللحاق بها.

استخراج طلبات السحب كفروع تتبع عن بعد
------------------------------------------------------

في الشوكة المحلية الخاصة بك، أضف إلى ملفك ``.git/config``، تحت عنوان ``[remote "upstream"]``، السطر التالي::

  fetch = +refs/pull/*/head:refs/remotes/upstream/pr/*

بعد ذلك، يمكنك استخدام ``git checkout pr/PR_NUMBER`` للانتقال إلى كود طلب السحب بالرقم المحدد. (`اقرأ المزيد في هذا المقطع التعليمي. <https://gist.github.com/piscisaureus/3342247>`_)

عرض تغطية الكود في طلبات السحب
--------------------------------------

لعرض تقارير تغطية الكود التي يولدها CodeCov continuous integration، يمكنك استخدام `هذا الامتداد للمتصفح <https://github.com/codecov/browser-extension>`_. ستظهر تغطية كل سطر كخلفية ملونة خلف رقم السطر.


.. _pytest_tips:

اختصارات وأعلام pytest المفيدة
-------------------------------

يستغرق تشغيل مجموعة الاختبارات الكاملة وقتًا طويلاً جدًا. وللحصول على تكرارات أسرع، يمكنك اختيار مجموعة فرعية من الاختبارات باستخدام محددات pytest.

على وجه التحديد، يمكنك تشغيل `اختبار واحد بناءً على معرف العقدة الخاص به <https://docs.pytest.org/en/latest/example/markers.html#selecting-tests-based-on-their-node-id>`_:

.. prompt:: bash $

  pytest -v sklearn/linear_model/tests/test_logistic.py::test_sparsify

أو استخدم معلمة `-k pytest <https://docs.pytest.org/en/latest/example/markers.html#using-k-expr-to-select-tests-based-on-their-name>`_ لاختيار الاختبارات بناءً على اسمها. على سبيل المثال،:

.. prompt:: bash $

  pytest sklearn/tests/test_common.py -v -k LogisticRegression

سيشغل جميع :term:`الاختبارات العامة` لمصنف ``LogisticRegression``.

عند فشل اختبار الوحدة، يمكن للحيل التالية تسهيل عملية التصحيح:

1. يوجه سطر الأوامر ``pytest -l`` pytest لطباعة المتغيرات المحلية عند حدوث خطأ.

2. يؤدي سطر الأوامر ``pytest --pdb`` إلى الدخول في مصحح Python عند حدوث خطأ. بدلاً من ذلك، للدخول إلى مصحح IPython الغني ``ipdb``، يمكنك إعداد اختصار في المحطة الطرفية إلى:

   .. prompt:: bash $

      pytest --pdbcls=IPython.terminal.debugger:TerminalPdb --capture no

تشمل خيارات "pytest" الأخرى التي قد تكون مفيدة ما يلي:

- ``-x`` الذي يخرج عند أول اختبار فاشل،
- ``--lf`` لإعادة تشغيل الاختبارات التي فشلت في التشغيل السابق،
- ``--ff`` لإعادة تشغيل جميع الاختبارات السابقة، وتشغيل الاختبارات التي فشلت أولاً،
- ``-s`` حتى لا يلتقط pytest إخراج عبارات ``print()``،
- ``--tb=short`` أو ``--tb=line`` للتحكم في طول السجلات،
- ``--runxfail`` لتشغيل الاختبارات التي تم وضع علامة عليها على أنها فشل معروف (XFAIL) والإبلاغ عن الأخطاء.

نظرًا لأن اختبارات التكامل المستمر لدينا سترسل خطأ إذا لم يتم التعامل مع ``FutureWarning`` بشكل صحيح، فمن المستحسن أيضًا تشغيل ``pytest`` مع علم ``-Werror::FutureWarning``.

.. _saved_replies:

الردود القياسية للمراجعة
------------------------------

قد يكون من المفيد تخزين بعض هذه الردود في `الردود المحفوظة <https://github.com/settings/replies/>`_ على GitHub للمراجعة:

.. highlight:: none

..
    لاحظ أن وضع هذا المحتوى في سطر واحد في حرفي هو أسهل طريقة لجعلها قابلة للنسخ ومقيدة على الشاشة.

المسألة: أسئلة الاستخدام

::

    أنت تسأل عن سؤال الاستخدام. يُستخدم مسار المشكلات للأخطاء والميزات الجديدة. يُنصح بتجربة [Stack Overflow](https://stackoverflow.com/questions/tagged/scikit-learn) أو [قائمة البريد](https://mail.python.org/mailman/listinfo/scikit-learn) لأسئلة الاستخدام.

    لسوء الحظ، يتعين علينا إغلاق هذه المشكلة لأن مسار المشكلات هو أداة اتصال تُستخدم لتطوير scikit-learn. تُعيق الأنشطة الإضافية التي تُنشئها أسئلة الاستخدام هذا التطوير. يمكن أن يستمر الحوار هنا، ومع ذلك، لا يوجد ضمان بأنه سيحصل على اهتمام من المطورين الأساسيين.


المسألة: أنت مدعو لتحديث الوثائق

::

    يرجى تقديم طلب سحب لتحديث الوثائق إذا كنت تعتقد أنه يمكن تحسينها.

المسألة: مثال مستقل للخطأ

::

    يرجى تقديم [كود مثال مستقل](https://scikit-learn.org/dev/developers/minimal_reproducer.html)، بما في ذلك الاستيرادات والبيانات (إن أمكن)، بحيث يمكن للمساهمين الآخرين تشغيله وتكرار مشكلتك. يجب أن يكون مثال الكود الخاص بك بسيطًا قدر الإمكان.

المسألة: إصدارات البرامج

::

    للمساعدة في تشخيص مشكلتك، يرجى لصق إخراج ما يلي:
    ```py
    import sklearn; sklearn.show_versions()
    ```
    شكرا لك.

المسألة: كتل الأكواد

::

    يمكن تحسين قابلية القراءة بشكل كبير إذا قمت [بتهيئة](https://help.github.com/articles/creating-and-highlighting-code-blocks/) مقتطفات الكود ورسائل الأخطاء الكاملة بشكل مناسب. على سبيل المثال:

        ```python
        print(something)
        ```

    يولد ما يلي:

    ```python
    print(something)
    ```

    و:

        ```pytb
        Traceback (most recent call last):
            File "<stdin>", line 1, in <module>
        ImportError: No module named 'hello'
        ```

    يولد ما يلي:

    ```pytb
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
    ImportError: No module named 'hello'
    ```

    يمكنك تحرير أوصاف المشكلات والتعليقات في أي وقت لتحسين قابلية القراءة. هذا يساعد المُصانين كثيرًا. شكرا لك!

المسألة/التعليق: الربط بالشيفرة

::

    نصيحة ودية: من أجل الوضوح، يمكنك الربط بالشيفرة مثل [هذا](https://help.github.com/articles/creating-a-permanent-link-to-a-code-snippet/).

المسألة/التعليق: الربط بالتعليقات

::

    يرجى استخدام الروابط إلى التعليقات، والتي تجعل من السهل معرفة ما تشير إليه، بدلاً من الارتباط بالمشكلة فقط. راجع [هذا](https://stackoverflow.com/questions/25163598/how-do-i-reference-a-specific-issue-comment-on-github) لمزيد من التفاصيل.

طلب السحب الجديد: وصف وعنوان أفضل

::

    شكرًا لك على طلب السحب! يرجى جعل عنوان طلب السحب أكثر وصفًا. سيصبح العنوان رسالة الالتزام عند دمجه. يجب أن تذكر ما هي المشكلة (أو طلب السحب) التي يحلها/يحسمها الوصف باستخدام بناء الجملة الموضح [هنا](https://scikit-learn.org/dev/developers/contributing.html#contributing-pull-requests).

طلب السحب الجديد: إصلاح #

::

    يرجى استخدام "إصلاح #issueNumber" في وصف طلب السحب (ويمكنك القيام بذلك أكثر من مرة). بهذه الطريقة، يتم إغلاق المشكلة المرتبطة تلقائيًا عند دمج طلب السحب. لمزيد من التفاصيل، راجع [هذا](https://github.com/blog/1506-closing-issues-via-pull-requests).

طلب السحب الجديد أو المشكلة: تكلفة الصيانة

::

    لكل ميزة ندرجها، هناك [تكلفة صيانة](https://scikit-learn.org/dev/faq.html#why-are-you-so-selective-on-what-algorithms-you-include-in-scikit-learn). مُصانينا متطوعون في الغالب. لإدراج ميزة جديدة، نحتاج إلى دليل على أنها مفيدة في كثير من الأحيان، و[راسخة جيدًا](https://scikit-learn.org/dev/faq.html#what-are-the-inclusion-criteria-for-new-algorithms) في الأدبيات أو الممارسة. أيضًا، نتوقع من مؤلفي طلبات السحب المشاركة في صيانة الكود الذي يقدمونه، على الأقل في البداية. لا يمنعك ذلك من تنفيذها لنفسك ونشرها في مستودع منفصل، أو حتى في [scikit-learn-contrib](https://scikit-learn-contrib.github.io).

طلب السحب قيد التقدم: ما المطلوب قبل الدمج؟

::

    يرجى التوضيح (ربما كقائمة مهام في وصف طلب السحب) ما العمل الذي تعتقد أنه لا يزال بحاجة إلى إنجازه قبل مراجعته للدمج. عندما يكون جاهزًا، يرجى إضافة بادئة "[MRG]" إلى عنوان طلب السحب.

طلب السحب قيد التقدم: اختبار الانحدار مطلوب

::

    يرجى إضافة [اختبار عدم الانحدار](https://en.wikipedia.org/wiki/Non-regression_testing) الذي سيفشل في "main" ولكنه سينجح في هذا طلب السحب.

طلب السحب قيد التقدم: PEP8

::

    لديك بعض [انتهاكات PEP8](https://www.python.org/dev/peps/pep-0008/)، والتي يمكنك الاطلاع على تفاصيلها في مهمة "lint" في Circle CI. قد يكون من المفيد تكوين محرر الكود الخاص بك للتحقق من مثل هذه الأخطاء أثناء التنقل، حتى تتمكن من اكتشافها قبل الالتزام.

طلب السحب جاهز للدمج: الصبر

::

    قبل الدمج، نطلب عادةً من مطورين أساسيين الموافقة على أن طلب السحب الخاص بك مرغوب فيه وجاهز. [يرجى التحلي بالصبر](https://scikit-learn.org/dev/faq.html#why-is-my-pull-request-not-getting-any-attention)، حيث نعتمد بشكل أساسي على الوقت التطوعي من المطورين الأساسيين المشغولين. (أنت مدعو أيضًا لمساعدتنا في [مراجعة طلبات السحب الأخرى](https://scikit-learn.org/dev/developers/contributing.html#code-review-guidelines).)

طلب السحب جاهز للدمج: إضافة إلى ما الجديد

::

    يرجى إضافة إدخال إلى سجل التغييرات في `doc/whats_new/v*.rst`. مثل الإدخالات الأخرى هناك، يرجى الإشارة إلى هذا طلب السحب باستخدام `:pr:` واعتماد نفسك (ومساهمين آخرين إذا كان ذلك ينطبق) باستخدام `:user:`.

طلب السحب: لا تغير غير ذي صلة

::

    يرجى عدم تغيير الأسطر غير ذات الصلة. يجعل مساهمتك أكثر صعوبة في المراجعة وقد يؤدي إلى تعارضات الدمج مع طلبات السحب الأخرى.

.. _debugging_ci_issues:

تصحيح أخطاء التكامل المستمر
-------------------

قد تنشأ مشكلات التكامل المستمر لعدد من الأسباب، لذا فإن هذا ليس دليلًا شاملاً بأي حال من الأحوال، ولكنه قائمة مفيدة بالنصائح والحيل.

استخدام ملف قفل للحصول على بيئة قريبة من التكامل المستمر
+++++++++++++++++++++++++++++++++++++++++++++++++++++++

يمكن استخدام `conda-lock` لإنشاء بيئة conda تحتوي على نفس حزم conda وpip تمامًا مثل التكامل المستمر. على سبيل المثال، سينشئ الأمر التالي بيئة conda تسمى `scikit-learn-doc` مشابهة للتكامل المستمر:

.. prompt:: bash $

    conda-lock install -n scikit-learn-doc build_tools/circle/doc_linux-64_conda.lock

.. note::

    يعمل فقط إذا كان لديك نفس نظام التشغيل مثل بناء التكامل المستمر (تحقق من `platform:` في ملف القفل). على سبيل المثال، لن يعمل الأمر السابق إلا إذا كنت على جهاز كمبيوتر يعمل بنظام Linux. أيضًا، قد لا يسمح لك هذا بإعادة إنتاج بعض المشكلات التي ترتبط بشكل أكبر بخصوصيات بيئة التكامل المستمر، على سبيل المثال بنية CPU التي يبلغ عنها OpenBLAS في `sklearn.show_versions()`.

إذا لم يكن لديك نفس نظام التشغيل مثل بناء التكامل المستمر، فيمكنك لا تزال إنشاء بيئة conda من ملف yaml البيئة الصحيح، على الرغم من أنه لن يكون قريبًا من بيئة التكامل المستمر مثل استخدام ملف القفل المقابل. على سبيل المثال لبناء الوثائق:

.. prompt:: bash $

    conda env create -n scikit-learn-doc -f build_tools/circle/doc_environment.yml -y

قد لا يمنحك هذا نفس إصدارات الحزم الموجودة في التكامل المستمر لعدد من الأسباب، على سبيل المثال:

- قد تكون هناك إصدارات جديدة من بعض الحزم بين الوقت الذي تم فيه تحديث ملفات القفل آخر مرة في فرع `main` ووقت تشغيل الأمر ``conda create``. يمكنك دائمًا محاولة البحث عن الإصدار في ملف القفل وتحديد الإصدارات يدويًا لبعض الحزم المحددة التي تعتقد أنها قد تساعد في إعادة إنتاج المشكلة.
- قد يتم تثبيت حزم مختلفة بشكل افتراضي اعتمادًا على نظام التشغيل. على سبيل المثال، تعتبر مكتبة BLAS الافتراضية عند تثبيت numpy هي OpenBLAS على Linux وMKL على Windows.

أيضًا، قد تكون المشكلة خاصة بنظام التشغيل، لذا فإن الطريقة الوحيدة لإعادة إنتاجها ستكون امتلاك نفس نظام التشغيل مثل بناء التكامل المستمر.

.. highlight:: default

تصحيح أخطاء الذاكرة في Cython باستخدام valgrind
بالرغم من أن إدارة الذاكرة المدمجة في بايثون/نومبي متينة نسبيًا، إلا أنها قد تؤدي إلى عقوبات أداء لبعض الروتين. ولهذا السبب، فإن الكثير من التعليمات البرمجية عالية الأداء في سكايت-ليرن مكتوبة في سايتون. ومع ذلك، تأتي هذه الزيادة في الأداء مع حل وسط: من السهل جدًا ظهور أخطاء الذاكرة في كود سايتون، خاصة في المواقف التي تعتمد فيها تلك التعليمات البرمجية اعتمادًا كبيرًا على حسابات المؤشر.

يمكن أن تظهر أخطاء الذاكرة بعدد من الطرق. وأسهلها في التصحيح هي أخطاء التقطيع والغلibc ذات الصلة. يمكن أن تؤدي المتغيرات غير المُهيأة إلى سلوك غير متوقع يصعب تتبعه. وأداة مفيدة جدًا عند تصحيح هذه الأنواع من الأخطاء هي فالجراوند.

فالجراوند هي أداة سطر أوامر يمكنها تتبع أخطاء الذاكرة في مجموعة متنوعة من التعليمات البرمجية. اتبع الخطوات التالية:

1. قم بتثبيت "فالجراوند" على نظامك.

2. قم بتنزيل ملف كبت فالجراوند بايثون: "valgrind-python.supp".

3. اتبع الإرشادات الموجودة في ملف "README.valgrind" لتخصيص عمليات الكبت بايثون الخاصة بك. إذا لم تقم بذلك، فستحصل على إخراج عشوائي يتعلق بمفسر بايثون بدلاً من التعليمات البرمجية الخاصة بك.

4. قم بتشغيل فالجراوند على النحو التالي:

valgrind -v --suppressions=valgrind-python.supp python my_test_script.py

ستكون النتيجة قائمة بجميع الأخطاء المتعلقة بالذاكرة، والتي تشير إلى أسطر في كود C التي تم إنشاؤها بواسطة سايتون من ملف .pyx الخاص بك. إذا قمت بفحص الأسطر المشار إليها في ملف .c، فستشاهد التعليقات التي تشير إلى الموقع المقابل في ملف مصدر .pyx الخاص بك. من المؤمل أن يعطيك الإخراج تلميحات عن مصدر خطأ الذاكرة الخاص بك.

للحصول على مزيد من المعلومات حول فالجراوند ومجموعة الخيارات التي يوفرها، راجع البرامج التعليمية والوثائق على موقع "فالجراوند" <https://valgrind.org>.

إعداد وبناء منصة ARM64 على جهاز x86_64
=================================

تعد الأجهزة المستندة إلى ARM هدفًا شائعًا للنشر المحمول أو الحواف أو عمليات النشر منخفضة الطاقة الأخرى (بما في ذلك في السحابة، على سبيل المثال على Scaleway أو AWS Graviton).

فيما يلي تعليمات لإعداد بيئة تطوير محلية لتكرار الأخطاء أو حالات الفشل الخاصة بـ ARM على جهاز كمبيوتر محمول أو محطة عمل x86_64 مضيفة. ويستند هذا إلى محاكاة QEMU لوضع المستخدم باستخدام برنامج Docker للراحة (راجع https://github.com/multiarch/qemu-user-static).

ملاحظة: يتم توضيح التعليمات التالية لنظام ARM64 ولكنها تنطبق أيضًا على ppc64le، بعد تغيير صورة Docker ومسارات Miniforge بشكل مناسب.

قم بإعداد مجلد على نظام الملفات المضيف وقم بتنزيل الأدوات ورمز المصدر اللازم:

mkdir arm64
pushd arm64
wget https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-Linux-aarch64.sh
git clone https://github.com/scikit-learn/scikit-learn.git

استخدم Docker لتثبيت QEMU في وضع المستخدم وتشغيل حاوية ARM64v8 مع الوصول إلى مجلدك المشترك تحت نقطة التثبيت /io:

docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
docker run -v`pwd`:/io --rm -it arm64v8/ubuntu /bin/bash

في الحاوية، قم بتثبيت miniforge3 لمعمارية ARM64 (المعروفة أيضًا باسم aarch64):

bash Miniforge3-Linux-aarch64.sh
# اختر تثبيت miniforge3 تحت: `/io/miniforge3`

في كل مرة تقوم فيها بإعادة تشغيل حاوية جديدة، ستحتاج إلى إعادة تهيئة بيئة conda المثبتة سابقًا تحت /io/miniforge3:

/io/miniforge3/bin/conda init
source /root/.bashrc

نظرًا لأن مجلد /root الرئيسي هو جزء من حاوية Docker المؤقتة. من ناحية أخرى، فإن كل ملف أو دليل مخزن تحت /io يكون ثابتًا.

بعد ذلك، يمكنك بناء سكايت-ليرن كالمعتاد (ستحتاج إلى تثبيت أدوات المترجم والاعتماديات باستخدام apt أو conda كالمعتاد). يستغرق بناء سكايت-ليرن الكثير من الوقت بسبب طبقة المحاكاة، ومع ذلك، يجب القيام بذلك مرة واحدة فقط إذا قمت بوضع مجلد سكايت-ليرن تحت نقطة التثبيت /io.

بعد ذلك، استخدم pytest لتشغيل اختبارات الوحدة فقط للوحدة التي تهتم بتصحيح الأخطاء فيها.

ميسون بناء الخلفية
=================

منذ سكايت-ليرن 1.5.0 نستخدم ميسون-بايثون كأداة بناء. ميسون هو أداة جديدة لسكايت-ليرن ونظام باي-داتا البيئي. ويستخدمه العديد من الحزم الأخرى التي كتبت أدلة جيدة حول ما هو وكيف يعمل.

- وثيقة إعداد بانداس <https://pandas.pydata.org/docs/development/contributing_environment.html#step-3-build-and-install-pandas>: لدى بانداس إعداد مشابه لنا (بدون سبين أو dev.py)
- توفر وثيقة ميسون سايسبي <https://scipy.github.io/devdocs/building/understanding_meson.html> المزيد من المعلومات الأساسية حول كيفية عمل ميسون خلف الكواليس.