هذا نص بتنسيق RST أريد ترجمته إلى اللغة العربية، مع الحفاظ على الرموز الخاصة والرموز والمعادلات الرياضية والروابط والتاجات والشفرة البرمجية:

.. |ss| raw:: html

   <strike>

.. |se| raw:: html

   </strike>

.. _خريطة\_الطريق:

خريطة الطريق

(ملاحظة: تم الاحتفاظ بنص "Roadmap" كما هو لأنّه يبدو وكأنّه عنوان قسم، ويمكن ترجمته إلى "خريطة الطريق" في السياق العربي.)

  الغرض من هذه الوثيقة
    ----------------------
    تدرج هذه الوثيقة التوجيهات العامة التي يرغب المساهمون الأساسيون في رؤيتها مطورة في سكيت-ليرن (scikit-learn). حقيقة أن العنصر موجود هنا لا يعني بأي شكل من الأشكال أنه سيحدث، لأن الموارد محدودة. بدلاً من ذلك، فهو مؤشر على أن المساعدة مرحب بها في هذا الموضوع.

    بيان الغرض: سكيت-ليرن في عام 2018
    ---------------------------------
    بعد أحد عشر عامًا من بدء سكيت-ليرن، تغير الكثير في عالم التعلم الآلي. تتضمن التغييرات الرئيسية ما يلي:

    * أدوات حسابية: استغلال وحدات معالجة الرسومات، وأطر البرمجة الموزعة مثل سكالا/سبارك، إلخ.
    * مكتبات بايثون عالية المستوى للتجريب والمعالجة وإدارة البيانات: Jupyter notebook، Cython، Pandas، Dask، Numba ...
    * التغييرات في التركيز على أبحاث التعلم الآلي: تطبيقات الذكاء الاصطناعي (حيث يكون هيكل المدخلات أساسيًا) مع التعلم العميق، والتعلم التمثيلي، والتعلم المعزز، ونقل المجال، وما إلى ذلك.

    تغيير أكثر دقة على مدار العقد الماضي هو أنه، بسبب الاهتمامات المتغيرة في التعلم الآلي، من المرجح أن يساهم طلاب الدكتوراه في التعلم الآلي في PyTorch، Dask، إلخ. أكثر من سكيت-ليرن، لذلك فإن مجموعة المساهمين لدينا مختلفة تمامًا عن عقد مضى.

    تظل سكيت-ليرن شائعة جدًا في الممارسة العملية لتجربة تقنيات التعلم الآلي القياسية، وخاصة للتطبيقات في العلوم التجريبية وعلم البيانات. الكثير مما نقدمه ناضج جدًا الآن. ولكن يمكن أن يكون مكلفًا في الصيانة، وبالتالي لا يمكننا تضمين تطبيقات جديدة عشوائية. ومع ذلك، تعد سكيت-ليرن أيضًا ضرورية في تحديد إطار عمل واجهة برمجة التطبيقات لتطوير مكونات التعلم الآلي القابلة للتشغيل البيني خارج المكتبة الأساسية.

    **وبالتالي فإن أهدافنا الرئيسية في هذا العصر هي:**

    * الاستمرار في الحفاظ على مجموعة عالية الجودة وموثقة جيدًا من الأدوات الأساسية لمعالجة البيانات والتعلم الآلي ضمن النطاق الحالي (أي البيانات المستطيلة التي لا تتغير إلى حد كبير مع ترتيب الأعمدة والصفوف ؛ التنبؤ بالأهداف بهيكل بسيط)
    * تحسين سهولة قيام المستخدمين بتطوير ونشر المكونات الخارجية
    * تحسين قابلية التشغيل البيني مع أدوات وبيئات علوم البيانات الحديثة (مثل Pandas، Dask) والبنية التحتية (مثل المعالجة الموزعة)

    يمكن العثور على العديد من الأهداف الأكثر دقة تحت علامة `API <https://github.com/scikit-learn/scikit-learn/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+label%3AAPI>`_ على متعقب المشكلات.

    أهداف معمارية / عامة
    
    (ملاحظة: لم يتم تضمين أي رموز خاصة أو معادلات رياضية أو روابط أو علامات أو شفرات برمجية في الترجمة)

ال قائمة مرقمة ليس كدلالة على أولوية التنفيذ، ولكن لتسهيل الإشارة إلى نقاط محددة. يرجى إضافة مدخلات جديدة فقط في الأسفل. لاحظ أن العناصر التي تم شطبها تم تنفيذها بالفعل، ونحن نحاول الحفاظ على المستند محدثًا أثناء العمل على هذه المشكلات.

1. تحسين التعامل مع إطارات بيانات Pandas

   * توثيق التعامل الحالي
   * مشكلة إعادة ترتيب الأعمدة :issue:`7242`
   * تجنب التحويل غير الضروري إلى ndarray |ss| :issue:`12147` |se|
   * إرجاع إطارات البيانات من المحولات :issue:`5523`
   * الحصول على إطارات البيانات من محمّلات مجموعة البيانات |ss| :issue:`10733` |se|،
     |ss| :issue:`13902` |se|
   * لا يتم اعتبار Sparse حاليًا |ss| :issue:`12800` |se|

2. تحسين التعامل مع الميزات الفئوية

   * يجب أن تكون النماذج المستندة إلى الأشجار قادرة على التعامل مع كل من الميزات المستمرة والفئوية
     :issue:`12866` و |ss| :issue:`15550` |se|.
   * |ss| في محمّلات مجموعة البيانات :issue:`13902` |se|
   * كمحولات عامة لاستخدامها مع ColumnTransforms (على سبيل المثال، الترميز الرتبي الذي تشرف عليه العلاقة مع متغير الهدف) :issue:`5853`،
     :issue:`11805`
   * التعامل مع مزيج من المتغيرات الفئوية والمستمرة

3. تحسين معالجة البيانات المفقودة

   * التأكد من أن المحولات العامة متساهلة تجاه البيانات المفقودة،
     |ss| :issue:`15319` |se|
   * أجهزة التقويم غير التافهة |ss| :issue:`11977`، :issue:`12852` |se|
   * المتعلمون يتعاملون مباشرة مع البيانات المفقودة |ss| :issue:`13911` |se|
   * مولد عينة بتر لجعل أجزاء من مجموعة بيانات مفقودة
     :issue:`6284`

4. وثائق تعليمية أكثر

   * تمت إضافة المزيد والمزيد من الخيارات إلى scikit-learn. نتيجة لذلك، أصبحت الوثائق مزدحمة مما يجعل من الصعب على المبتدئين الحصول على الصورة الكبيرة. يمكن القيام ببعض العمل في تحديد أولويات المعلومات.

5. تمرير المعلومات التي ليست (X، y): خصائص العينة

   * نحتاج إلى أن نكون قادرين على تمرير أوزان العينة إلى أدوات التهديف في التحقق المتقاطع.
   * يجب أن تكون لدينا طرق قياسية/عامة لتمرير خصائص كل عينة حولها في المحولات العامة. :issue:`4497` :issue:`7646`

6. تمرير المعلومات التي ليست (X، y): خصائص الميزة

   * من الناحية المثالية، يجب أن تكون أسماء الميزات أو أوصافها متاحة للتناسب، على سبيل المثال
     . :issue:`6425` :issue:`6424`
   * يجب أيضًا ألا تحتاج المعالجة لكل ميزة (على سبيل المثال، "هل هذا اسم / ترتيبي / نص باللغة الإنجليزية؟") إلى توفيرها لمنشئي التقدير،
     من الناحية المثالية، ولكن يجب أن تكون متاحة كبيانات وصفية إلى جانب X. :issue:`8480`

7. تمرير المعلومات التي ليست (X، y): معلومات الهدف

   * لدينا مشاكل في الحصول على المجموعة الكاملة من الطبقات لجميع المكونات عندما
     يتم تقسيم/عينة البيانات. :issue:`6231` :issue:`8100`
   * ليس لدينا طريقة للتعامل مع مزيج من الأهداف الفئوية والمستمرة.

8. تسهيل كتابة مكونات متوافقة مع Scikit-learn للمستخدمين الخارجيين

   * تحقق من صحة التقدير الأكثر مرونة والتي لا تحدد حسب اسم التقدير
     |ss| :issue:`6599` |se| :issue:`6715`
   * مثال على كيفية تطوير التقدير أو التقدير الفوقي،
     |ss| :issue:`14582` |se|
   * تشغيل أكثر اكتفاءً ذاتيًا لـ scikit-learn-contrib أو مورد مشابه

9. دعم إعادة أخذ العينات وتقليل العينة

   * السماح باختيار فرعي للفئات الرئيسية (في خط أنابيب؟) :issue:`3855`
   * تنفيذ الغابات العشوائية مع إعادة أخذ العينات :issue:`13227`

10. واجهات أفضل للتطوير التفاعلي

   * |ss| __repr__ والتصورات HTML للمقدرين
     :issue:`6323` و :pr:`14180` |se|.
   * تضمين أدوات التخطيط، وليس فقط كمثال. :issue:`9173`

11. أدوات محسنة لتشخيص النموذج والاستدلال الأساسي

   * |ss| بديل ميزات أهمية التنفيذات، :issue:`13146` |se|
   * طرق أفضل للتعامل مع مجموعات التحقق عند التركيب
   * طرق أفضل لإيجاد العتبات / إنشاء قواعد القرار :issue:`8614`

12. أدوات أفضل لاختيار超参数 مع مقدرين مبشرين

   * لا ينطبق البحث الشبكي والتحقق المتقاطع على معظم مهام التجميع. التحديد المستند إلى الاستقرار أكثر ملاءمة.

13. دعم أفضل لبناء خطوط الأنابيب اليدوية والتلقائية

   * طريقة أسهل لبناء خطوط أنابيب معقدة ومساحات بحث صالحة
     :issue:`7608` :issue:`5082` :issue:`8243`
   * تقديم نطاقات بحث للمقدرين الشائعين؟
   *راجع `searchgrid <https://searchgrid.readthedocs.io/en/latest/>`_

14. تحسين تتبع التركيب

   * Verbose ليس ودودًا للغاية ويجب أن يستخدم مكتبة تسجيل قياسية
     :issue:`6929`، :issue:`78`
   * ستسهل ردادات الاتصال أو نظام مماثل التسجيل والتوقف المبكر

15. التوازي الموزع

   * قبول البيانات التي تمتثل لـ ``__array_function__``

16. طريقة للأمام لمزيد من خارج الأساسية

   * تمكن Dask الحساب خارج النواة بسهولة. بينما ربما لا يمكن تكييف نموذج Dask مع جميع خوارزميات التعلم الآلي، فإن معظم التعلم الآلي هو على بيانات أصغر من ETL، وبالتالي يمكننا ربما التكيف مع نطاق واسع للغاية مع دعم جزء صغير فقط من الأنماط.

17. دعم العمل مع النماذج المدربة مسبقًا

   * تقدير "التجميد". على وجه الخصوص، من المستحيل حاليًا استنساخ `CalibratedClassifierCV` مع prefit. :issue:`8370`. :issue:`6451`

18. التوافق مع الإصدارات السابقة للتسلسل / إلغاء تسلسل بعض المقدرين

   * التسلسل الحالي (مع مخلل) يكسر عبر الإصدارات. بينما قد لا نتمكن من الالتفاف حول القيود الأخرى لمخلل إعادة الأمان وما إلى ذلك، سيكون من الرائع تقديم أمان عبر الإصدار من الإصدار 1.0. ملاحظة: يعتقد غايل وأوليفييه أن هذا يمكن أن يسبب عبئا ثقيلا للصيانة ويجب أن ندير المفاضلات. يتم تقديم بديل محتمل في النقطة التالية.

19. الوثائق والأدوات لإدارة دورة حياة النموذج



(ملاحظة: الرموز الخاصة والتعبيرات الرياضية والروابط والعلامات والشفرة البرمجية لم تتم ترجمتها كما هو مطلوب في التعليمات.)

* توثيق الممارسات الجيدة لنشر النماذج ودورة حياتها: قبل نشر النموذج، تأخذ لقطة للإصدارات البرمجية (مثل numpy، scipy، scikit-learn، وغيرها من مستودعات التعليمات البرمجية المخصصة)، وبرنامج التدريب والاسم المستعار لكيفية استرجاع بيانات التدريب التاريخية + لقطة من مجموعة التحقق الصغيرة + لقطة من التنبؤات (الاحتمالات المتوقعة للتصنيفات) على مجموعة التحقق هذه.
* توثيق وأدوات لتسهيل إدارة ترقية إصدارات scikit-learn:
	+ حاول تحميل الملف القديم، إذا نجح، استخدم لقطة توقعات مجموعة التحقق للتحقق من أن النموذج المسلسل لا يزال يتصرف بنفس الطريقة؛
	+ إذا لم ينجح joblib.load / pickle.load، استخدم برنامج التدريب الذي يتم التحكم فيه بالإصدار + مجموعة التدريب التاريخية لإعادة تدريب النموذج واستخدم لقطة توقعات مجموعة التحقق للتأكيد على أنه من الممكن استعادة الأداء التنبئي السابق: إذا لم يكن هذا هو الحال، فمن المحتمل أن تكون هناك مشكلة في scikit-learn التي تحتاج إلى الإبلاغ عنها.

1. ينبغي أن يلتزم كل شيء في Scikit-learn بعقد واجهة برمجة التطبيقات لدينا. ما زلنا في طور اتخاذ قرارات بشأن بعض هذه القضايا ذات الصلة.
	* يعدل `Pipeline <pipeline.Pipeline>` و `FeatureUnion` معلمات الإدخال الخاصة بهم في الإعداد. يتطلب إصلاح ذلك التأكد من أن لدينا فهمًا جيدًا لحالات الاستخدام الخاصة بهما للتأكد من الحفاظ على جميع الوظائف الحالية. :issue:`8157` :issue:`7382`

2. (اختياري) تحسين مجموعة الاختبارات الشائعة في scikit-learn للتأكد من أن النماذج (على الأقل المستخدمة بشكل متكرر) لديها تنبؤات مستقرة عبر الإصدارات (لمناقشتها)؛
	* توسيع الوثائق لذكر كيفية نشر النماذج في بيئات خالية من Python على سبيل المثال `ONNX <https://github.com/onnx/sklearn-onnx>`_. واستخدم أفضل الممارسات المذكورة أعلاه لتقييم الاتساق التنبئي بين وظائف التنبؤ scikit-learn و ONNX في مجموعة التحقق.
	* توثيق الممارسات الجيدة للكشف عن الانجراف في التوزيع الزمني للنموذج المنشور والممارسات الجيدة لإعادة التدريب على بيانات جديدة دون التسبب في تراجعات كارثية في الأداء التنبئي.

أهداف خاصة بالمنصة الفرعية

(ملاحظة: لم يتم ترجمة الروابط والتاجات والرموز الخاصة والمعادلات الرياضية والشفرة البرمجية وفقاً للتعليمات)

:mod:`sklearn.ensemble`

* |ss| تنفيذ التكديس، :issue:`11047` |se|

:mod:`sklearn.cluster`

* نسخ kmeans للمسافات غير الإقليدية، إذا استطعنا إثبات أن هذه الفوائد تتجاوز التجميع الهرمي.

:mod:`sklearn.model_selection`

* |ss| التهديف متعدد القياسات بطيء :issue:`9326` |se|
* ربما نريد أن نكون قادرين على استعادة أكثر من مقاييس متعددة
* إن التعامل مع الحالات العشوائية في مقسمات CV هو تصميم رديء ويتعارض مع التحقق من صحة المعلمات المماثلة في أدوات التقدير، `SLEP011 <https://github.com/scikit-learn/enhancement_proposals/pull/24>`_
* استغلال بدء التشغيل الدافئ وخوارزميات المسار حتى يمكن الوصول إلى فوائد كائنات `EstimatorCV` عبر `GridSearchCV` واستخدامها في Pipelines. :issue:`1626`
* يجب أن يكون التحقق المتصالب قادراً على الاستبدال بتقديرات OOB كلما تم استخدام iterator التحقق المتصالب.
* يجب تجنب الحسابات الزائدة في خطوط الأنابيب (ذات صلة بالنقطة المذكورة أعلاه) cf `dask-ml <https://ml.dask.org/hyper-parameter-search.html#avoid-repeated-work>`_

:mod:`sklearn.neighbors`

* |ss| القدرة على استبدال تنفيذ الجيران الأقرب/التقريبي/المحسوب مسبقًا في جميع/معظم السياقات التي يتم استخدامها لتعلم الجيران الأقرب. :issue:`10463` |se|

:mod:`sklearn.pipeline`

* مشكلات الأداء مع `Pipeline.memory`
* انظر "كل شيء في Scikit-learn يجب أن يلتزم بعقد API الخاص بنا" أعلاه

(ملاحظة: تم الاحتفاظ بالرموز الخاصة والأرقام والمعادلات الرياضية والروابط والتاجات والشفرة البرمجية دون ترجمة وفقاً لطلبك.)
