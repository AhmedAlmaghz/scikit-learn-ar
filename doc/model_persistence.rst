
.. _model_persistence:

=================
استمرارية النموذج
====

جدول يلخص أساليب استمرارية النماذج
:widths: 25 50 50
:header-rows: 1

* - أسلوب استمرارية النموذج
  - إيجابيات
  - سلبيات / مخاطر
* - :ref:`ONNX <onnx_persistence>`
  - * خدمة النماذج دون بيئة بايثون
    * بيئات الخدمة والتدريب مستقلة عن بعضها البعض
    * الخيار الأكثر أمانًا
  - * لا يتم دعم جميع نماذج scikit-learn
    * تتطلب المقدرات المخصصة مزيدًا من العمل لدعمها
    * يتم فقدان كائن بايثون الأصلي ولا يمكن إعادة بناؤه
* - :ref:`skops_persistence`
  - * أكثر أمانًا من التنسيقات المستندة إلى `pickle`
    * يمكن التحقق من المحتويات جزئيًا دون التحميل
  - * ليس بالسرعة التنسيقات المستندة إلى `pickle`
    * يدعم أنواعًا أقل من التنسيقات المستندة إلى `pickle`
    * يتطلب نفس البيئة مثل بيئة التدريب
* - :mod:`pickle`
  - * أصلي لبايثون
    * يمكنه تسلسل معظم كائنات بايثون
    * استخدام فعال للذاكرة مع `protocol=5`
  - * يمكن للتحميل تنفيذ رمز عشوائي
    * يتطلب نفس البيئة مثل بيئة التدريب
* - :mod:`joblib`
  - * استخدام فعال للذاكرة
    * يدعم تخطيط الذاكرة
    * طرق مختصرة سهلة للضغط وفك الضغط
  - * تنسيق مستند إلى Pickle
    * يمكن للتحميل تنفيذ رمز عشوائي
    * يتطلب نفس البيئة مثل بيئة التدريب
* - `cloudpickle`_
  - * يمكنه تسلسل رمز بايثون المخصص وغير المعبأ
    * كفاءة تحميل قابلة للمقارنة مثل :mod:`pickle` مع `protocol=5`
  - * تنسيق مستند إلى Pickle
    * يمكن للتحميل تنفيذ رمز عشوائي
    * لا توجد ضمانات للتوافق المستقبل
    * يتطلب نفس البيئة مثل بيئة التدريب

بعد تدريب نموذج scikit-learn، من المرغوب أن يكون لديك طريقة للحفاظ على النموذج للاستخدام في المستقبل دون الحاجة إلى إعادة التدريب. بناءً على حالة الاستخدام الخاصة بك، هناك عدة طرق مختلفة للحفاظ على نموذج scikit-learn، وهنا نساعدك على تحديد الطريقة الأنسب لك. لاتخاذ قرار، تحتاج إلى الإجابة على الأسئلة التالية:

1. هل تحتاج إلى كائن بايثون بعد الاستمرارية، أم أنك تحتاج فقط إلى الاستمرارية من أجل خدمة النموذج والحصول على تنبؤات منه؟

إذا كنت تحتاج فقط إلى خدمة النموذج ولا يلزم إجراء مزيد من التحقيق في كائن بايثون نفسه، فقد يكون :ref:`ONNX <onnx_persistence>` مناسبًا لك. لاحظ أن ONNX لا يدعم جميع النماذج.

في حال عدم ملاءمة ONNX لحالتك، فإن السؤال التالي هو:

2. هل تثق تمامًا في مصدر النموذج، أم أن هناك أي مخاوف أمنية تتعلق بمصدر النموذج المستمر؟

إذا كانت لديك مخاوف أمنية، فيجب أن تفكر في استخدام :ref:`skops.io <skops_persistence>` الذي يعيد لك كائن بايثون، ولكن على عكس حلول الاستمرارية المستندة إلى `pickle`، فإن تحميل النموذج المستمر لا يسمح تلقائيًا بتنفيذ رمز عشوائي. لاحظ أن هذا يتطلب تحقيقًا يدويًا في الملف المستمر، والذي يسمح لك :mod:`skops.io` بالقيام به.

تفترض الحلول الأخرى أنك تثق تمامًا في مصدر الملف ليتم تحميله، لأنها جميعًا عرضة لتنفيذ رمز عشوائي عند تحميل الملف المستمر نظرًا لأنها جميعًا تستخدم بروتوكول التخليل تحت الغطاء.

3. هل تهتم بأداء تحميل النموذج، ومشاركته بين العمليات حيث يكون الكائن المخطط للذاكرة على القرص مفيدًا؟

إذا كانت الإجابة بنعم، فيمكنك التفكير في استخدام :ref:`joblib <pickle_persistence>`. إذا لم يكن هذا مصدر قلق كبير بالنسبة لك، فيمكنك استخدام وحدة :mod:`pickle` المضمنة.

4. هل حاولت استخدام :mod:`pickle` أو :mod:`joblib` ووجدت أنه لا يمكن الاستمرار في النموذج؟ يمكن أن يحدث هذا على سبيل المثال عندما يكون لديك وظائف محددة من قبل المستخدم في نموذجك.

إذا كانت الإجابة بنعم، فيمكنك استخدام `cloudpickle`_ الذي يمكنه تسلسل كائنات معينة لا يمكن تسلسلها بواسطة :mod:`pickle` أو :mod:`joblib`.

نظرة عامة على سير العمل
---------------------

في سير عمل نموذجي، تكون الخطوة الأولى هي تدريب النموذج باستخدام scikit-learn ومكتبات متوافقة مع scikit-learn. لاحظ أن دعم scikit-learn ومقدرات الجهات الخارجية يختلف عبر طرق الاستمرارية المختلفة.

قم بتدريب النموذج واستمراره
...........................

يعتمد إنشاء نموذج مناسب على حالة الاستخدام الخاصة بك. على سبيل المثال، هنا نقوم بتدريب :class:`sklearn.ensemble.HistGradientBoostingClassifier` على مجموعة بيانات iris::

  >>> from sklearn import ensemble
  >>> from sklearn import datasets
  >>> clf = ensemble.HistGradientBoostingClassifier()
  >>> X, y = datasets.load_iris(return_X_y=True)
  >>> clf.fit(X, y)
  HistGradientBoostingClassifier()

بمجرد تدريب النموذج، يمكنك الاستمرار فيه باستخدام الطريقة التي تريدها، وبعد ذلك يمكنك تحميل النموذج في بيئة منفصلة والحصول على تنبؤات منه بالنظر إلى بيانات الإدخال. هنا يوجد مساران رئيسيان اعتمادًا على كيفية استمرارية النموذج وتخطيط خدمته:

- :ref:`ONNX <onnx_persistence>`: تحتاج إلى وقت تشغيل `ONNX` وبيئة مع التبعيات المناسبة المثبتة لتحميل النموذج واستخدام وقت التشغيل للحصول على تنبؤات. يمكن أن تكون هذه البيئة بسيطة ولا تتطلب بالضرورة تثبيت بايثون لتحميل النموذج وحساب التنبؤات. لاحظ أيضًا أن `onnxruntime` يتطلب عادةً ذاكرة وصول عشوائي أقل بكثير من بايثون لحساب التنبؤات من النماذج الصغيرة.

- :mod:`skops.io`, :mod:`pickle`, :mod:`joblib`, `cloudpickle`_: تحتاج إلى بيئة بايثون مع التبعيات المناسبة المثبتة لتحميل النموذج والحصول على تنبؤات منه. يجب أن تحتوي هذه البيئة على نفس **الحزم** و **الإصدارات** مثل البيئة التي تم فيها تدريب النموذج. لاحظ أن أيا من هذه الأساليب لا يدعم تحميل نموذج تم تدريبه بإصدار مختلف من scikit-learn، وربما إصدارات مختلفة من تبعيات أخرى مثل `numpy` و `scipy`. ستكون هناك مخاوف أخرى تتعلق بتشغيل النموذج المستمر على أجهزة مختلفة، وفي معظم الحالات يجب أن تكون قادرًا على تحميل النموذج المستمر على أجهزة مختلفة.

.. _onnx_persistence:

ONNX
---

`ONNX`، أو `Open Neural Network Exchange <https://onnx.ai/>`__ هو تنسيق مناسب للاستخدام في الحالات التي تحتاج فيها إلى الاحتفاظ بالنموذج ثم استخدام القطعة المحفوظة للحصول على التنبؤات دون الحاجة إلى تحميل كائن Python نفسه. وهو أيضًا مفيد في الحالات التي تحتاج فيها بيئة الخدمة إلى أن تكون بسيطة وخفيفة، نظرًا لأن وقت تشغيل `ONNX` لا يتطلب `python`.

`ONNX` هو تسلسل ثنائي للنموذج. وقد تم تطويره لتحسين قابلية استخدام التمثيل المتبادل لنماذج البيانات. وهو يهدف إلى تسهيل تحويل نماذج البيانات بين أطر التعلم الآلي المختلفة، وتحسين قابليتها للنقل على هندسات الحوسبة المختلفة. يمكن الاطلاع على مزيد من التفاصيل من `ONNX tutorial <https://onnx.ai/get-started.html>`__. لتحويل نموذج scikit-learn إلى `ONNX`، تم تطوير `sklearn-onnx <http://onnx.ai/sklearn-onnx/>`__. ومع ذلك، لا يتم دعم جميع نماذج scikit-learn، وهو يقتصر على scikit-learn الأساسي ولا يدعم معظم تقديرات الجهات الخارجية. يمكن كتابة محول مخصص لتقديرات الجهات الخارجية أو المخصصة، ولكن الوثائق للقيام بذلك نادرة وقد يكون من الصعب القيام بذلك.

.. dropdown:: استخدام ONNX

  لتحويل النموذج إلى تنسيق `ONNX`، تحتاج إلى إعطاء المحول بعض المعلومات حول المدخلات أيضًا، والتي يمكنك قراءتها أكثر `هنا <http://onnx.ai/sklearn-onnx/index.html>`__::

      from skl2onnx import to_onnx
      onx = to_onnx(clf, X[:1].astype(numpy.float32), target_opset=12)
      with open("filename.onnx", "wb") as f:
          f.write(onx.SerializeToString())

  يمكنك تحميل النموذج في Python واستخدام وقت تشغيل `ONNX` للحصول على التنبؤات::

      from onnxruntime import InferenceSession
      with open("filename.onnx", "rb") as f:
          onx = f.read()
      sess = InferenceSession(onx, providers=["CPUExecutionProvider"])
      pred_ort = sess.run(None, {"X": X_test.astype(numpy.float32)})[0]

.. _skops_persistence:

`skops.io`
----------

:mod:`skops.io` يتجنب استخدام :mod:`pickle` ويحمل فقط الملفات التي لها أنواع وإشارات إلى وظائف موثوق بها إما بشكل افتراضي أو من قبل المستخدم. وبالتالي، فإنه يوفر تنسيقًا أكثر أمانًا من :mod:`pickle` و:mod:`joblib` و`cloudpickle`_.


.. dropdown:: استخدام skops

  إن واجهة برمجة التطبيقات مشابهة جدًا لـ:mod:`pickle`، ويمكنك الاحتفاظ بنماذجك كما هو موضح في `الوثائق <https://skops.readthedocs.io/en/stable/persistence.html>`__ باستخدام :func:`skops.io.dump` و:func:`skops.io.dumps`::

      import skops.io as sio
      obj = sio.dump(clf, "filename.skops")

  ويمكنك تحميلها مرة أخرى باستخدام :func:`skops.io.load` و:func:`skops.io.loads`. ومع ذلك، تحتاج إلى تحديد الأنواع الموثوق بها من قبلك. يمكنك الحصول على الأنواع غير المعروفة الموجودة في كائن/ملف محمل باستخدام :func:`skops.io.get_untrusted_types`، وبعد التحقق من محتوياتها، قم بتمريرها إلى دالة التحميل::

      unknown_types = sio.get_untrusted_types(file="filename.skops")
      # تحقق من محتويات unknown_types، وقم بالتحميل فقط إذا كنت تثق بكل ما تراه.
      clf = sio.load("filename.skops", trusted=unknown_types)

  يرجى الإبلاغ عن المشكلات وطلبات الميزات المتعلقة بهذا التنسيق على `skops issue tracker <https://github.com/skops-dev/skops/issues>`__.


.. _pickle_persistence:

`pickle` و`joblib` و`cloudpickle`
-------------------------------------

هذه الوحدات النمطية / الحزم الثلاثة، تستخدم بروتوكول `pickle` تحت الغطاء، ولكنها تأتي مع اختلافات طفيفة:

- :mod:`pickle` هي وحدة نمطية من مكتبة Python القياسية. يمكنها تسلسلية وإلغاء تسلسل أي كائن Python، بما في ذلك فئات وكائنات Python المخصصة.
- :mod:`joblib` أكثر كفاءة من `pickle` عند العمل مع نماذج التعلم الآلي الكبيرة أو صفائف numpy الكبيرة.
- `cloudpickle`_ يمكنه تسلسلية بعض الكائنات التي لا يمكن تسلسليها بواسطة :mod:`pickle` أو :mod:`joblib`، مثل الوظائف المعرفة من قبل المستخدم ووظائف لامدا. يمكن أن يحدث هذا على سبيل المثال، عند استخدام :class:`~sklearn.preprocessing.FunctionTransformer` واستخدام دالة مخصصة لتحويل البيانات.

.. dropdown:: استخدام `pickle` أو `joblib` أو `cloudpickle`

  اعتمادًا على حالتك، يمكنك اختيار إحدى هذه الطرق الثلاث للاحتفاظ بنموذج scikit-learn وتحميله، وجميعها تتبع نفس واجهة برمجة التطبيقات::

      # يمكنك هنا استبدال pickle بـ joblib أو cloudpickle
      from pickle import dump
      with open("filename.pkl", "wb") as f:
          dump(clf, f, protocol=5)

  يوصى باستخدام `protocol=5` لتقليل استخدام الذاكرة وجعل تخزين وتحميل أي صفيف NumPy كبير مخزن كخاصية مجهزة في النموذج أسرع. يمكنك بدلاً من ذلك تمرير `protocol=pickle.HIGHEST_PROTOCOL` وهو ما يعادل `protocol=5` في Python 3.8 والأحدث (في وقت الكتابة).

  ويمكنك لاحقًا عند الحاجة، تحميل نفس الكائن من الملف المحفوظ::

      # يمكنك هنا استبدال pickle بـ joblib أو cloudpickle
      from pickle import load
      with open("filename.pkl", "rb") as f:
          clf = load(f)

.. _persistence_limitations:

قيود الأمان والصيانة
--------------------------------------

تحتوي وحدة :mod:`pickle` (ووحدات :mod:`joblib` و :mod:`clouldpickle` بالامتداد) على العديد من الثغرات الأمنية الموثقة بسبب تصميمها، ويجب استخدامها فقط إذا كان المصدر الموثوق به والتحقق منه هو مصدر ملف pickle، أي نموذج التعلم الآلي. يجب عدم تحميل ملف pickle من مصدر غير موثوق به، على غرار عدم تنفيذ التعليمات البرمجية من مصدر غير موثوق به.

لاحظ أيضًا أنه يمكن تمثيل العمليات الحسابية التعسفية باستخدام تنسيق `ONNX`، لذلك يوصى بتقديم النماذج باستخدام `ONNX` في بيئة صندوق الرمل للحماية من عمليات الاستغلال الحسابية والذاكرة.

لاحظ أيضًا أنه لا توجد طرق مدعومة لتحميل نموذج تم تدريبه بإصدار مختلف من scikit-learn. أثناء استخدام :mod:`skops.io`، :mod:`joblib`، :mod:`pickle`، أو `cloudpickle`_، قد يتم تحميل النماذج المحفوظة باستخدام إصدار واحد من scikit-learn في إصدارات أخرى، ولكن هذا غير مدعوم بالكامل وغير مستحسن. يجب أيضًا أن تضع في اعتبارك أن العمليات التي يتم إجراؤها على هذه البيانات يمكن أن تعطي نتائج مختلفة وغير متوقعة، أو حتى تتسبب في تعطل عملية Python الخاصة بك.

من أجل إعادة بناء نموذج مشابه مع الإصدارات المستقبلية من scikit-learn، يجب حفظ بيانات إضافية بجانب النموذج المحفوظ:

* بيانات التدريب، مثل مرجع إلى لقطة غير قابلة للتغيير
* شفرة المصدر Python المستخدمة لتوليد النموذج
* إصدارات scikit-learn وتبعياتها
* نتيجة التحقق المتقاطع التي تم الحصول عليها على بيانات التدريب

يجب أن يتيح هذا إمكانية التحقق من أن نتيجة التحقق المتقاطع تقع في نفس النطاق كما كانت من قبل.

باستثناء بعض الاستثناءات، يجب أن تكون النماذج الثابتة محمولة عبر أنظمة التشغيل ومعماريات الأجهزة بشرط استخدام نفس الإصدارات من التبعية و Python. إذا واجهت مُقدرًا غير قابل للنقل، فيرجى فتح مشكلة على GitHub. غالبًا ما يتم نشر النماذج الثابتة في الإنتاج باستخدام حاويات مثل Docker، وذلك لتجميد البيئة والتبعيات.

إذا كنت تريد معرفة المزيد عن هذه المشكلات، فيرجى الرجوع إلى هذه المحادثات:

- `أدريان جلالي: دعونا نستغل pickle، و skops للإنقاذ! | PyData أمستردام 2023 <https://www.youtube.com/watch?v=9w_H5OSTO9A>`__.
- `أليكس جاينور: المخللات للمطاعم، وليست للبرامج - PyCon 2014 <https://pyvideo.org/video/2566/pickles-are-for-delis-not-software>`__.


.. _serving_environment:

تكرار بيئة التدريب في الإنتاج
.........................................

إذا اختلفت إصدارات التبعيات المستخدمة من التدريب إلى الإنتاج، فقد ينتج عن ذلك سلوك غير متوقع وأخطاء أثناء استخدام النموذج المدرب. لمنع مثل هذه المواقف، يوصى باستخدام نفس التبعيات والإصدارات في كل من بيئة التدريب والإنتاج. يمكن تثبيت هذه التبعيات العابرة باستخدام أدوات إدارة الحزم مثل `pip`، `mamba`، `conda`، `poetry`، `conda-lock`، `pixi`، إلخ.

ليس من الممكن دائمًا تحميل نموذج تم تدريبه بإصدارات أقدم من مكتبة scikit-learn وتبعياتها في بيئة برامج محدثة. بدلاً من ذلك، قد تحتاج إلى إعادة تدريب النموذج باستخدام الإصدارات الجديدة من جميع المكتبات. لذلك عند تدريب النموذج، من المهم تسجيل وصفة التدريب (مثل برنامج Python النصي) ومعلومات مجموعة التدريب، والبيانات الوصفية حول جميع التبعيات لتكون قادرًا على إعادة بناء نفس بيئة التدريب تلقائيًا لبرنامج محدث.

.. dropdown:: InconsistentVersionWarning

  عند تحميل مُقدر بإصدار scikit-learn غير متسق مع الإصدار الذي تم تخزينه فيه، يتم رفع :class:`~sklearn.exceptions.InconsistentVersionWarning`. يمكن الإمساك بهذا التحذير للحصول على الإصدار الأصلي الذي تم تخزين المُقدر فيه::

    من sklearn.exceptions استورد InconsistentVersionWarning
    warnings.simplefilter("error", InconsistentVersionWarning)

    حاول:
        مع open("model_from_prevision_version.pickle", "rb") ك f:
            est = pickle.load(f)
    إلا InconsistentVersionWarning ك w:
        print(w.original_sklearn_version)


خدمة عرض النموذج
..........................

الخطوة الأخيرة بعد تدريب نموذج scikit-learn هي خدمة النموذج. بمجرد تحميل النموذج المدرب بنجاح، يمكن تقديمه لإدارة طلبات التنبؤ المختلفة. يمكن أن يشمل ذلك نشر النموذج كخدمة ويب باستخدام الحاويات، أو استراتيجيات نشر نموذج أخرى، وفقًا للمواصفات.


تلخيص النقاط الرئيسية

    
 PAD

بناءً على النهج المختلفة لاستدامة النموذج، يمكن تلخيص النقاط الرئيسية لكل نهج على النحو التالي:

* `ONNX`: يوفر تنسيقًا موحدًا لاستدامة أي نموذج للتعلم الآلي أو التعلم العميق (بخلاف scikit-learn) وهو مفيد لاستدلال النموذج (التنبؤات). ومع ذلك، يمكن أن يؤدي إلى مشكلات التوافق مع أطر عمل مختلفة.
* :mod:`skops.io`: يمكن مشاركة نماذج scikit-learn المدربة بسهولة ووضعها في الإنتاج باستخدام :mod:`skops.io`. وهي أكثر أمانًا مقارنة بالنهج البديلة القائمة على :mod:`pickle` لأنها لا تقوم بتحميل التعليمات البرمجية التعسفية ما لم يطلب المستخدم ذلك صراحة. يجب تعبئة هذه التعليمات البرمجية وجعلها قابلة للاستيراد في بيئة Python المستهدفة.
* :mod:`joblib`: تجعل تقنيات تعيين الذاكرة الفعالة من الأسرع عند استخدام نفس النموذج المستدام في عمليات Python متعددة عند استخدام `mmap_mode="r"`. كما يوفر طرقًا مختصرة سهلة لضغط وفك ضغط الكائن المستدام دون الحاجة إلى رمز إضافي. ومع ذلك، قد يؤدي ذلك إلى تشغيل رمز ضار عند تحميل نموذج من مصدر غير موثوق به مثل أي آلية استدامة أخرى قائمة على pickle.
* :mod:`pickle`: وهي أصلية في Python ويمكن تسلسل معظم كائنات Python وإلغاء تسلسلها باستخدام :mod:`pickle`، بما في ذلك فئات ووظائف Python المخصصة طالما أنها معرفة في حزمة يمكن استيرادها في البيئة المستهدفة. بينما يمكن استخدام :mod:`pickle` بسهولة لحفظ وتحميل نماذج scikit-learn، فقد يؤدي ذلك إلى تشغيل رمز ضار أثناء تحميل نموذج من مصدر غير موثوق به. يمكن أن يكون :mod:`pickle` فعالًا جدًا من حيث الذاكرة إذا تم الاحتفاظ بالنموذج مع `protocol=5` ولكنه لا يدعم تعيين الذاكرة.
* `cloudpickle`\_: لديه كفاءة تحميل مماثلة لـ :mod:`pickle` و :mod:`joblib` (بدون تعيين الذاكرة)، لكنه يوفر مرونة إضافية لتسلسل رمز Python المخصص مثل عبارات lambda والوظائف والفئات المحددة بشكل تفاعلي. قد يكون الملجأ الأخير للاحتفاظ بخطوط الأنابيب باستخدام مكونات Python المخصصة مثل :class:`sklearn.preprocessing.FunctionTransformer` التي تلتف حول وظيفة معرفة في برنامج التدريب نفسه أو بشكل عام خارج أي حزمة Python قابلة للاستيراد. لاحظ أن `cloudpickle`\_ لا يقدم أي ضمانات للتوافق المستقبلي وقد تحتاج إلى نفس إصدار `cloudpickle`\_ لتحميل النموذج المستدام جنبًا إلى جنب مع نفس الإصدار من جميع المكتبات المستخدمة لتعريف النموذج. مثل آليات الاستدامة الأخرى المستندة إلى pickle، قد يؤدي ذلك إلى تشغيل رمز ضار أثناء تحميل نموذج من مصدر غير موثوق به.

.. _cloudpickle: https://github.com/cloudpipe/cloudpickle
