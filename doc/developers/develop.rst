هذا نص بتنسيق RST أريد ترجمته إلى اللغة العربية، مع الحفاظ على الرموز الخاصة والرموز والمعادلات الرياضية والروابط والتاجات والشفرة البرمجية:

.. _develop:

==================================
تطوير مقدرات scikit-learn
==================================

سواء كنت تقترح مقدرًا لإدراجه في scikit-learn، أو تقوم بتطوير حزمة منفصلة متوافقة مع scikit-learn، أو تقوم بتنفيذ مكونات مخصصة لمشاريعك الخاصة، يوضح هذا الفصل كيفية تطوير كائنات تتفاعل بأمان مع خطوط أنابيب scikit-learn وأدوات اختيار النموذج.

.. currentmodule:: sklearn

.. _api_overview:

واجهات برمجة التطبيقات لكائنات scikit-learn

(ملاحظة: لا يمكن ترجمة الرموز الخاصة والرموز والمعادلات الرياضية والروابط والتاجات والشفرة البرمجية، لذلك تم الإبقاء عليها كما هي في النص الأصلي.)

هذا نص بتنسيق RST أريد ترجمته إلى اللغة العربية، مع الحفاظ على الرموز الخاصة والرموز والمعادلات الرياضية والروابط والتاجات والشفرة البرمجية كما هي:

============================

للحصول على واجهة برمجة تطبيقات موحدة، نحاول الحصول على واجهة برمجة تطبيقات أساسية مشتركة لجميع الكائنات. بالإضافة إلى ذلك، لتجنب انتشار رمز الإطار، نحاول تبني اتفاقيات بسيطة والحد من عدد الأساليب التي يجب أن يطبقها الكائن إلى الحد الأدنى.

يتم وصف عناصر واجهة برمجة تطبيقات scikit-learn بشكل أكثر تحديدًا في :ref:`glossary`.

الكائنات المختلفة
-----------------

الكائنات الرئيسية في scikit-learn هي (يمكن لفئة واحدة تنفيذ واجهات متعددة):

:Estimator:

    الكائن الأساسي، يطبق طريقة ``fit`` للتعلم من البيانات، إما::

      estimator = estimator.fit(data, targets)

    أو::

      estimator = estimator.fit(data)

:Predictor:

    للتعلم الخاضع للإشراف، أو لبعض المشكلات غير الخاضعة للإشراف، يطبق::

      prediction = predictor.predict(data)

    تقدم خوارزميات التصنيف عادةً أيضًا طريقة لتقييم التأكد من التنبؤ، إما باستخدام ``decision_function`` أو ``predict_proba``::

      probability = predictor.predict_proba(data)

:Transformer:

    لتعديل البيانات بطريقة خاضعة للإشراف أو غير خاضعة للإشراف (على سبيل المثال، عن طريق إضافة أو تغيير أو إزالة الأعمدة، ولكن ليس عن طريق إضافة أو إزالة الصفوف). يطبق::

      new_data = transformer.transform(data)

    عندما يمكن إجراء الملاءمة والتحويل بشكل أكثر كفاءة معًا من بشكل منفصل، يطبق::

      new_data = transformer.fit_transform(data)

:Model:

    نموذج يمكنه إعطاء مقياس "جودة الملاءمة" أو احتمالية بيانات غير مرئية، يطبق (كلما ارتفع كان أفضل)::

      score = model.score(data)

Estimators

    
```

حافظتُ على الرموز الخاصة والرموز والمعادلات الرياضية والروابط والتاجات والشفرة البرمجية كما هي في الترجمة.

إن الواجهة البرمجية التطبيقية (API) تحتوي على كائن أساسي واحد هو المقدّر (estimator). المقدّر هو كائن يلائم نموذجًا بناءً على بعض بيانات التدريب ويكون قادرًا على استنتاج بعض الخصائص على بيانات جديدة. يمكن أن يكون مثلا مصنفًا أو مقاربًا. جميع المقدّرات تنفذ طريقة التلائم (fit)::

    estimator.fit(X, y)

كافة المقدّرات المضمنة لديها أيضًا طريقة ``set_params``، والتي تقوم بتعيين معلمات غير معتمدة على البيانات (تجاوز قيم المعلمات السابقة التي تم تمريرها إلى ``__init__``).

يجب أن ترث كافة المقدّرات في الشفرة المصدرية الرئيسية لـ scikit-learn من ``sklearn.base.BaseEstimator``.

إنشاء كائن
^^^^^^^^^^

يتعلق هذا بإنشاء كائن. قد تقبل طريقة ``__init__`` الخاصة بالكائن ثوابت كوسائط تحدد سلوك المقدّر (مثل الثابت C في SVMs). ومع ذلك، لا ينبغي أن تأخذ بيانات التدريب الفعلية كوسيطة، حيث يتم ترك ذلك لأسلوب ``fit()``::

    clf2 = SVC(C=2.3)
    clf3 = SVC([[1, 2], [2, 3]], [-1, 1]) # خاطئ!

يجب أن تكون كافة الوسائط التي تقبلها ``__init__`` وسائط كلمات رئيسية مع قيمة افتراضية. بمعنى آخر، يجب أن يكون المستخدم قادرًا على إنشاء مقدّر دون تمرير أي وسائط إليه. يجب أن تتوافق كافة الوسائط مع المعلمات الفائقة التي تصف النموذج أو مشكلة التحسين

التي يحاول المقدّر حلها. تتذكر المقدّر دائمًا هذه الوسائط الأولية (أو المعلمات).لاحظ أيضًا أنه لا ينبغي توثيقها تحت قسم "Attributes"، ولكن تحت قسم "Parameters" لهذا المقدّر.

بالإضافة إلى ذلك، يجب أن **يتوافق كل وسيط كلمات رئيسية تقبله ``__init__`` مع خاصية في المثيل**. يعتمد Scikit-learn على ذلك للعثور على الخصائص ذات الصلة لتعيينها على المقدّر عند القيام باختيار النموذج.

تلخيصًا، يجب أن تبدو ``__init__`` كالتالي::

    def __init__(self, param1=1, param2=2):
        self.param1 = param1
        self.param2 = param2

لا ينبغي أن يكون هناك أي منطق، ولا حتى التحقق من صحة المدخلات،
ولا ينبغي تغيير المعلمات.
يجب وضع المنطق المقابل حيث يتم استخدام المعلمات،
عادةً في ``fit``.
ما يلي خاطئ::

    def __init__(self, param1=1, param2=2, param3=3):
        # خاطئ: لا ينبغي تعديل المعلمات
        if param1 > 1:
            param2 += 1
        self.param1 = param1
        # خاطئ: يجب أن يكون للسمات الخاصة بالكائن نفس اسم
        # الوسيط في المنشئ
        self.param3 = param2

السبب في تأجيل التحقق من الصحة هو أنه يجب تنفيذ نفس التحقق
في ``set_params``،
والذي يتم استخدامه في خوارزميات مثل ``GridSearchCV``.

التلائم
^^^^^^^

الشيء التالي الذي قد ترغب في القيام به على الأرجح هو تقدير بعض
المعلمات في النموذج. يتم تنفيذ هذا في طريقة ``fit()``.

تأخذ طريقة ``fit()`` بيانات التدريب كوسائط، والتي يمكن أن تكون مصفوفة واحدة في حالة التعلم غير الخاضع للإشراف، أو مصفوفتين في حالة
التعلم الخاضع للإشراف.

لاحظ أنه يتم ملاءمة النموذج باستخدام ``X`` و ``y``، ولكن الكائن لا يحتوي على أي مرجع إلى ``X`` و ``y``. ومع ذلك، هناك بعض الاستثناءات لهذا، كما هو الحال في
حالة النوى المحسوبة مسبقًا حيث يجب تخزين هذه البيانات لاستخدامها بواسطة
طريقة التنبؤ.

============= ======================================================
المعلمات
============= ======================================================
X             شبيه بالمصفوفة من الشكل (n_samples, n_features)

y             شبيه بالمصفوفة من الشكل (n_samples,)

kwargs        معلمات اختيارية تعتمد على البيانات
============= ======================================================

يجب أن يكون ``X.shape[0]`` هو نفس ``y.shape[0]``. إذا لم يتم استيفاء هذا الشرط،
يجب طرح استثناء من النوع ``ValueError``.

يمكن تجاهل ``y`` في حالة التعلم غير الخاضع للإشراف. ومع ذلك، ل
جعل من الممكن استخدام المقدّر كجزء من خط أنابيب يمكنه
خلط كلاً من المحولات الخاضعة للإشراف وغير الخاضعة للإشراف، حتى المقدّرات غير الخاضعة للإشراف
تحتاج إلى قبول وسيطة ``y=None`` في الموضع الثاني الذي يتجاهله المقدّر ببساطة.
لنفس السبب، تحتاج طرق ``fit_predict`` و ``fit_transform`` و ``score``
و ``partial_fit`` إلى قبول وسيطة ``y`` في
المكان الثاني إذا تم تنفيذها.

يجب أن تعيد الطريقة الكائن (``self``). هذا النمط مفيد
لتكون قادرًا على تنفيذ عبارات سريعة من سطر واحد في جلسة IPython مثل::

  y_predicted = SVC(C=100).fit(X_train, y_train).predict(X_test)

اعتمادًا على طبيعة الخوارزمية، يمكن أن تقبل ``fit`` أحيانًا أيضًا
وسائط كلمات رئيسية إضافية. ومع ذلك، يجب أن تكون أي معلمة يمكن
تعيين قيمة لها قبل الوصول إلى البيانات هي وسيطة كلمات رئيسية لـ ``__init__``. **يجب تقييد معلمات fit على متغيرات تعتمد مباشرة على البيانات**. على سبيل المثال، مصفوفة Gram أو
مصفوفة التقارب التي تم حسابها مسبقًا من مصفوفة البيانات ``X``
تعتمد على البيانات. معيار التوقف ``tol`` ليس معتمدًا بشكل مباشر على البيانات (على الرغم من أن القيمة المثلى وفقًا لبعض وظائف التقييم ربما تكون كذلك).

عند استدعاء ``fit``، يجب تجاهل أي استدعاء سابق لـ ``fit``. بشكل
عام، يجب أن يكون استدعاء ``estimator.fit(X1)`` ثم ``estimator.fit(X2)``
نفس الشيء مثل استدعاء ``estimator.fit(X2)`` فقط. ومع ذلك، قد لا يكون هذا
صحيحًا في الممارسة عندما يعتمد ``fit`` على بعض العمليات العشوائية، انظر
:term:`random_state`. استثناء آخر لهذه القاعدة هو عندما
يتم تعيين المعلمة الفائقة ``warm_start`` على ``True`` للمقدّرات التي
تدعمها. ``warm_start=True`` تعني أنه يتم إعادة استخدام الحالة السابقة للمعالم القابلة للتدريب للمقدّر بدلاً من استخدام
استراتيجية التهيئة الافتراضية.

السمات المقدرة
^^^^^^^^^^^^^^

يجب أن تنتهي أسماء السمات التي تم تقديرها من البيانات دائمًا
بتسطير ختامي، على سبيل المثال سيتم تخزين معاملات
مقدّر الانحدار في سمة ``coef_`` بعد
استدعاء ``fit``.

من المتوقع تجاوز السمات المقدرة عند استدعاء ``fit``
للمرة الثانية.

وسائط اختيارية
^^^^^^^^^^^^^^

في الخوارزميات التكرارية، يجب تحديد عدد التكرارات بواسطة
عدد صحيح يسمى ``n_iter``.
    

(ملاحظة: رمز الب Idéale هو تركيبة خاصة من الأحرف تدل على نهاية القسم في لغة RST وليس لها معنى في هذه الترجمة، لذا لم يتم ترجمتها)

السمات العالمية
^^^^^^^^^^^^^^^^^^

يجب على المقدرين الذين يتوقعون إدخال جدولي أن يحددوا سمة `n_features_in_` في وقت التهيئة (`fit`) للإشارة إلى عدد السمات التي يتوقعها المقدّر للاستدعاءات اللاحقة لوظيفتي `predict` أو `transform`. راجع `SLEP010 <https://scikit-learn-enhancement-proposals.readthedocs.io/en/latest/slep010/proposal.html>`_ للحصول على التفاصيل.

.. _rolling_your_own_estimator:

إنشاء المقدّر الخاص بك

(ملاحظة: النص السابق يحتوي على رابط لا يمكن ترجمته، وقد تم الاحتفاظ به كما هو في الترجمة العربية.)

إذا كنت ترغب في تنفيذ أداة تقدير جديدة متوافقة مع Scikit-learn، سواء كان ذلك فقط للاستخدام الشخصي أو للمساهمة في Scikit-learn، فهناك العديد من الأشياء الداخلية في Scikit-learn التي يجب أن تكون على دراية بها بالإضافة إلى واجهة برمجة التطبيقات (API) الخاصة بـ Scikit-learn المذكورة أعلاه. يمكنك التحقق مما إذا كانت أداة التقدير الخاصة بك تلتزم بواجهة Scikit-learn والمعايير عن طريق تشغيل `check_estimator` على نسخة منها. يمكن أيضًا استخدام ديكور اختبار `parametrize_with_checks` (راجع سلاسل الوثائق الخاصة به للتفاصيل والتفاعلات المحتملة مع `pytest`)::

  >>> from sklearn.utils.estimator_checks import check_estimator
  >>> from sklearn.svm import LinearSVC
  >>> check_estimator(LinearSVC())  # passes

قد يكون الدافع الرئيسي لجعل فصل متوافق مع واجهة أداة تقدير Scikit-learn هو أنك تريد استخدامه مع أدوات تقييم واختيار النموذج مثل `model_selection.GridSearchCV` و `pipeline.Pipeline`.

قبل تفصيل واجهة المطلوب أدناه، نصف طريقتين لتحقيق الواجهة الصحيحة بسهولة أكبر.

.. topic:: قالب المشروع:

    نقدم `قالب مشروع <https://github.com/scikit-learn-contrib/project-template/>`_ الذي يساعد في إنشاء حزم Python تحتوي على أدوات تقدير متوافقة مع Scikit-learn. يوفر:

    * مستودع git أولي به بنية دليل حزمة Python
    * قالب لأداة تقدير Scikit-learn
    * مجموعة اختبار أولية بما في ذلك استخدام `check_estimator`
    * هياكل ونصوص الدليل لتجميع الوثائق ومعرض الأمثلة
    * نصوص لإدارة التكامل المستمر (الاختبار على Linux و Windows)
    * تعليمات من البدء إلى النشر على `PyPi <https://pypi.org/>`_

.. topic:: "BaseEstimator" و mixins:

    نميل إلى استخدام "تدقيق البطة"، لذلك فإن بناء أداة تقدير تتبع واجهة برمجة التطبيقات تكفي للتوافق، دون الحاجة إلى ورثة أو حتى استيراد أي فئات Scikit-learn.

    ومع ذلك، إذا كان الاعتماد على Scikit-learn مقبولاً في التعليمات البرمجية الخاصة بك، يمكنك منع الكثير من رمز المرجل من خلال اشتقاق فئة من "BaseEstimator" واختياريًا فئات mixin في "sklearn.base". على سبيل المثال، أدناه يوجد مصنف مخصص، مع المزيد من الأمثلة المضمنة في Scikit-learn-contrib `قالب المشروع <https://github.com/scikit-learn-contrib/project-template/blob/master/skltemplate/_template.py>`__.

    من المهم بشكل خاص ملاحظة أن mixins يجب أن تكون "على اليسار" بينما يجب أن يكون "BaseEstimator" "على اليمين" في قائمة الميراث من أجل MRO مناسب.

      >>> import numpy as np
      >>> from sklearn.base import BaseEstimator, ClassifierMixin
      >>> from sklearn.utils.validation import check_X_y, check_array, check_is_fitted
      >>> from sklearn.utils.multiclass import unique_labels
      >>> from sklearn.metrics import euclidean_distances
      >>> class TemplateClassifier(ClassifierMixin, BaseEstimator):
      ...
      ...     def __init__(self, demo_param='demo'):
      ...         self.demo_param = demo_param
      ...
      ...     def fit(self, X, y):
      ...
      ...         # Check that X and y have correct shape
      ...         X, y = check_X_y(X, y)
      ...         # Store the classes seen during fit
      ...         self.classes_ = unique_labels(y)
      ...
      ...         self.X_ = X
      ...         self.y_ = y
      ...         # Return the classifier
      ...         return self
      ...
      ...     def predict(self, X):
      ...
      ...         # Check if fit has been called
      ...         check_is_fitted(self)
      ...
      ...         # Input validation
      ...         X = check_array(X)
      ...
      ...         closest = np.argmin(euclidean_distances(X, self.X_), axis=1)
      ...         return self.y_[closest]

get_params و set_params

    

الترجمة من الإنجليزية إلى العربية:

إذا كنت ترغب في تنفيذ أداة تقدير جديدة متوافقة مع Scikit-learn، سواءً كان ذلك للاستخدام الشخصي أو للمساهمة في Scikit-learn، فيجب أن تكون على دراية ببعض الأشياء الداخلية في Scikit-learn بالإضافة إلى واجهة برمجة التطبيقات المذكورة أعلاه. يمكنك التحقق من توافق أداة التقدير الخاصة بك مع واجهة Scikit-learn والمعايير عن طريق تشغيل `check_estimator` على نسخة منها. يمكن استخدام ديكور اختبار `parametrize_with_checks` للتحقق من التوافق (راجع سلاسل الوثائق الخاصة به للتفاصيل والتفاعلات المحتملة مع `pytest`)::

  >>> from sklearn.utils.estimator_checks import check_estimator
  >>> from sklearn.svm import LinearSVC
  >>> check_estimator(LinearSVC())  # passes

قد يكون السبب الرئيسي لجعل فصل متوافق مع واجهة أداة تقدير Scikit-learn هو أنك تريد استخدامه مع أدوات تقييم واختيار النموذج مثل `model_selection.GridSearchCV` و `pipeline.Pipeline`.

قبل شرح واجهة المطلوب بالتفصيل، سنشرح طريقتين لتحقيق الواجهة الصحيحة بسهولة أكبر.

.. topic:: قالب المشروع:

    نقدم `قالب مشروع <https://github.com/scikit-learn-contrib/project-template/>`_ الذي يساعد في إنشاء حزم Python تحتوي على أدوات تقدير متوافقة مع Scikit-learn. يوفر القالب:

    * مستودع git أولي به بنية دليل حزمة Python
    * قالب لأداة تقدير Scikit-learn
    * مجموعة اختبار أولية بما في ذلك استخدام `check_estimator`
    * هياكل ونصوص الدليل لتجميع الوثائق ومعرض الأمثلة
    * نصوص لإدارة التكامل المستمر (الاختبار على Linux و Windows)
    * تعليمات من البدء إلى النشر على `PyPi <https://pypi.org/>`_

.. topic:: "BaseEstimator" و mixins:

    نميل إلى استخدام "تدقيق البطة"، لذلك فإن بناء أداة تقدير تتبع واجهة برمجة التطبيقات تكفي للتوافق، دون الحاجة إلى ورثة أو حتى استيراد أي فئات Scikit-learn.

    ومع ذلك، إذا كان الاعتماد على Scikit-learn مقبولاً في التعليمات البرمجية الخاصة بك، يمكنك منع الكثير من رمز المرجل من خلال اشتقاق فئة من "BaseEstimator" واختياريًا فئات mixin في "sklearn.base". على سبيل المثال، أدناه يوجد مصنف مخصص، مع المزيد من الأمثلة المضمنة في Scikit-learn-contrib `قالب المشروع <https://github.com/scikit-learn-contrib/project-template/blob/master/skltemplate/_template.py>`__.

    من المهم بشكل خاص ملاحظة أن mixins يجب أن تكون "على اليسار" بينما يجب أن يكون "BaseEstimator" "على اليمين" في قائمة الميراث من أجل MRO مناسب.

      >>> import numpy as np
      >>> from sklearn.base import BaseEstimator, ClassifierMixin
      >>> from sklearn.utils.validation import check_X_y, check_array, check_is_fitted
      >>> from sklearn.utils.multiclass import unique_labels
      >>> from sklearn.metrics import euclidean_distances
      >>> class TemplateClassifier(ClassifierMixin, BaseEstimator):
      ...
      ...     def __init__(self, demo_param='demo'):
      ...         self.demo_param = demo_param
      ...
      ...     def fit(self, X, y):
      ...
      ...         # Check that X and y have correct shape
      ...         X, y = check_X_y(X, y)
      ...         # Store the classes seen during fit
      ...         self.classes_ = unique_labels(y)
      ...
      ...         self.X_ = X
      ...         self.y_ = y
      ...         # Return the classifier
      ...         return self
      ...
      ...     def predict(self, X):
      ...
      ...         # Check if fit has been called
      ...         check_is_fitted(self)
      ...
      ...         # Input validation
      ...         X = check_array(X)
      ...
      ...        
  جميع مقدرات scikit-learn لديها وظائف "get_params" و "set_params".

    تأخذ وظيفة "get_params" أي وسيطات وتعيد قاموسًا من باراميترات "__init__" للمقدر، بالإضافة إلى قيمها.

    يجب أن تأخذ وسيطة كلمة رئيسية واحدة، "deep"، والتي تتلقى قيمة منطقية تحدد ما إذا كانت الطريقة يجب أن تعيد باراميترات التقديرات الفرعية (بالنسبة لمعظم المقدرّات، يمكن تجاهل ذلك). القيمة الافتراضية لـ "deep" يجب أن تكون "True". على سبيل المثال، مع الأخذ في الاعتبار المقدّر التالي:

    >>> from sklearn.base import BaseEstimator
    >>> from sklearn.linear_model import LogisticRegression
    >>> class MyEstimator(BaseEstimator):
    ...     def __init__(self, subestimator=None, my_extra_param="random"):
    ...         self.subestimator = subestimator
    ...         self.my_extra_param = my_extra_param

    ستتحكم الباراميترات "deep" في ما إذا كانت باراميترات "subestimator" يجب الإبلاغ عنها أم لا. وبالتالي عندما يكون "deep=True"، ستكون النتيجة::

    >>> my_estimator = MyEstimator(subestimator=LogisticRegression())
    >>> for param, value in my_estimator.get_params(deep=True).items():
    ...     print(f"{param} -> {value}")
    my_extra_param -> random
    subestimator__C -> 1.0
    subestimator__class_weight -> None
    subestimator__dual -> False
    ...

    في حين أنه عندما يكون "deep=False"، ستكون النتيجة::

    >>> for param, value in my_estimator.get_params(deep=False).items():
    ...     print(f"{param} -> {value}")
    my_extra_param -> random
    subestimator -> LogisticRegression()

    من ناحية أخرى، تأخذ "set_params" باراميترات "__init__" كوسيطات للكلمات الرئيسية، وتفككها في قاموس من النموذج "بارامتر": قيمة وتعيين باراميترات المقدّر باستخدام هذا القاموس. يجب أن تكون قيمة الإرجاع المقدّر نفسه.

    على الرغم من أن آلية "get_params" ليست ضرورية (انظر :ref:`cloning` أدناه)، فإن وظيفة "set_params" ضرورية لأنها تستخدم لتعيين باراميترات أثناء عمليات البحث في الشبكة.

    أسهل طريقة لتنفيذ هذه الوظائف، والحصول على طريقة "\_\_repr\_\_" معقولة، هي أن ترث من "sklearn.base.BaseEstimator". إذا كنت لا تريد أن تجعل الكود الخاص بك يعتمد على scikit-learn، فإن أسهل طريقة لتنفيذ الواجهة هي::

        def get_params(self, deep=True):
            # لنفترض أن هذا المقدّر لديه باراميترات "alpha" و "recursive"
            return {"alpha": self.alpha, "recursive": self.recursive}

        def set_params(self, **parameters):
            for parameter, value in parameters.items():
                setattr(self, parameter, value)
            return self

    باراميترات و init
    -------------------
    نظرًا لأن :class:`model_selection.GridSearchCV` يستخدم "set_params" لتطبيق إعداد باراميترات على المقدّرين، فمن الضروري أن يكون لاستدعاء "set_params" نفس التأثير مثل تعيين باراميترات باستخدام طريقة "\_\_init\_\_". أسهل طريقة وأفضل طريقة للقيام بذلك هي **عدم إجراء أي التحقق من صحة باراميترات في** "\_\_init\_\_". يجب إجراء جميع المنطق وراء باراميترات المقدّر، مثل ترجمة الوسيطات النصية إلى وظائف، في "fit".

    أيضًا، من المتوقع أن باراميترات التي تنتهي بـ "_" **يجب ألا يتم تعيينها داخل طريقة** "\_\_init\_\_". جميع السمات العامة التي تم تعيينها بواسطة fit فقط لها "_" لاحقة. نتيجة لذلك، يتم استخدام وجود باراميترات ذات "_" لاحقة للتحقق مما إذا كان المقدّر قد تم تركيبه.

    .. _cloning:

    الاستنساخ
    -------
    للاستخدام مع وحدة :mod:`~sklearn.model_selection`، يجب أن يدعم المقدّر وظيفة "base.clone" لتكرار المقدّر. يمكن القيام بذلك عن طريق توفير طريقة "get_params". إذا كانت "get_params" موجودة، فإن "clone(estimator)" ستكون مثيلًا لـ "type(estimator)" التي تم استدعاء "set_params" عليها باستخدام نسخ من نتيجة "estimator.get_params()".

    سيتم نسخ الكائنات التي لا توفر هذه الطريقة بعمق (باستخدام الوظيفة القياسية لبايثون "copy.deepcopy") إذا تم تمرير "safe=False" إلى "clone".

    يمكن للمقدّرين تخصيص سلوك :func:`base.clone` عن طريق تحديد طريقة `__sklearn_clone__`. يجب أن تعيد `__sklearn_clone__` مثيلًا للمقدّر. تكون `__sklearn_clone__` مفيدة عندما يحتاج المقدّر إلى التمسك ببعض الحالات عند استدعاء :func:`base.clone` على المقدّر. على سبيل المثال، يمكن تعريف متحول التجميد للمتحولات على النحو التالي::

        class FrozenTransformer(BaseEstimator):
            def __init__(self, fitted_transformer):
                self.fitted_transformer = fitted_transformer

            def __getattr__(self, name):
                # يمكن الآن الوصول إلى سمات `fitted_transformer`
                return getattr(self.fitted_transformer, name)

            def __sklearn_clone__(self):
                return self

            def fit(self, X, y):
                # لا يغير التركيب حالة المقدّر
                return self

            def fit_transform(self, X, y=None):
                # fit_transform يحول البيانات فقط
                return self.fitted_transformer.transform(X, y)

    التوافق مع Pipeline
    -------------------
    ...

  للاستخدام مع ``pipeline.Pipeline`` في أي خطوة باستثناء الخطوة الأخيرة، يجب على المصنف توفير دالة ``fit`` أو ``fit_transform``. ولكي يكون من الممكن تقييم خط الأنابيب على أي بيانات غير مجموعة التدريب، يجب أن يوفر أيضًا دالة ``transform``.
    
    لا توجد متطلبات خاصة للخطوة الأخيرة في خط الأنابيب، باستثناء أنها تحتوي على دالة ``fit``. يجب أن تأخذ جميع دالات ``fit`` و``fit_transform`` وسيطات ``X, y``، حتى لو لم يتم استخدام y. وبالمثل، لكي تكون ``score`` قابلة للاستخدام، يجب أن تحتوي الخطوة الأخيرة من خط الأنابيب على دالة ``score`` تقبل وسيط ``y`` اختياري.
    
    أنواع المصنفات
    ---------------
    تعتمد بعض الوظائف الشائعة على نوع المصنف الذي تم تمريره. على سبيل المثال، يتم استخدام التقسيم الطبقي افتراضيًا عند استخدام تقاطع التحقق في :class:`model_selection.GridSearchCV` و:func:`model_selection.cross_val_score` في التصنيفات، ولكن ليس في الحالات الأخرى. وبالمثل، في تصنيفات متوسط الدقة التي تأخذ تنبؤات مستمرة، يجب استدعاء ``decision_function`` للمصنفات، ولكن ``predict`` للمنظّمات.
    
    يتم تنفيذ هذا التمييز بين المصنفات والمنظّمات باستخدام الخاصية ``_estimator_type`` التي تأخذ قيمة سلسلة نصية. يجب أن تكون ``"classifier"`` للمصنفات و``"regressor"`` للمنظّمات و``"clusterer"`` لأساليب التجميع، لكي تعمل كما هو متوقع.
    
    يؤدي الميراث من ``ClassifierMixin`` أو ``RegressorMixin`` أو ``ClusterMixin`` إلى تعيين الخاصية تلقائيًا. وعندما يحتاج مصنف الميتا إلى التمييز بين أنواع المصنفات، يجب استخدام المساعدين مثل :func:`base.is_classifier` بدلاً من التحقق من ``_estimator_type`` مباشرةً.
    
    النماذج المحددة
    ---------------
    
    يجب أن تقبل المصنفات وسيطات ``y`` (الهدف) على أنها تسلسلات (قوائم أو صفائف) من سلاسل نصية أو أعداد صحيحة. ولا يجب أن تفترض أن تسميات الفئة عبارة عن نطاق صحيح متجاور، وبدلاً من ذلك يجب تخزين قائمة من الفئات في خاصية أو سمة ``classes_``. يجب أن يتطابق ترتيب تسميات الفئة في هذه الخاصية مع الترتيب الذي تُرجع به ``predict_proba`` و``predict_log_proba`` و``decision_function`` قيمها.
    
    الطريقة الأسهل لتحقيق ذلك هي وضع::
    
        self.classes_, y = np.unique(y, return_inverse=True)
    
    في ``fit``. وهذا يُرجع ``y`` جديد يحتوي على مؤشرات الفئة، بدلاً من التسميات، في النطاق [0, ``n_classes``).
    
    يجب أن تُرجع دالة ``predict`` للمصنف صفائف تحتوي على تسميات الفئة من ``classes_``. ويمكن تحقيق ذلك في مصنف يطبق ``decision_function`` باستخدام::
    
        def predict(self, X):
            D = self.decision_function(X)
            return self.classes_[np.argmax(D, axis=1)]
    
    في النماذج الخطية، يتم تخزين المعاملات في صفيف يسمى ``coef_``، ويتم تخزين المصطلح المستقل في ``intercept_``. يحتوي ``sklearn.linear_model._base`` على بعض الفئات الأساسية والمخاليط التي تطبق أنماط نماذج خطية شائعة.
    
    تحتوي وحدة :mod:`~sklearn.utils.multiclass` على دالات مفيدة للعمل مع المشكلات متعددة الفئات ومتعددة التسميات.
    
    علامات المصنف
    
    
    (لم يتم العثور على ترجمة لنص علامات المصنف)
    
    .. _estimator_tags:
    
    Estimator Tags
    
    
    (نهاية النص)

  هذا نص بتنسيق RST أريد ترجمته إلى اللغة العربية، مع الحفاظ على الرموز الخاصة والرياضية والروابط والأكواد البرمجية دون ترجمة:

    --------------
    .. warning::

        تعتبر علامات المُقدر تجريبية، وواجهة برمجة التطبيقات الخاصة بها عرضة للتغيير.

    قام سكيت-ليرن (Scikit-learn) بتقديم علامات المُقدر في الإصدار 0.21. هذه عبارة عن تعليقات توضيحية للمُقدر تسمح بالتفتيش البرمجي لقدراته، مثل دعم المصفوفة المتفرقة، وأنواع الإخراج المدعومة، والطرق المدعومة. علامات المُقدر عبارة عن قاموس يتم إرجاعه بواسطة الطريقة ``_get_tags()``. يتم استخدام هذه العلامات في الشيكات الشائعة التي يتم تشغيلها بواسطة وظيفة ``check_estimator`` والديكور ``parametrize_with_checks``. تحدد العلامات الاختبارات التي يجب تشغيلها ونوع بيانات الإدخال المناسب. يمكن أن تعتمد العلامات على معلمات المُقدر أو حتى بنية النظام، ولا يمكن تحديدها بشكل عام إلا أثناء التشغيل.

    مجموعة علامات المُقدر الحالية هي:

    allow_nan (الافتراضي=False)
        ما إذا كان المُقدر يدعم البيانات التي بها قيم مفقودة مشفرة كـ np.nan

    array_api_support (الافتراضي=False)
        ما إذا كان المُقدر يدعم مدخلات متوافقة مع Array API.

    binary_only (الافتراضي=False)
        ما إذا كان المُقدر يدعم التصنيف الثنائي ولكن يفتقر إلى دعم التصنيف متعدد الفئات.

    multilabel (الافتراضي=False)
        ما إذا كان المُقدر يدعم الإخراج المتعدد التسميات

    multioutput (الافتراضي=False)
        ما إذا كان أداة التراجع تدعم إخراج متعدد الأهداف أو أن المُصنف يدعم الإخراج متعدد الفئات متعدد الإخراج.

    multioutput_only (الافتراضي=False)
        ما إذا كان المُقدر يدعم فقط تصنيف الإخراج المتعدد أو الانحدار.

    no_validation (الافتراضي=False)
        ما إذا كان المُقدر يتخطى التحقق من صحة الإدخال. هذا مخصص فقط للمحولات الجامدة والوهمية!

    non_deterministic (الافتراضي=False)
        ما إذا كان المُقدر غير حتمي نظرًا لـ ``random_state`` ثابت

    pairwise (الافتراضي=False)
        يشير هذا السمة المنطقية إلى ما إذا كانت البيانات (``X``) :term:`fit` والطرق المماثلة تتكون من مقاييس زوجية على العينات بدلاً من تمثيل ميزة لكل عينة. عادة ما يكون ``True`` حيث يحتوي المُقدر على معلمة ``metric`` أو ``affinity`` أو ``kernel`` ذات قيمة 'محسوبة مسبقًا'. الغرض الأساسي منه هو دعم :term:`meta-estimator` أو إجراء التحقق المتقاطع الذي يستخرج عينة فرعية من البيانات المخصصة لمقدر زوجي، حيث تحتاج البيانات إلى فهرستها على كلا المحورين. على وجه التحديد، يتم استخدام هذه العلامة بواسطة ``sklearn.utils.metaestimators._safe_split`` لقطع الصفوف والأعمدة.

    preserves_dtype (الافتراضي=``[np.float64]``)
        ينطبق فقط على المحولات. إنه يتوافق مع أنواع البيانات التي سيتم الحفاظ عليها بحيث يكون ``X_trans.dtype`` هو نفسه ``X.dtype`` بعد الاتصال ``transformer.transform(X)``. إذا كانت هذه القائمة فارغة، فلا يُتوقع أن يحافظ المحول على نوع البيانات. تعتبر القيمة الأولى في القائمة نوع البيانات الافتراضي، والذي يتوافق مع نوع بيانات الإخراج عندما لا يتم الحفاظ على نوع بيانات الإدخال.

    poor_score (الافتراضي=False)
        ما إذا كان المُقدر يفشل في تقديم "نتيجة معقولة" لمجموعة الاختبار، والتي حاليًا للانحدار هي R2 يبلغ 0.5 على ``make_regression(n_samples=200, n_features=10, n_informative=1, bias=5.0, noise=20, random_state=42)``، وللتصنيف دقة 0.83 على ``make_blobs(n_samples=300, random_state=0)``. تستند هذه المجموعات والقيم إلى المُقدر الحالي في سكيت-ليرن وقد يتم استبدالها بشيء أكثر منهجية.

    requires_fit (الافتراضي=True)
        ما إذا كان المُقدر يتطلب التركيب قبل استدعاء أحد ``transform`` أو ``predict`` أو ``predict_proba`` أو ``decision_function``.

    requires_positive_X (الافتراضي=False)
        ما إذا كان المُقدر يتطلب X إيجابي.

    requires_y (الافتراضي=False)
        ما إذا كان المُقدر يتطلب y لتمريره إلى ``fit`` أو ``fit_predict`` أو ``fit_transform`` الأساليب. تكون العلامة ``True`` للمُقدر الذي يرث من ``RegressorMixin`` و ``ClassifierMixin``.

    requires_positive_y (الافتراضي=False)
        ما إذا كان المُقدر يتطلب y إيجابي (ينطبق فقط على الانحدار).

    _skip_test (الافتراضي=False)
        ما إذا كان سيتم تخطي الاختبارات الشائعة تمامًا. لا تستخدم هذا إلا إذا كان لديك سبب *جيد جدًا*.

    _xfail_checks (الافتراضي=False)
        قاموس ``{check_name: reason}`` من الشيكات الشائعة التي سيتم وضع علامة عليها كـ `XFAIL` لـ pytest، عند استخدام ``parametrize_with_checks``. سيتم ببساطة تجاهل هذه الشيكات وعدم تشغيلها بواسطة ``check_estimator``، ولكن سيتم رفع ``SkipTestWarning``. لا تستخدم هذا إلا إذا كان هناك سبب *جيد جدًا* لعدم اجتياز المُقدر للاختبار. لاحظ أيضًا أن استخدام هذه العلامة قابل للتغيير بشكل كبير لأننا نحاول جعلها أكثر مرونة: كن مستعدًا للتغييرات الجذرية في المستقبل.

    stateless (الافتراضي=False)
        ما إذا كان المُقدر يحتاج إلى الوصول إلى البيانات للتركيب. على الرغم من أن المُقدر قد يكون عديم الحالة، إلا أنه قد لا يزال بحاجة إلى استدعاء ``fit`` للتبدئة.

    X_types (الافتراضي=['2darray'])
        أنواع الإدخال المدعومة لـ X كقائمة من السلاسل. يتم حاليًا تشغيل الاختبارات فقط إذا كانت '2darray' موجودة في القائمة، مما يدل على أن المُقدر يأخذ مصفوفات numpy مستمرة ثنائية الأبعاد كمدخلات. القيمة الافتراضية هي ['2darray']. الأنواع الأخرى المحتملة هي ``'string'``، ``'sparse'``، ``'categorical'``، ``dict``، ``'1dlabels'`` و ``'2dlabels'``. الهدف هو أنه في المستقبل سيحدد نوع الإدخال المدعوم البيانات المستخدمة أثناء الاختبار، خاصة بالنسبة لبيانات ``'string'`` و ``'sparse'`` و ``'categorical'``. في الوقت الحالي، لا تستخدم اختبار البيانات المتفرقة علامة ``'sparse'``.

    من غير المرجح أن تتناسب القيم الافتراضية لكل علامة مع احتياجات المُقدر المحدد الخاص بك. يمكن إنشاء علامات إضافية أو تجاوز العلامات الافتراضية عن طريق تحديد طريقة ``_more_tags()`` والتي ترجع قاموسًا بالعلامات المرغوبة المتجاوزة أو العلامات الجديدة. على سبيل المثال::

        class MyMultiOutputEstimator(BaseEstimator):

    
    ...
    <functioncall>
    ...
    إنشاء مهمة التلخيص:

    قام سكيت-ليرن بتقديم علامات المُقدر في الإصدار 0.21 لتسهيل التفتيش البرمجي لقدرات المُقدر. تتضمن العلامات الحالية دعم المصفوفة المتفرقة، وأنواع الإخراج المدعومة، والطرق المدعومة، من بين أمور أخرى. يمكن إنشاء علامات إضافية أو تجاوز العلامات الافتراضية عن طريق تحديد طريقة ``_more_tags()``.

هذا نص بتنسيق RST أريد ترجمته إلى اللغة العربية:

```python
def _more_tags(self):
    return {'multioutput_only': True,
            'non_deterministic': True}
```

أي علامة ليست موجودة في `_more_tags()` سيتم الرجوع إلى القيم الافتراضية الموثقة أعلاه.

على الرغم من أنه غير مستحسن، فمن الممكن تجاوز الدالة `_get_tags()`. ومع ذلك، يجب أن تكون **جميع العلامات موجودة في القاموس**. إذا لم تكن أي من المفاتيح الموثقة أعلاه موجودة في ناتج `_get_tags()`، فسيحدث خطأ.

بالإضافة إلى العلامات، يحتاج المقدرون أيضًا إلى إعلان أي بارامترات غير اختيارية لـ `__init__` في سمة الصف `_required_parameters`، والتي تكون قائمة أو مجموعة. إذا كان `_required_parameters` يحتوي فقط على `["estimator"]` أو `["base_estimator"]`، فسيتم إنشاء المقدّر مع مثيل من `LogisticRegression` (أو `RidgeRegression` إذا كان المقدّر نموذج انحدار) في الاختبارات. اختيار هذين النموذجين غريب بعض الشيء ولكن كلاهما يجب أن يوفر حلولًا قوية بشكل مغلق.

.. _developer_api_set_output:

واجهة برمجة التطبيقات للمطورين لـ `set_output`
```

(ملاحظة: لم تتم ترجمة الروابط والتاجات والشفرة البرمجية والرموز الخاصة والرموز والمعادلات الرياضية وفقًا للتعليمات).

هذا نص بتنسيق RST أريد ترجمته إلى اللغة العربية، مع الحفاظ على الرموز الخاصة والرموز والمعادلات الرياضية والروابط والتاجات والشفرة البرمجية دون ترجمة:

==============================

مع `SLEP018 <https://scikit-learn-enhancement-proposals.readthedocs.io/en/latest/slep018/proposal.html>`__، يقدم سكيت-ليرن واجهة برمجة التطبيقات `set_output` لتكوين المحولات لإخراج إطارات بيانات البانداس. يتم تعريف واجهة برمجة التطبيقات `set_output` تلقائيًا إذا قام المحول بتعريف :term:`get_feature_names_out` وينتمي إلى الفئة :class:`base.TransformerMixin`. يتم استخدام :term:`get_feature_names_out` للحصول على أسماء الأعمدة لإخراج البانداس.

:class:`base.OneToOneFeatureMixin` و:class:`base.ClassNamePrefixFeaturesOutMixin` هما مكسينان مفيدان لتعريف :term:`get_feature_names_out`. :class:`base.OneToOneFeatureMixin` مفيد عندما يكون للمحول تناظر واحد لواحد بين ميزات الإدخال وميزات الإخراج، مثل :class:`~preprocessing.StandardScaler`. :class:`base.ClassNamePrefixFeaturesOutMixin` مفيد عندما يحتاج المحول إلى إنشاء أسماء الميزات الخاصة به، مثل :class:`~decomposition.PCA`.

يمكنك إلغاء اشتراك واجهة برمجة التطبيقات `set_output` عن طريق تعيين `auto_wrap_output_keys=None` عند تعريف فئة فرعية مخصصة::

    class MyTransformer(TransformerMixin، BaseEstimator، auto_wrap_output_keys=None):

        def fit(self، X، y=None):
            return self
        def transform(self، X، y=None):
            return X
        def get_feature_names_out(self، input_features=None):
            ...

القيمة الافتراضية لـ `auto_wrap_output_keys` هي `("transform",)`، والتي تقوم تلقائيًا بلف `fit_transform` و `transform`. يستخدم `TransformerMixin` آلية `__init_subclass__` لاستهلاك `auto_wrap_output_keys` وتمرير جميع وسيطات الكلمة الرئيسية الأخرى إلى فئتها الفائقة. يجب **عدم** اعتماد `__init_subclass__` للفئات الفائقة على `auto_wrap_output_keys`.

بالنسبة للمحولات التي تعيد صفائف متعددة في `transform`، فإن الالتفاف التلقائي سوف يلف الصفيف الأول فقط ولا يعدل الصفائف الأخرى.

انظر :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py` للحصول على مثال حول كيفية استخدام واجهة برمجة التطبيقات.

.. _developer_api_check_is_fitted:

واجهة برمجة التطبيقات للمطور لـ `check_is_fitted`
================================================

بشكل افتراضي، تتحقق :func:`~sklearn.utils.validation.check_is_fitted` إذا كان هناك أي سمات في المثال لها علامة سفلية زائدة، مثل `coef_`. يمكن للمقدر تغيير السلوك عن طريق تنفيذ طريقة `__sklearn_is_fitted__` التي لا تأخذ أي مدخلات وتعيد قيمة منطقية. إذا كانت هذه الطريقة موجودة، فإن :func:`~sklearn.utils.validation.check_is_fitted` تعيد ببساطة إخراجها.

انظر :ref:`sphx_glr_auto_examples_developing_estimators_sklearn_is_fitted.py` للحصول على مثال حول كيفية استخدام واجهة برمجة التطبيقات.

واجهة برمجة التطبيقات للمطور لتمثيل HTML
=======================================

.. warning::

    واجهة برمجة التطبيقات لتمثيل HTML تجريبية وخاضعة للتغيير.

تعرض المقاييس التي ترث من :class:`~sklearn.base.BaseEstimator` تمثيل HTML لأنفسهم في بيئات البرمجة التفاعلية مثل دفاتر جوبتر. على سبيل المثال، يمكننا عرض مخطط HTML هذا::

    from sklearn.base import BaseEstimator

    BaseEstimator()

يتم الحصول على تمثيل HTML الخام عن طريق استدعاء الدالة :func:`~sklearn.utils.estimator_html_repr` على مثال للمقدر.

لتخصيص عنوان URL الذي يربط توثيق المقّدر (أي عند النقر على أيقونة "?")، تجاوز سمة `_doc_link_module` و `_doc_link_template`. بالإضافة إلى ذلك، يمكنك توفير طريقة `_doc_link_url_param_generator`. قم بتعيين `_doc_link_module` إلى اسم الوحدة النمطية (من المستوى الأعلى) التي تحتوي على مقدّر الخاص بك. إذا لم تطابق القيمة اسم الوحدة النمطية من المستوى الأعلى، فلن يحتوي تمثيل HTML على رابط إلى التوثيق. بالنسبة لمقدرات سكيت-ليرن، يتم تعيين هذا إلى `"sklearn"`.

يتم استخدام `_doc_link_template` لإنشاء عنوان URL النهائي. بشكل افتراضي، يمكن أن يحتوي على متغيرين: `estimator_module` (الاسم الكامل للوحدة النمطية التي تحتوي على المقدّر) و `estimator_name` (اسم فئة المقدّر). إذا كنت بحاجة إلى المزيد من المتغيرات، فيجب عليك تنفيذ طريقة `_doc_link_url_param_generator` التي يجب أن تعيد قاموسًا للمتغيرات وقيمها. سيتم استخدام هذا القاموس لتقديم `_doc_link_template`.

.. _coding-guidelines:

إرشادات الترميز

    

فيما يلي بعض الإرشادات حول كيفية كتابة التعليمات البرمجية الجديدة للإدراج في Scikit-learn ، والتي قد يكون من المناسب اعتمادها في المشاريع الخارجية. بالطبع ، هناك حالات خاصة وسوف تكون هناك استثناءات لهذه القواعد. ومع ذلك ، فإن اتباع هذه القواعد عند إرسال رمز جديد يجعل المراجعة أسهل بحيث يمكن دمج الرمز الجديد في وقت أقل.

يجعل الرمز المنظم بشكل موحد من السهل مشاركة ملكية التعليمات البرمجية. يحاول مشروع Scikit-learn اتباع الإرشادات الرسمية لـ Python بالتفصيل في PEP8 الذي يوضح بالتفصيل كيفية تنسيق التعليمات البرمجية والمسافات البادئة. يرجى قراءتها واتباعها.

بالإضافة إلى ذلك ، نضيف الإرشادات التالية:

* استخدم underscores لفصل الكلمات في الأسماء غير التابعة للفئة: ``n_samples`` بدلاً من ``nsamples``.
* تجنب وجود عدة عبارات في سطر واحد. يفضل العودة إلى السطر بعد عبارة التحكم (``if`` / ``for``).
* استخدم عمليات الاستيراد النسبية للإشارات داخل Scikit-learn.
* اختبارات الوحدة هي استثناء من القاعدة السابقة ؛ يجب أن تستخدم عمليات استيراد مطلقة ، تمامًا كما يفعل رمز العميل. نتيجة لذلك ، إذا قام ``sklearn.foo`` بتصدير فئة أو دالة يتم تنفيذها في ``sklearn.foo.bar.baz`` ، فيجب على الاختبار استيرادها من ``sklearn.foo``.
* **من فضلك لا تستخدم** ``import *`` **في أي حالة**. يعتبر ضارًا من قبل `التوصيات الرسمية لـ Python <https://docs.python.org/3.1/howto/doanddont.html#at-module-level>` _. يجعل الرمز أكثر صعوبة في القراءة حيث لم تعد أصل الرموز مشار إليها بشكل صريح ، ولكن الأهم من ذلك ، أنه يمنع استخدام أداة التحليل الثابتة مثل `pyflakes <https://divmod.readthedocs.io/en/latest/products/pyflakes.html>`_ للعثور تلقائيًا على الأخطاء في Scikit-learn.
* استخدم `معيار docstring الخاص بـ numpy <https://numpydoc.readthedocs.io/en/latest/format.html#docstring-standard>`_ في جميع مستنداتك.

يمكن العثور على مثال جيد للشفرة التي نفضلها `هنا <https://gist.github.com/nateGeorge/5455d2c57fb33c1ae04706f2dc4fee01>`_.

التحقق من صحة الإدخال
--------------------

.. currentmodule :: sklearn.utils

يحتوي الوحدة النمطية: mod: `sklearn.utils` على وظائف مختلفة لإجراء التحقق من صحة الإدخال وتحويله. في بعض الأحيان ، يكون ``np.asarray`` كافيًا للتحقق من الصحة ؛ لا تستخدم ``np.asanyarray`` أو ``np.atleast_2d`` ، نظرًا لأن تلك ترك مصفوفة ``np.matrix`` من NumPy ، والتي تحتوي على واجهة برمجة تطبيقات مختلفة (على سبيل المثال ، ``*`` تعني حاصل الضرب النقطي على ``np.matrix`` ، ولكن منتج Hadamard على ``np.ndarray`` ).

في حالات أخرى ، تأكد من استدعاء: func: `check_array` على أي وسيطة تشبه الصفيف تم تمريرها إلى وظيفة واجهة برمجة تطبيقات Scikit-learn. تعتمد المعلمات الدقيقة التي يجب استخدامها بشكل أساسي على ما إذا كانت مصفوفات ``scipy.sparse`` يجب قبولها وأيها.

لمزيد من المعلومات ، راجع صفحة: ref: `developers-utils`.

الأرقام العشوائية
--------------

إذا كان الكود الخاص بك يعتمد على مولد الأرقام العشوائية ، فلا تستخدم ``numpy.random.random ()`` أو روتينيات مماثلة. لضمان إمكانية التكرار في فحص الأخطاء ، يجب أن تقبل الروتينية كلمة رئيسية ``random_state`` وتستخدمها لإنشاء كائن ``numpy.random.RandomState``. انظر: func: `sklearn.utils.check_random_state` في: ref: `developers-utils`.

فيما يلي مثال بسيط على استخدام بعض الإرشادات المذكورة أعلاه::

    from sklearn.utils import check_array, check_random_state

    def choose_random_sample(X, random_state=0):
        """اختر نقطة عشوائية من X.

        المعلمات
        ----------
        X : array-like من الشكل (n_samples، n_features)
            صفيف يمثل البيانات.
        random_state : int أو مثيل RandomState ، الافتراضي = 0
            بذرة مولد الأرقام العشوائية الزائفة الذي يختار عينة عشوائية. مرر رقمًا صحيحًا لإخراج قابل للتكاثر عبر عدة استدعاءات للوظيفة.
            انظر: term: `Glossary <random_state>`.

        يعود
        -------
        x : ndarray من الشكل (n_features ،)
            نقطة عشوائية مختارة من X.
        """
        X = check_array(X)
        random_state = check_random_state(random_state)
        i = random_state.randint(X.shape[0])
        return X[i]

إذا كنت تستخدم العشوائية في مقدر بدلاً من وظيفة قائمة بذاتها ، يتم تطبيق بعض الإرشادات الإضافية.

أولاً ، يجب أن يأخذ المقدر وسيطة ``random_state`` لـ ``__init__`` الخاصة به بقيمة افتراضية ``None``. يجب أن يخزن قيمة وسيطة هذا دون تغيير في سمة ``random_state``. يمكن لـ ``fit`` استدعاء ``check_random_state`` على تلك السمة للحصول على مولد أرقام عشوائية فعلي. إذا ، لسبب ما ، كانت هناك حاجة إلى العشوائية بعد ``fit`` ، فيجب تخزين RNG في السمة ``random_state_``. يجب أن يوضح المثال التالي هذا::

    class GaussianNoise (BaseEstimator ، TransformerMixin):
        """يتجاهل هذا المقدر مدخلاته ويعيد ضوضاء غاوسية عشوائية.

        كما أنها لا تلتزم بجميع اتفاقيات Scikit-learn ،
        ولكنها تعرض كيفية التعامل مع العشوائية.
        """

        def __init__(self، n_components = 100، random_state = None):
            self.random_state = random_state
            self.n_components = n_components

        # يتم تجاهل الحجج على أي حال ، لذلك نجعلها اختيارية
        def fit(self، X = None، y = None):
            self.random_state_ = check_random_state(self.random_state)

        def transform(self ، X):
            n_samples = X.shape[0]
            return self.random_state_.randn(n_samples ، self.n_components)

وذلك لأن قابلية التكرار: عندما يتم ``fit`` مرّتين لمقدر ما إلى نفس البيانات ، يجب أن ينتج عنه نموذج متطابق في كلتا الحالتين ، وبالتالي التحقق من الصحة في ``fit`` ، وليس ``__init__``.

التأكيدات العددية في الاختبارات

    









































































































































































































































































































































































































عند التأكيد على شبه المساواة بين صفائف القيم المستمرة، يُرجى استخدام `sklearn.utils._testing.assert_allclose`.

يتم استنتاج التحمل النسبي تلقائيًا من أنواع البيانات (dtypes) للصفائف المقدمة (خاصة بالنسبة لـ float32 و float64) ولكن يمكنك تجاوزه عبر ``rtol``.

عند مقارنة صفائف العناصر الصفرية، يُرجى توفير قيمة غير صفرية للتحمل المطلق عبر ``atol``.

لمزيد من المعلومات، يرجى الرجوع إلى سلسلة الوثائق الخاصة بـ `sklearn.utils._testing.assert_allclose`.
