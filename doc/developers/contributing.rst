  هذا نص بتنسيق RST أريد ترجمته إلى اللغة العربية:

    .. _contributing:

    ============
    المساهمة
    ============

    .. currentmodule:: sklearn

    هذا المشروع هو جهد جماعي، والجميع مرحب به للمساهمة. يستضاف على https://github.com/scikit-learn/scikit-learn. يتم توضيح عملية صنع القرار وهيكل الحوكمة لـ scikit-learn في :ref:`governance`.

    تتميز Scikit-learn بأنها :ref:`انتقائية <selectiveness>` إلى حد ما عندما يتعلق الأمر بإضافة خوارزميات جديدة، وأفضل طريقة للمساهمة والمساعدة في المشروع هي البدء في العمل على المشكلات المعروفة. راجع :ref:`new_contributors` للبدء.

    .. topic:: **مجتمعنا، قيمنا**

        نحن مجتمع قائم على الانفتاح والمناقشات الودية والتعليمية.

        نحن نطمح إلى معاملة الجميع على قدم المساواة، ونقدّر مساهماتهم. نحن نسعى بشكل خاص إلى جذب الأشخاص من الخلفيات غير الممثلة في البرمجيات مفتوحة المصدر، و scikit-learn على وجه الخصوص، للمشاركة والمساهمة بخبرتهم وتجربتهم.

        تتخذ القرارات بناءً على الجدارة التقنية والتوافق.

        الكود ليس الطريقة الوحيدة للمساعدة في المشروع. إن مراجعة طلبات السحب، والإجابة على الأسئلة لمساعدة الآخرين في القوائم البريدية أو المشكلات، وتنظيم وتعليم الدروس، والعمل على الموقع الإلكتروني، وتحسين الوثائق، كلها مساهمات لا تقدر بثمن.

        نحن نلتزم بمبادئ الانفتاح والاحترام والاهتمام بالآخرين التابعة لمؤسسة البرامجPython:
        https://www.python.org/psf/codeofconduct/


    في حال واجهتك مشاكل أثناء استخدام هذه الحزمة، لا تتردد في تقديم تذكرة إلى
    `متعقب المشكلات على GitHub
    <https://github.com/scikit-learn/scikit-learn/issues>`_. كما أنك مرحب بك لنشر طلبات الميزات أو طلبات السحب.

    طرق المساهمة
    ==================

    هناك العديد من الطرق للمساهمة في scikit-learn، وأكثرها شيوعًا هي المساهمة بالكود أو الوثائق في المشروع. تحسين الوثائق ليس أقل أهمية من تحسين المكتبة نفسها. إذا وجدت خطأ إملائيًا في الوثائق، أو أجريت تحسينات، فلا تتردد في إرسال بريد إلكتروني إلى القائمة البريدية أو من الأفضل إرسال طلب سحب على GitHub. يمكن العثور على الوثائق الكاملة تحت دليل doc/.

    ولكن هناك العديد من الطرق الأخرى للمساعدة. على وجه الخصوص، :ref:`تحسين، فرز، والتحقيق في المشكلات <bug_triaging>` و
    :ref:`مراجعة طلبات سحب المطورين الآخرين <code_review>` هي مساهمات قيمة للغاية تقلل العبء على مسؤولي المشروع.

    طريقة أخرى للمساهمة هي الإبلاغ عن المشكلات التي تواجهها، وإعطاء "إعجاب" للمشكلات التي أبلغ عنها الآخرون والتي تهمك. كما أنه يساعدنا إذا نشرت الكلمة: ارجع إلى المشروع من مدونتك والمقالات، اربطه من موقع الويب الخاص بك، أو ببساطة انقر على النجمة لتقول "أستخدمه":

    .. raw:: html

      <p>
        <object
          data="https://img.shields.io/github/stars/scikit-learn/scikit-learn?style=for-the-badge&logo=github"
          type="image/svg+xml">
        </object>
      </p>

    في حالة تضمنت المساهمة/المشكلة تغييرات في مبادئ واجهة برمجة التطبيقات أو تغييرات في الإعتمادات أو الإصدارات المدعومة، يجب دعمها بواسطة
    :ref:`slep`، حيث يجب إرسال SLEP كطلب سحب إلى
    `مقترحات التحسين <https://scikit-learn-enhancement-proposals.readthedocs.io>`_
    باستخدام `قالب SLEP <https://scikit-learn-enhancement-proposals.readthedocs.io/en/latest/slep_template.html>`_
    ويتبع عملية صنع القرار الموضحة في :ref:`governance`.

    .. dropdown:: المساهمة في المشاريع ذات الصلة

      تزدهر Scikit-learn في نظام بيئي من عدة مشاريع ذات صلة، والتي قد يكون لها أيضًا مشكلات ذات صلة للعمل عليها، بما في ذلك المشاريع الصغيرة مثل:

      * `scikit-learn-contrib <https://github.com/search?q=org%3Ascikit-learn-contrib+is%3Aissue+is%3Aopen+sort%3Aupdated-desc&type=Issues>`__
      * `joblib <https://github.com/joblib/joblib/issues>`__
      * `sphinx-gallery <https://github.com/sphinx-gallery/sphinx-gallery/issues>`__
      * `numpydoc <https://github.com/numpy/numpydoc/issues>`__
      * `liac-arff <https://github.com/renatopp/liac-arff/issues>`__

      والمشاريع الكبيرة:

      * `numpy <https://github.com/numpy/numpy/issues>`__
      * `scipy <https://github.com/scipy/scipy/issues>`__
      * `matplotlib <https://github.com/matplotlib/matplotlib/issues>`__
      * وغيرها.

      ابحث عن المشكلات التي تحمل علامة "مساعدة مطلوبة" أو ما شابه ذلك. قد يساعد مساعدة هذه المشاريع scikit-learn أيضًا. انظر أيضًا :ref:`related_projects`.

    سياسة المساهمات الآلية
    ==============================

    يرجى الامتناع عن إرسال المشكلات أو طلبات السحب التي تم إنشاؤها بواسطة أدوات مؤتمتة بالكامل. يحتفظ المشرفون بالحق، وفقًا لتقديرهم الخاص، في إغلاق هذه الطلبات وحظر أي حساب مسؤول عنها.

    من الناحية المثالية، يجب أن تأتي المساهمات بعد مناقشة من شخص لآخر في شكل مشكلة.

    إرسال تقرير علة أو طلب ميزة

(ملاحظة: الروابط والتاجات والمعادلات الرياضية والشفرة البرمجية والرموز الخاصة لم تتم ترجمتها بناءً على طلبك)

نستخدم قضايا GitHub لتتبع جميع الأخطاء وطلبات الميزات؛ لا تتردد في فتح قضية إذا كنت قد وجدت خطأ أو ترغب في رؤية ميزة يتم تنفيذها.

في حال واجهتك مشاكل في استخدام هذه الحزمة، لا تتردد في إرسال تذكرة إلى  `متعقب الأخطاء <https://github.com/scikit-learn/scikit-learn/issues>`_. أنت أيضًا مرحب بك لنشر طلبات الميزات أو طلبات السحب.

من المستحسن التحقق من أن قضيتك تتوافق مع القواعد التالية قبل تقديمها:

- تحقق من أن قضيتك لا تتم معالجتها حاليًا من قبل قضايا أخرى  `<https://github.com/scikit-learn/scikit-learn/issues?q=>`_  أو طلبات السحب  `<https://github.com/scikit-learn/scikit-learn/pulls?q=>`_.

- إذا كنت تقدم طلبًا لخوارزمية أو ميزة، يرجى التحقق من أن الخوارزمية تلبي متطلبات الخوارزمية الجديدة  `<https://scikit-learn.org/stable/faq.html#what-are-the-inclusion-criteria-for-new-algorithms>`_.

- إذا كنت تقدم تقريرًا عن خطأ، فإننا نشجعك بشدة على اتباع الإرشادات في  :ref:`filing_bugs`.

.. _filing_bugs:

كيفية تقديم تقرير خطأ جيد
-----------------------------

عند إرسال مشكلة إلى  `GitHub <https://github.com/scikit-learn/scikit-learn/issues>`__، يرجى بذل قصارى جهدك لاتباع هذه الإرشادات! هذا سيجعل من الأسهل بكثير توفير بازدود جيد لك:

- يحتوي تقرير الخطأ المثالي على  :ref:`قصاصة رمز قابلة للتكرار قصيرة <minimal_reproducer>`، بهذه الطريقة يمكن لأي شخص محاولة إعادة إنتاج الخطأ بسهولة. إذا كان المقطع الخاص بك أطول من حوالي 50 سطرًا، فالرجاء الربط بـ  `Gist <https://gist.github.com>`_  أو مستودع GitHub.

- إذا لم يكن من الممكن تضمين مقتطف قابل للتكرار، فيرجى أن تكون محددًا بشأن  **التقديرات و/أو الوظائف المعنية وشكل البيانات**.

- إذا تم طرح استثناء، فيرجى  **توفير التتبع الكامل**.

- يرجى تضمين  **نوع نظام التشغيل ورقم الإصدار**، وكذلك  **إصدارات Python و scikit-learn و numpy و scipy**. يمكن العثور على هذه المعلومات عن طريق تشغيل:

  .. prompt:: bash

    python -c "import sklearn; sklearn.show_versions()"

- يرجى التأكد من تنسيق جميع  **قصاصات التعليمات البرمجية ورسائل الخطأ في كتل التعليمات البرمجية المناسبة**.  انظر  `إنشاء وإبراز كتل التعليمات البرمجية <https://help.github.com/articles/creating-and-highlighting-code-blocks>`_  لمزيد من التفاصيل.

إذا كنت ترغب في المساعدة في تنسيق المشكلات، فاقرأ عن  :ref:`bug_triaging`.

المساهمة في الشفرة

    

ملاحظة:

  لتجنب تكرار العمل، ينصح بشدة البحث في تعقب المشاكل <https://github.com/scikit-learn/scikit-learn/issues> وقائمة الطلبات المرسلة <https://github.com/scikit-learn/scikit-learn/pulls>. إذا كنت في شك حول العمل المكرر، أو إذا كنت ترغب في العمل على ميزة غير تافهة، فمن المستحسن أن تفتح أولاً مشكلة في تعقب المشاكل <https://github.com/scikit-learn/scikit-learn/issues> للحصول على بعض التعليقات من المطورين الأساسيين.

  طريقة سهلة للعثور على مشكلة للعمل عليها هي بتطبيق علامة "مطلوب مساعدة" في بحثك. هذا يسرد جميع المشاكل التي لم يتم المطالبة بها حتى الآن. للمطالبة بمشكلة لنفسك، يرجى التعليق بالضبط ``/take`` عليها لتعيينها تلقائياً لك من قبل سي آي.

لحفاظ على جودة الشفرة البرمجية وتسهيل عملية المراجعة، يجب أن يتوافق أي مساهمة مع إرشادات الترميز الخاصة بالمشروع <https://scikit-learn.org/dev/developers/index.html#coding-guidelines>، على وجه الخصوص:

- لا تقم بتعديل الأسطر غير ذات الصلة للحفاظ على التركيز على النطاق المذكور في وصفه أو مشكلته.
- اكتب فقط التعليقات المضمنة التي تضيف قيمة وتجنب ذكر ما هو واضح: اشرح "لماذا" بدلاً من "ماذا".
- **الأهم من ذلك**: لا تساهم برمز لا تفهمه.

موارد الفيديو
---------------
هذه مقاطع فيديو عبارة عن مقدمات خطوة بخطوة حول كيفية المساهمة في scikit-learn، وهي رفيق رائع للمبادئ التوجيهية للنص التالي. يرجى التأكد من التحقق من إرشاداتنا أدناه، لأنها تصف سير العمل الأحدث لدينا.

- دورة مكثفة في المساهمة في سكيكيت-تعلم ومشاريع مفتوحة المصدر:
  `فيديو <https://youtu.be/5OL8XoMMOfA>`__،
  `نسخة
  <https://github.com/data-umbrella/event-transcripts/blob/main/2020/05-andreas-mueller-contributing.md>`__

- مثال على إرسال طلب سحب إلى سكيكيت-تعلم:
  `فيديو <https://youtu.be/PU1WyDPGePI>`__،
  `نسخة
  <https://github.com/data-umbrella/event-transcripts/blob/main/2020/06-reshama-shaikh-sklearn-pr.md>`__

- تعليمات محددة للسباق ونصائح عملية:
  `فيديو <https://youtu.be/p_2Uw2BxdhA>`__،
  `نسخة
  <https://github.com/data-umbrella/data-umbrella-scikit-learn-sprint/blob/master/3_transcript_ACM_video_vol2.md>`__

- 3 مكونات لمراجعة طلب السحب:
  `فيديو <https://youtu.be/dyxS9KKCNzA>`__،
  `نسخة
  <https://github.com/data-umbrella/event-transcripts/blob/main/2021/27-thomas-pr.md>`__

ملاحظة:
  في يناير 2021، تم تغيير اسم الفرع الافتراضي من ``master`` إلى ``main`` لمستودع جيثب سكيكيت-تعلم لاستخدام شروط أكثر شمولاً. تم إنشاء مقاطع الفيديو هذه قبل إعادة تسمية الفرع. بالنسبة للمساهمين الذين يشاهدون مقاطع الفيديو هذه لإعداد بيئة العمل الخاصة بهم وإرسال طلب سحب، يجب استبدال ``master`` بـ ``main``.

كيفية المساهمة

(نهاية الترجمة)

الطريقة المفضلة للمساهمة في scikit-learn هي تفرع المستودع الرئيسي على GitHub، ثم إرسال "طلب سحب" (PR).

في الخطوات القليلة الأولى، سنشرح كيفية تثبيت scikit-learn محليًا، وكيفية إعداد مستودع git الخاص بك:

1. أنشئ حسابًا على GitHub إذا لم يكن لديك حساب بالفعل.

2. تفرع مستودع المشروع: انقر على زر "Fork" بالقرب من أعلى الصفحة. هذا ينشئ نسخة من الكود تحت حسابك على حساب مستخدم GitHub. لمزيد من التفاصيل حول كيفية تفرع المستودع، راجع هذا الدليل.

3. استنسخ تفرعك من مستودع scikit-learn من حساب GitHub الخاص بك إلى القرص المحلي الخاص بك:

   ```bash
   git clone git@github.com:YourLogin/scikit-learn.git  # add --depth 1 if your connection is slow
   cd scikit-learn
   ```

4. اتبع الخطوات 2-6 في تثبيت scikit-learn في وضع التطوير والعودة إلى هذه الوثيقة.

5. تثبيت تبعيات التطوير:

   ```bash
   pip install pytest pytest-cov ruff mypy numpydoc black==24.3.0
   ```

.. _upstream:

6. أضف remote "upstream". هذا يحفظ مرجعًا لمستودع scikit-learn الرئيسي، والذي يمكنك استخدامه لإبقاء المستودع الخاص بك متزامنًا مع أحدث التغييرات:

   ```bash
   git remote add upstream git@github.com:scikit-learn/scikit-learn.git
   ```

7. تحقق من أن remote 'upstream' و 'origin' تم تكوينهما بشكل صحيح عن طريق تشغيل `git remote -v` الذي يجب أن يعرض:

   ```text
   origin	git@github.com:YourLogin/scikit-learn.git (fetch)
   origin	git@github.com:YourLogin/scikit-learn.git (push)
   upstream	git@github.com:scikit-learn/scikit-learn.git (fetch)
   upstream	git@github.com:scikit-learn/scikit-learn.git (push)
   ```

يجب أن يكون لديك الآن تثبيت عامل لـ scikit-learn، ومستودع git الخاص بك مكون بشكل صحيح. قد يكون من المفيد تشغيل بعض الاختبارات للتحقق من تثبيتك. يرجى الرجوع إلى pytest_tips للحصول على أمثلة.

الخطوات التالية تصف الآن عملية تعديل الكود وتقديم PR:

8. مزامنة فرع "main" الخاص بك مع فرع "upstream/main"، المزيد من التفاصيل على GitHub Docs:

   ```bash
   git checkout main
   git fetch upstream
   git merge upstream/main
   ```

9. إنشاء فرع ميزة لعقد تغييرات التطوير الخاصة بك:

   ```bash
   git checkout -b my_feature
   ```

   والبدء في إجراء التغييرات. استخدم دائمًا فرع ميزة. من الجيد ألا تعمل أبدًا على فرع "main"!

10. (**اختياري**) تثبيت pre-commit لتشغيل عمليات فحص نمط الكود قبل كل commit:

    ```bash
    pip install pre-commit
    pre-commit install
    ```

    يمكن تعطيل عمليات فحص pre-commit لـ commit معين باستخدام `git commit -n`.

11. تطوير الميزة على فرع الميزة الخاص بك على جهاز الكمبيوتر الخاص بك، باستخدام Git لإجراء التحكم في الإصدار. عند الانتهاء من التحرير، أضف الملفات المتغيرة باستخدام `git add` ثم `git commit`:

    ```bash
    git add modified_files
    git commit
    ```

    لتسجيل التغييرات الخاصة بك في Git، ثم دفع التغييرات إلى حساب GitHub الخاص بك باستخدام:

    ```bash
    git push -u origin my_feature
    ```

12. اتبع هذه التعليمات لإنشاء طلب سحب من تفرعك. هذا سيرسل بريدًا إلكترونيًا إلى committers. قد ترغب في التفكير في إرسال بريد إلكتروني إلى القائمة البريدية لمزيد من الوضوح.

غالبًا ما يكون من المفيد إبقاء فرع الميزة المحلي الخاص بك متزامنًا مع أحدث تغييرات مستودع scikit-learn الرئيسي:

```bash
git fetch upstream
git merge upstream/main
```

بعد ذلك، قد تحتاج إلى حل النزاعات. يمكنك الرجوع إلى وثائق Git المتعلقة بحل تعارض الدمج باستخدام سطر الأوامر.

.. topic:: تعلم Git

    وثائق Git و http://try.github.io هي موارد ممتازة للبدء مع git، وفهم جميع الأوامر المعروضة هنا.

.. _pr_checklist:

قائمة مراجعة طلب السحب

(لا يوجد محتوى لترجمته في هذا القسم)

قبل دمج طلب السحب (PR)، يجب الموافقة عليه من قبل اثنين من المطورين الأساسيين. يجب تمييز المساهمة غير المكتملة - حيث تتوقع القيام بالمزيد من العمل قبل تلقي مراجعة كاملة - كـ "مسودة طلب سحب" وتغييرها إلى "جاهزة للمراجعة" عند نضجها. قد تكون مسودات طلبات السحب مفيدة لـ: الإشارة إلى أنك تعمل على شيء ما لتجنب العمل المكرر، أو طلب مراجعة واسعة للوظائف أو واجهة برمجة التطبيقات (API)، أو البحث عن متعاونين. غالبًا ما تستفيد مسودات طلبات السحب من تضمين "قائمة المهام" في وصف طلب السحب.

لتسهيل عملية المراجعة، نوصي بأن يلتزم مساهمتك بالقواعد التالية قبل وضع علامة على طلب السحب كـ "جاهز للمراجعة". تلك القواعد **الموضحة بالخط العريض** هي مهمة بشكل خاص:

1. **اعطي طلب السحب الخاص بك عنوانًا مفيدًا** يلخص ما تفعله مساهمتك. سيصبح هذا العنوان غالبًا رسالة الالتزام بمجرد الدمج ، لذلك يجب أن يلخص مساهمتك للأجيال القادمة. في بعض الحالات ، يكون "إصلاح <عنوان المشكلة>" كافيًا. "إصلاح # <رقم المشكلة>" ليس عنوان جيد أبدًا.

2. **تأكد من أن الكود الخاص بك يجتاز الاختبارات**. يمكن تشغيل مجموعة الاختبارات بأكملها باستخدام `pytest` ، ولكنها عادةً لا تكون موصى بها لأنها تستغرق وقتًا طويلاً. غالبًا ما يكون تشغيل الاختبار المرتبط بالتغييرات التي أجريتها كافيًا: على سبيل المثال ، إذا قمت بتغيير شيء ما في `sklearn / linear_model / _logistic.py` ، فإن تشغيل الأوامر التالية سيكون عادةً كافيًا:

   - `pytest sklearn / linear_model / _logistic.py` للتأكد من صحة أمثلة اختبار doctest
   - `pytest sklearn / linear_model / tests / test_logistic.py` لتشغيل الاختبارات المحددة للملف
   - `pytest sklearn / linear_model` لاختبار وحدة `~sklearn.linear_model` بأكملها
   - `pytest doc / modules / linear_model.rst` للتأكد من صحة أمثلة دليل المستخدم.
   - `pytest sklearn / tests / test_common.py -k LogisticRegression` لتشغيل جميع اختبارات المُقدر الخاصة بنا (على وجه التحديد لـ `LogisticRegression` ، إذا كان هذا هو المُقدر الذي قمت بتغييره).

   قد تكون هناك اختبارات فاشلة أخرى ، ولكن سيتم التقاطها بواسطة CI لذلك لا تحتاج إلى تشغيل مجموعة الاختبارات بالكامل محليًا. للحصول على إرشادات حول كيفية استخدام ``pytest`` بكفاءة ، راجع :ref:`pytest_tips`.

3. **تأكد من أن الكود الخاص بك معلق وموثق بشكل صحيح**، وتأكد من **عرض التوثيق بشكل صحيح**. يرجى الرجوع إلى إرشاداتنا :ref:`contribute_documentation` لبناء التوثيق. ستقوم CI أيضًا ببناء التوثيق: يرجى الرجوع إلى :ref:`generated_doc_CI`.

4. **الاختبارات ضرورية لقبول التحسينات**. يجب توفير الإصلاحات أو الميزات الجديدة مع `اختبارات عدم الارتداد <https://en.wikipedia.org/wiki/Non-regression_testing>`_. تتحقق اختبارات عدم الارتداد هذه من السلوك الصحيح للإصلاح أو الميزة. بهذه الطريقة ، يتم منح التعديلات اللاحقة على قاعدة التعليمات البرمجية لتكون متسقة مع السلوك المطلوب. في حالة إصلاحات الأخطاء ، في وقت طلب السحب ، يجب أن تفشل اختبارات عدم الارتداد لقاعدة التعليمات البرمجية في فرع ``main`` وتمرير اختبارات طلب السحب.

5. اتبع الـ :ref:`coding-guidelines`.

6. عند الاقتضاء ، استخدم أدوات التحقق والنصوص البرمجية في وحدة :mod:`sklearn.utils`. يمكن العثور على قائمة بأدوات الخدمة المساعدة المتاحة للمطورين في صفحة :ref:`developers-utils`.

7. غالبًا ما تحل طلبات السحب مشكلة واحدة أو أكثر (أو طلبات سحب). إذا كان دمج طلب السحب الخاص بك يعني أنه يجب إغلاق بعض المشكلات / طلبات السحب الأخرى ، فيجب عليك `استخدام الكلمات الرئيسية لإنشاء ارتباط إليها <https://github.com/blog/1506-closing-issues-via-pull-requests/>`_ (على سبيل المثال ، ``Fixes # 1234`` ؛ يُسمح بالعديد من المشكلات / طلبات السحب طالما أن كل واحد يسبقه كلمة رئيسية). عند الدمج ، سيتم إغلاق تلك المشكلات / طلبات السحب تلقائيًا بواسطة GitHub. إذا كان طلب السحب الخاص بك مرتبطًا ببساطة ببعض المشكلات / طلبات السحب الأخرى ، أو أنه يحل المشكلة المستهدفة جزئيًا فقط ، فقم بإنشاء ارتباط إليها دون استخدام الكلمات الرئيسية (على سبيل المثال ، ``Towards # 1234``).

8. يجب أن تتضمن طلبات السحب غالبًا التغيير ، من خلال مقاييس الأداء والكفاءة (انظر :ref:`monitoring_performances`) أو من خلال أمثلة الاستخدام. توضح الأمثلة أيضًا ميزات وتعقيدات المكتبة للمستخدمين. ألق نظرة على أمثلة أخرى في الدليل `examples / <https://github.com/scikit-learn/scikit-learn/tree/main/examples>`_ كمرجع. يجب أن توضح الأمثلة سبب فائدة الوظيفة الجديدة في الممارسة العملية ، وإذا أمكن ، قارنها بالطرق الأخرى المتاحة في scikit-learn.

9. تشتمل الميزات الجديدة على بعض النفقات العامة للصيانة. نتوقع من مؤلفي طلبات السحب المشاركة في الصيانة للكود الذي يقدمونه ، على الأقل في البداية. تحتاج الميزات الجديدة إلى توضيح بتوثيق السرد في دليل المستخدم ، مع مقتطفات التعليمات البرمجية الصغيرة. إذا كان ذلك مناسبًا ، يرجى أيضًا إضافة مراجع في الأدبيات ، مع روابط PDF عند الإمكان.

10. يجب أن يتضمن دليل المستخدم أيضًا الوقت المتوقع وتعقيد المساحة للخوارزمية وقابلية التوسع ، على سبيل المثال "يمكن أن تتوسع هذه الخوارزمية إلى عدد كبير من العينات> 100000 ، ولكنها لا تتوسع في الأبعاد: من المتوقع أن يكون `n_features` أقل من 100".

يمكنك أيضًا مراجعة الـ :ref:`code_review` لمعرفة ما يتوقعه المراجعون.

يمكنك التحقق من أخطاء البرمجة الشائعة باستخدام الأدوات التالية:

* الكود بتغطية اختبار وحدة جيدة (على الأقل 80٪ ، من الأفضل أن تكون 100٪) ، تحقق باستخدام:

  .. prompt:: bash

    pip install pytest pytest-cov
    pytest --cov sklearn path/to/tests

  انظر أيضًا :ref:`testing_coverage`.

* قم بتشغيل التحليل الثابت باستخدام `mypy`:

  .. prompt:: bash

      mypy sklearn

  يجب ألا ينتج عن هذا أخطاء جديدة في طلب السحب الخاص بك. يمكن أن يكون استخدام تعليق `# type: ignore` حلاً لبعض الحالات التي لا يدعمها mypy ، على وجه الخصوص ،

  - عند استيراد وحدات C أو Cython ،
  - على الخصائص ذات الزخارف.

    

ستحصل المساهمات التي تتضمن تحليل الأداء باستخدام سيناريو المعيار وإخراج التنميط (انظر :ref:`monitoring_performances`) على نقاط إضافية. يرجى أيضًا الاطلاع على دليل :ref:`performance-howto` للحصول على مزيد من التفاصيل حول تحسينات التنميط والسيثون.

.. note::

  حالة قاعدة شفرة scikit-learn الحالية غير متوافقة مع جميع هذه الإرشادات، لكننا نتوقع أن يؤدي فرض هذه القيود على جميع المساهمات الجديدة إلى تحسين جودة قاعدة الشفرة العامة في الاتجاه الصحيح.

.. seealso::

  للحصول على دليلين موثقين جيدًا وأكثر تفصيلاً حول سير عمل التطوير، يرجى زيارة قسم `Scipy Development Workflow <http://scipy.github.io/devdocs/dev/dev_quickstart.html>`_ - وقسم `Astropy Workflow for Developers <https://astropy.readthedocs.io/en/latest/development/workflow/development_workflow.html>`_.

تكامل مستمر (CI)

(ملحوظة: لم تتم ترجمة الرموز الخاصة والرموز والمعادلات الرياضية والروابط والتاجات والشفرة البرمجية وفقاً للتعليمات.)

هذا نص بتنسيق RST أريد ترجمته إلى اللغة العربية، مع الحفاظ على الرموز الخاصة والرموز والمعادلات الرياضية والروابط والتاجات والشفرة البرمجية كما هي:

---------------------------

* يتم استخدام Azure pipelines لاختبار scikit-learn على Linux وMac وWindows، مع تبعيات وإعدادات مختلفة.
* يتم استخدام CircleCI لبناء المستندات للعرض.
* يتم استخدام Github Actions للمهام المختلفة، بما في ذلك بناء العجلات والتوزيعات المصدرية.
* يتم استخدام Cirrus CI للبناء على ARM.

.. _commit_markers:

علامات رسالة الالتزام
^^^^^^^^^^^^^^^^^^^^^^

يرجى ملاحظة أنه إذا ظهرت واحدة من العلامات التالية في أحدث رسالة التزام، يتم اتخاذ الإجراءات التالية من قبل CI.

====================== ===================
علامة رسالة الالتزام     الإجراء الذي يتخذه CI
====================== ===================
[ci skip]              تخطي CI بالكامل
[cd build]             تشغيل CD (بناء العجلات والتوزيع المصدري)
[cd build gh]          تشغيل CD فقط لـ GitHub Actions
[cd build cirrus]      تشغيل CD فقط لـ Cirrus CI
[lint skip]            تخطي Azure pipeline للتدقيق
[scipy-dev]            البناء والاختبار مع بنات التطوير للتبعيات الخاصة بنا (numpy، scipy، إلخ)
[free-threaded]        البناء والاختبار مع CPython 3.13 خالٍ من الخيوط
[pyodide]              البناء والاختبار مع Pyodide
[azure parallel]       تشغيل وظائف Azure CI بالتوازي
[cirrus arm]           تشغيل اختبار Cirrus CI ARM
[float3

...

علامة رسالة الالتزام     الإجراء الذي يتخذه CI
====================== ===================
[float32]              تشغيل اختبارات float32 عن طريق تعيين `SKLEARN_RUN_FLOAT32_TESTS=1`. راجع :ref:`environment_variable` للحصول على مزيد من التفاصيل
[doc skip]             عدم بناء المستندات
[doc quick]            بناء المستندات، ولكن يستبعد مخططات مثال المعرض
[doc build]            بناء المستندات بما في ذلك مخططات مثال المعرض (طويلة جدًا)
====================== ===================

لاحظ أنه، بشكل افتراضي، يتم بناء المستندات ولكن يتم تنفيذ الأمثلة التي يتم تعديلها مباشرة بواسطة طلب السحب فقط.

ملفات القفل
^^^^^^^^^^

تستخدم CIs ملفات القفل لبناء بيئات بإصدارات محددة من التبعيات. عندما يحتاج طلب السحب إلى تعديل التبعيات أو إصداراتها، يجب تحديث ملفات القفل وفقًا لذلك. يمكن القيام بذلك عن طريق التعليق في طلب السحب:

.. code-block:: text

  @scikit-learn-bot update lock-files

سيقوم البوت بدفع التزام إلى فرع طلب السحب الخاص بك مع ملفات القفل المحدثة في غضون دقائق قليلة. تأكد من تحديد مربع الاختيار *Allow edits from maintainers* الموجود في أسفل الشريط الجانبي الأيمن لطلب السحب. يمكنك أيضًا تحديد الخيارات `--select-build`، و`--skip-build`، و`--select-tag` كما في سطر الأوامر. استخدم `--help` في البرنامج النصي `build_tools/update_environments_and_lock_files.py` للحصول على مزيد من المعلومات. على سبيل المثال،

.. code-block:: text

  @scikit-learn-bot update lock-files --select-tag main-ci --skip-build doc

سيضيف البوت تلقائيًا :ref:`commit message markers <commit_markers>` إلى الالتزام لعلامات معينة. إذا كنت تريد إضافة المزيد من العلامات يدويًا، يمكنك القيام بذلك باستخدام الخيار `--commit-marker`. على سبيل المثال، سيؤدي التعليق التالي إلى تشغيل البوت لتحديث ملفات القفل ذات الصلة بالمستندات وإضافة علامة `[doc build]` إلى الالتزام:

.. code-block:: text

  @scikit-learn-bot update lock-files --select-build doc --commit-marker "[doc build]"

.. _stalled_pull_request:

طلبات السحب المتوقفة
---------------------

نظرًا لأن المساهمة في ميزة يمكن أن تكون عملية طويلة، تظهر بعض طلبات السحب غير نشطة ولكنها غير مكتملة. في هذه الحالة، يعد توليها خدمة كبيرة للمشروع. آداب جيدة لتوليها هي:

* **تحديد ما إذا كان طلب السحب متوقفًا**

  * قد يحتوي طلب السحب على علامة "متوقف" أو "مطلوب مساعدة" إذا كنا قد حددناه بالفعل كمرشح لمساهمين آخرين.

  * لتحديد ما إذا كان طلب السحب غير النشط متوقفًا، اسأل المساهم عما إذا كان يخطط لمواصلة العمل على طلب السحب في المستقبل القريب.
    الفشل في الرد خلال أسبوعين بنشاط يحرك طلب السحب
    إلى الأمام يشير إلى أن طلب السحب متوقف وسيؤدي إلى وضع علامة على
    طلب السحب بـ "مطلوب مساعدة".

    لاحظ أنه إذا تلقى طلب السحب تعليقات سابقة على المساهمة
    التي لم تتلق أي رد في غضون شهر، فمن الآمن افتراض أن طلب السحب
    متوقف وتقصير وقت الانتظار إلى يوم واحد.

    بعد فترة التجربة، سيتم التواصل مع المشاركين في التجربة لمتابعة طلبات السحب غير المدمجة المفتوحة خلال فترة التجربة، وسيتم
    وضع علامة "تجربة" على تلك الطلبات. يمكن إعادة تعيين طلبات السحب الموسومة بـ "تجربة" أو
    إعلان توقفها من قبل قادة التجربة.

* **تولي طلب سحب متوقف**: لتولي طلب سحب، من المهم
  التعليق على طلب السحب المتوقف الذي تتولاه والارتباط من
  طلب السحب الجديد إلى الطلب القديم. يجب إنشاء طلب السحب الجديد عن طريق السحب من
  الطلب القديم.

القضايا المتوقفة وغير المطالب بها
----------------------------

بشكل عام، ستحتوي القضايا التي يمكن الحصول عليها على علامة
`"مطلوب مساعدة" <https://github.com/scikit-learn/scikit-learn/labels/help%20wanted>`_. ومع ذلك، لن تحتوي جميع القضايا التي تحتاج إلى مساهمين على هذه العلامة،
حيث لا يتم تحديث علامة "مطلوب مساعدة" دائمًا مع حالة
القضية. يمكن للمساهمين العثور على قضايا لا تزال مطروحة للتحصيل
باستخدام الإرشادات التالية:

* أولاً، **لتحديد ما إذا كانت القضية مطلوبة**:

  * تحقق من طلبات السحب المرتبطة
  * تحقق من المحادثة لمعرفة ما إذا كان أي شخص قد قال إنه يعمل على
    إنشاء طلب سحب

* إذا علق أحد المساهمين على قضية ليقول إنه يعمل عليها،
  من المتوقع تقديم طلب سحب في غضون أسبوعين (مساهم جديد) أو 4 أسابيع
  (مساهم أو مطور أساسي)، ما لم يتم إعطاء إطار زمني أكبر صراحة.
  بعد ذلك الوقت، يمكن لمساهم آخر تولي القضية وإنشاء
  طلب سحب لها. نشجع المساهمين على التعليق مباشرة على
  القضية المتوقفة أو غير المطالب بها لإعلام أعضاء المجتمع بأنهم سيعملون عليها.

* إذا كانت القضية مرتبطة بـ :ref:`stalled pull request <stalled_pull_request>`,
  نوصي بأن يتبع المساهمون الإجراء
  الموصوف في قسم :ref:`stalled_pull_request`
  بدلاً من العمل مباشرة على القضية.

.. _new_contributors:

القضايا للمساهمين الجدد

    

ينبغي على المساهمين الجدد البحث عن العلامات التالية عند البحث عن المشكلات. نوصي بشدة أن يتعامل المساهمون الجدد مع المشكلات "السهلة" أولاً: وهذا يساعد المساهم على التعرف على سير عمل المساهمة، ولدى المطورين الأساسيين للتعرف على المساهم؛ بالإضافة إلى ذلك، نحن غالبًا ما نقلل من سهولة حل المشكلة!

- **علامة المشكلة الأولى الجيدة**

  طريقة رائعة للبدء في المساهمة في scikit-learn هي اختيار عنصر من قائمة `المشكلات الأولى الجيدة <https://github.com/scikit-learn/scikit-learn/labels/good%20first%20issue>`_ في أداة تعقب المشكلات. يتيح حل هذه المشكلات للمساهمة في المشروع دون الحاجة إلى معرفة مسبقة كبيرة. إذا كنت قد ساهمت بالفعل في scikit-learn، فيجب عليك النظر في المشكلات السهلة بدلاً من ذلك.

- **علامة سهلة**

  إذا كنت قد ساهمت بالفعل في scikit-learn، فهناك طريقة رائعة أخرى للمساهمة في scikit-learn وهي اختيار عنصر من قائمة `المشكلات السهلة <https://github.com/scikit-learn/scikit-learn/labels/Easy>`_ في أداة تعقب المشكلات. سيكون مساعدتك في هذا المجال موضع تقدير كبير من قبل المطورين الأكثر خبرة لأنه يساعد في تحرير وقتهم للتركيز على مشكلات أخرى.

- **علامة المساعدة المطلوبة**

  نستخدم غالبًا علامة المساعدة المطلوبة لتحديد المشكلات بغض النظر عن مستوى الصعوبة. بالإضافة إلى ذلك، نستخدم علامة المساعدة المطلوبة لتحديد طلبات السحب التي تم التخلي عنها من قبل المساهم الأصلي ومتاحة لشخص ما ليواصل العمل من حيث توقّف المساهم الأصلي. يمكن العثور على قائمة المشكلات مع علامة المساعدة المطلوبة `هنا <https://github.com/scikit-learn/scikit-learn/labels/help%20wanted>`_. لاحظ أنه لن يكون لدى جميع المشكلات التي تحتاج إلى مساهمين هذه العلامة.

.. _contribute_documentation:

الوثائق

(لا يوجد نص للترجمة في هذا القسم)

نحن سعداء بقبول أي نوع من التوثيق:

* **توتير وظيفي/طريقة/فئة:** تعرف أيضًا باسم "توثيق واجهة برمجة التطبيقات"، وتصف ما يفعله الكائن وتفاصيل أي معلمات وسمات وطرق. توتير التوثيق يعيش جنبًا إلى جنب مع الكود في `sklearn/ <https://github.com/scikit-learn/scikit-learn/tree/main/sklearn>`_، ويتم إنشاؤها وفقًا لـ `doc/api_reference.py <https://github.com/scikit-learn/scikit-learn/blob/main/doc/api_reference.py>`_. لإضافة أو تحديث أو إزالة أو إهمال واجهة برمجة تطبيقات عامة مدرجة في :ref:`api_ref`، هذا هو المكان الذي يجب النظر فيه.
* **دليل المستخدم:** توفر هذه المعلومات معلومات أكثر تفصيلاً حول الخوارزميات التي تم تنفيذها في scikit-learn وعادة ما تعيش في الدليل الجذر `doc/ <https://github.com/scikit-learn/scikit-learn/tree/main/doc>`_ و
  `doc/modules/ <https://github.com/scikit-learn/scikit-learn/tree/main/doc/modules>`_.
* **أمثلة:** توفر هذه أمثلة كاملة على التعليمات البرمجية التي قد توضح استخدام وحدات scikit-learn أو مقارنة خوارزميات مختلفة أو مناقشة تفسيرها، وما إلى ذلك. وتعيش الأمثلة في `examples/ <https://github.com/scikit-learn/scikit-learn/tree/main/examples>`_.
* **وثائق أخرى من ReStructuredText:** توفر هذه المعلومات المختلفة الأخرى معلومات مفيدة (مثال: دليل :ref:`contributing`) وتعش في `doc/ <https://github.com/scikit-learn/scikit-learn/tree/main/doc>`_.

.. dropdown:: إرشادات لكتابة التوثيق

  * عند توثيق المعلمات والسمات، فيما يلي قائمة ببعض الأمثلة المنسقة بشكل جيد

    .. code-block:: text

      n_clusters : int, default=3
          عدد المجموعات التي كشف عنها الخوارزمية.

      some_param : {"hello", "goodbye"}, bool or int, default=True
          وصف المعلمة موجود هنا، ويمكن أن يكون إما سلسلة حرفية (إما `hello` أو `goodbye`)، أو قيمة منطقية، أو عدد صحيح. القيمة الافتراضية هي True.

      array_parameter : {array-like, sparse matrix} of shape (n_samples, n_features) \
          or (n_samples,)
          تقبل هذه المعلمة البيانات في أي من الأشكال المذكورة، مع واحد من الأشكال المذكورة. القيمة الافتراضية هي `np.ones(shape=(n_samples,))`.

      list_param : list of int

      typed_ndarray : ndarray of shape (n_samples,), dtype=np.int32

      sample_weight : array-like of shape (n_samples,), default=None

      multioutput_array : ndarray of shape (n_samples, n_classes) or list of such arrays

    بشكل عام ضع في الاعتبار ما يلي:

    * استخدم أنواع Python الأساسية. (``bool`` بدلاً من ``boolean``)
    * استخدم الأقواس لتعريف الأشكال: ``array-like of shape (n_samples,)`` أو ``array-like of shape (n_samples, n_features)``
    * بالنسبة للسلاسل ذات الخيارات المتعددة، استخدم الأقواس: ``input: {'log', 'squared', 'multinomial'}``
    * يمكن أن تكون البيانات أحادية أو ثنائية الأبعاد مجموعة فرعية من ``{array-like, ndarray, sparse matrix, dataframe}``. لاحظ أن ``array-like`` يمكن أن يكون أيضًا ``list``، في حين أن ``ndarray`` هو فقط ``numpy.ndarray`` بشكل صريح.
    * حدد ``dataframe`` عند استخدام ميزات تشبه الإطار، مثل أسماء الأعمدة.
    * عند تحديد نوع البيانات لقائمة، استخدم ``of`` كفاصل: ``list of int``. عندما تدعم المعلمة صفائف تمنح تفاصيل حول الشكل و/أو نوع البيانات وقائمة من هذه الصفائف، يمكنك استخدام أحد ``array-like of shape (n_samples,) or list of such arrays``.
    * عند تحديد نوع البيانات dtype لمصفوفة ndarray، استخدم على سبيل المثال ``dtype=np.int32`` بعد تحديد الشكل: ``ndarray of shape (n_samples,), dtype=np.int32``. يمكنك تحديد عدة أنواع بيانات كمجموعة: ``array-like of shape (n_samples,), dtype={np.float64, np.float32}``. إذا أراد أحد ذكر دقة عشوائية، استخدم `integral` و`floating` وليس نوع بيانات Python `int` و`float`. عندما يتم دعم كل من `int` و`floating`، فلا داعي لتحديد نوع البيانات.
    * عندما تكون القيمة الافتراضية ``None``، يجب تحديد ``None`` فقط في النهاية باستخدام ``default=None``. تأكد من تضمين ما يعنيه أن تكون المعلمة أو السمة ``None`` في التوثيق.

  * أضف "انظر أيضًا" في التوثيق للطبقات/الدوال ذات الصلة.

  * يجب أن تكون "انظر أيضًا" في التوثيق سطرًا واحدًا لكل مرجع، مع القولون وشرح، على سبيل المثال:

    .. code-block:: text

      See Also
      --------
      SelectKBest : Select features based on the k highest scores.
      SelectFpr : Select features based on a false positive rate test.

  * أضف مقتطفًا أو اثنين من التعليمات البرمجية في قسم "مثال" لإظهار كيفية استخدامه.


.. dropdown:: إرشادات لكتابة دليل المستخدم وغيرها من وثائق ReStructuredText

  من المهم الحفاظ على حل وسط جيد بين التفاصيل الرياضية والخوارزمية، وإعطاء الحدس للقارئ حول ما تفعله الخوارزمية على البيانات.

  * ابدأ بشرح موجز لما يفعله الخوارزمية/الكود على البيانات.

  * قم بتسليط الضوء على فائدة الميزة وتطبيقها الموصى به.
    فكر في تضمين تعقيد الخوارزمية (:math:`O\left(g\left(n\right)\right)`) إذا كان ذلك متاحًا، حيث يمكن أن تكون "قواعد الإبهام" معتمدة جدًا على الآلة. فقط إذا لم تكن هذه التعقيدات متوفرة، فيمكن توفير قواعد الإبهام بدلاً من ذلك.

  * قم بدمج صورة ذات صلة (تم إنشاؤها من مثال) لتوفير الحدس.

  * قم بتضمين مثال أو مثالين قصيرين من التعليمات البرمجية لإظهار استخدام الميزة.

  * قم بإدخال أي معادلات رياضية ضرورية، متبوعة بالإشارات. من خلال تأجيل الجوانب الرياضية، تصبح التوثيق أكثر قابلية للوصول للمستخدمين المهتمين بشكل أساسي بفهم الآثار العملية للميزة بدلاً من آلياتها الأساسية.

  * عند تحرير ملفات ReStructuredText (``.rst``)، حاول إبقاء طول الخط أقل من 88 حرفًا عند الإمكان (وتشمل الاستثناءات الروابط والجداول).
    
  (ملاحظة: لم تتضمن الترجمة العربية بعض عناصر التنسيق الخاصة بنظام ReStructuredText، مثل الأكواد البرمجية والأمثلة، بسبب عدم وجودها في النص الأصلي المراد ترجمته. يرجى الرجوع إلى النص الأصلي للحصول على هذه العناصر.)

  في ملفات reStructuredText الخاصة بـ scikit-learn، يتم عرض كل من الفواصل المنفردة والمزدوجة المحيطة بالنص كتسلسل حرفي مضمن (غالبًا ما يستخدم للشفرة، مثل `list`). هذا يرجع إلى تكوينات محددة قمنا بتعيينها. يجب استخدام الفواصل المنفردة في الوقت الحالي.

  * المعلومات الزائدة تجعل من الصعب على المستخدمين الوصول إلى المحتوى الذي يهتمون به. استخدم القوائم المنسدلة لترتيبها باستخدام بناء الجملة التالي:

    .. code-block:: rst

      .. dropdown:: عنوان القائمة المنسدلة

        محتوى القائمة المنسدلة.

    سوف ينتج عن المقتطف أعلاه القائمة المنسدلة التالية:

    .. dropdown:: عنوان القائمة المنسدلة

      محتوى القائمة المنسدلة.

  * المعلومات التي يمكن إخفاؤها افتراضيًا باستخدام القوائم المنسدلة هي:

    * الأقسام ذات التدرج الهرمي المنخفض مثل `References`، `Properties`، إلخ. (انظر على سبيل المثال الأقسام الفرعية في :ref:`det_curve`)؛

    * التفاصيل الرياضية المتعمقة؛

    * السرد الخاص بحالة الاستخدام؛

    * بشكل عام، السرد الذي قد يهم المستخدمين الذين يرغبون في تجاوز البراغماتية لأداة معينة.

  * لا تستخدم القوائم المنسدلة لقسم المستوى المنخفض `Examples`، حيث يجب أن يظل مرئيًا لجميع المستخدمين. تأكد من أن قسم `Examples` يأتي مباشرة بعد المناقشة الرئيسية مع أقل قسم مطوي ممكن بينهما.

  * يرجى الانتباه إلى أن القوائم المنسدلة تقطع المراجع المتقاطعة. إذا كان ذلك منطقيًا، قم بإخفاء المرجع جنبًا إلى جنب مع النص الذي يذكره. خلاف ذلك، لا تستخدم القائمة المنسدلة.


.. dropdown:: إرشادات لكتابة المراجع

  * عندما تكون المراجع الببليوغرافية متاحة بأرقام تعريف `arxiv <https://arxiv.org/>`_ أو `Digital Object Identifier <https://www.doi.org/>`_، استخدم توجيهاتphinx `:arxiv:` أو `:doi:`. على سبيل المثال، راجع المراجع في :ref:`Spectral Clustering Graphs <spectral_clustering_graph>`.

  * للحصول على قسم "References" في docstrings، راجع :func:`sklearn.metrics.silhouette_score` كمثال.

  * للإشارة إلى الصفحات الأخرى في وثائق scikit-learn، استخدم بناء جملة الإحالة المرجعية reStructuredText:

    * **Section:** للإشارة إلى قسم عشوائي في الوثائق، استخدم تسميات المرجع (انظر `Sphinx docs <https://www.sphinx-doc.org/en/master/usage/restructuredtext/roles.html#ref-role>`_). على سبيل المثال:

      .. code-block:: rst

          .. _my-section:

          قسمي
          ----------

          هذا هو نص القسم.

          للإشارة إلى نفسه استخدم :ref:`my-section`.

      يجب ألا تقوم بتعديل تسميات مرجع sphinx الموجودة لأن ذلك قد يؤدي إلى تعطيل المراجع المتقاطعة الحالية والروابط الخارجية التي تشير إلى أقسام معينة في وثائق scikit-learn.

    * **Glossary:** للإشارة إلى مصطلح في :ref:`glossary`:

      .. code-block:: rst

          :term:`cross_validation`

    * **Function:** للإشارة إلى وثائق الدالة، استخدم مسار الاستيراد الكامل إلى الدالة:

      .. code-block:: rst

          :func:`~sklearn.model_selection.cross_val_score`

      ومع ذلك، إذا كان هناك توجيه `.. currentmodule::` أعلى منك في المستند، فستحتاج فقط إلى استخدام المسار إلى الدالة التي تلي الوحدة الحالية المحددة. على سبيل المثال:

      .. code-block:: rst

          .. currentmodule:: sklearn.model_selection

          :func:`cross_val_score`

    * **Class:** للإشارة إلى وثائق الصف، استخدم مسار الاستيراد الكامل إلى الصف، ما لم يكن هناك توجيه `.. currentmodule::` في المستند أعلاه (انظر أعلاه):

      .. code-block:: rst

          :class:`~sklearn.preprocessing.StandardScaler`

يمكنك تحرير الوثائق باستخدام أي محرر نصوص، ثم إنشاء مخرجات HTML باتباع :ref:`building_documentation`. سيتم وضع ملفات HTML الناتجة في ``_build/html/`` ويمكن عرضها في مستعرض ويب، على سبيل المثال عن طريق فتح ملف ``_build/html/index.html`` المحلي أو عن طريق تشغيل خادم محلي

.. prompt:: bash

 python -m http.server -d _build/html


.. _building_documentation:

إنشاء الوثائق
    
    
    
    (ملاحظة: لم يتم تضمين العنوان "إنشاء الوثائق" في الترجمة لأنه عنوان رابط وليس نصًا يجب ترجمته.)

**قبل إرسال طلب سحب، تحقق مما إذا كانت التعديلات التي أجريتها قد أدت إلى ظهور تحذيرات جديدة منphinx عن طريق بناء التوثيق محليًا ومحاولة إصلاحها.**

أولاً، تأكد من أنك قمت **بتثبيت** إصدار التطوير **بطريقة صحيحة** <install_bleeding_edge>`. بالإضافة إلى ذلك، يتطلب بناء التوثيق تثبيت بعض الحزم الإضافية:

..
    لا حاجة إلى packaging بمجرد أن يبدأ setuptools بتضمين packaging>=17.0

.. prompt:: bash

    pip install sphinx sphinx-gallery numpydoc matplotlib Pillow pandas \
                polars scikit-image packaging seaborn sphinx-prompt \
                sphinxext-opengraph sphinx-copybutton plotly pooch \
                pydata-sphinx-theme sphinxcontrib-sass sphinx-design \
                sphinx-remove-toctrees

لبناء التوثيق، تحتاج إلى أن تكون في مجلد ``doc``:

.. prompt:: bash

    cd doc

في معظم الحالات، تحتاج فقط إلى توليد موقع الويب الكامل، بدون معرض الأمثلة:

.. prompt:: bash

    make

سيتم توليد التوثيق في مجلد ``_build/html/stable`` ويمكن عرضه في متصفح الويب، على سبيل المثال عن طريق فتح الملف المحلي ``_build/html/stable/index.html``.
لتوليد معرض الأمثلة أيضًا، يمكنك استخدام:

.. prompt:: bash

    make html

سيستغرق هذا الأمر بعض الوقت لتشغيل جميع الأمثلة. إذا كنت تريد فقط توليد بضعة أمثلة، وهو أمر مفيد بشكل خاص إذا كنت تعدل بعض الأمثلة، يمكنك استخدام:

.. prompt:: bash

    EXAMPLES_PATTERN=your_regex_goes_here make html

عيّن متغير البيئة `NO_MATHJAX=1` إذا كنت تنوي عرض التوثيق في وضع غير متصل بالإنترنت. لبناء دليل PDF، قم بتشغيل:

.. prompt:: bash

    make latexpdf

.. admonition:: إصدار Sphinx
   :class: warning

   على الرغم من بذلنا قصارى جهدنا لتوليد التوثيق تحت أكبر عدد ممكن من إصدارات Sphinx، إلا أن الإصدارات المختلفة تميل إلى التصرف بشكل مختلف قليلاً. للحصول على أفضل النتائج، يجب استخدام نفس الإصدار الذي استخدمناه على CircleCI. ابحث في هذا `البحث على GitHub <https://github.com/search?q=repo%3Ascikit-learn%2Fscikit-learn+%2F%5C%2Fsphinx-%5B0-9.%5D%2B%2F+path%3Abuild_tools%2Fcircle%2Fdoc_linux-64_conda.lock&type=code>`_ لمعرفة الإصدار الدقيق.


.. _generated_doc_CI:

التوثيق المولّد على GitHub Actions
-----------------------------------------

عندما تغير التوثيق في طلب سحب، يقوم GitHub Actions تلقائيًا ببنائه. لعرض التوثيق الذي ولّده GitHub Actions، اذهب ببساطة إلى أسفل صفحة طلب السحب الخاصة بك، وابحث عن العنصر "Check the rendered docs here!" وانقر على 'تفاصيل' بجانبه:

.. image:: ../images/generated-doc-ci.png
   :align: center

.. _testing_coverage:

الاختبار وتحسين تغطية الاختبار


(ملاحظة: لم يتم تضمين النص "Testing and improving test coverage" في الترجمة لأنه لم يكن هناك نص مطابق له في النص الأصلي.)

نص بتنسيق RST الذي تريد ترجمته إلى اللغة العربية:

===================================

اختبارات الوحدة عالية الجودة (`unit testing <https://en.wikipedia.org/wiki/Unit_testing>`_) هي حجر الزاوية في عملية تطوير scikit-learn. لهذا الغرض، نستخدم حزمة `pytest <https://docs.pytest.org>`_. الاختبارات هي وظائف مسماة بشكل مناسب، تقع في المجلدات الفرعية `tests`، والتي تتحقق من صحة الخوارزميات والخيارات المختلفة في الكود.

تشغيل `pytest` في مجلد سيقوم بتشغيل جميع اختبارات الحزم الفرعية المقابلة. لمزيد من التفاصيل حول سير عمل `pytest`، يرجى الرجوع إلى :ref:`pr_checklist`.

نتوقع أن يكون تغطية الكود للميزات الجديدة حوالي 90٪ على الأقل.

.. dropdown:: كتابة اختبارات متعلقة بـ matplotlib

  تضمن تركيبات الاختبار أن مجموعة من الاختبارات سيتم تنفيذها مع التهيئة والتنظيف المناسبين. تنفذ مجموعة اختبارات scikit-learn تجهيزة `pyplot` والتي يمكن استخدامها مع `matplotlib`.

  يجب استخدام تجهيزة `pyplot` عندما تتعامل دالة الاختبار مع `matplotlib`. `matplotlib` هو تبعية ناعمة وغير مطلوب. تتولى هذه التجهيزة مسؤولية تخطي الاختبارات إذا لم يتم تثبيت `matplotlib`. بالإضافة إلى ذلك، سيتم إغلاق الرسوم البيانية التي تم إنشاؤها أثناء الاختبارات تلقائيًا بمجرد تنفيذ دالة الاختبار.

  للاستفادة من هذه التجهيزة في دالة اختبار، تحتاج إلى تمريرها كوسيطة::

      def test_requiring_mpl_fixture(pyplot):
          # يمكنك الآن استخدام matplotlib بامان

.. dropdown:: سير العمل لتحسين تغطية الاختبارات

  لاختبار تغطية الكود، تحتاج إلى تثبيت حزمة `coverage <https://pypi.org/project/coverage/>`_ بالإضافة إلى `pytest`.

  1. تشغيل `pytest --cov sklearn /path/to/tests`. سيعرض الناتج لكل ملف أرقام الأسطر التي لم يتم اختبارها.

  2. ابحث عن فرصة سهلة، بالنظر إلى الأسطر التي لم يتم اختبارها، اكتب أو انسخ اختبارًا خصيصًا لهذه الأسطر.

  3. كرر الخطوات.

.. _monitoring_performances:

مراقبة الأداء
============

*هذا القسم مستوحى بشكل كبير من* `وثائق pandas <https://pandas.pydata.org/docs/development/contributing_codebase.html#running-the-performance-test-suite>`_.

عند اقتراح تغييرات على قاعدة الكود الموجودة، من المهم التأكد من أنها لا تسبب أي تراجع في الأداء. تستخدم Scikit-learn معايير `asv <https://github.com/airspeed-velocity/asv>`_ لمراقبة أداء مجموعة مختارة من المفوضين والوظائف الشائعة. يمكنك عرض هذه المعايير على `صفحة مقارنة scikit-learn <https://scikit-learn.org/scikit-learn-benchmarks>`_.
يمكن العثور على مجموعة مقارنة المقارنة المقابلة في دليل `asv_benchmarks/`.

لاستخدام جميع ميزات asv، ستحتاج إلى `conda` أو `virtualenv`. لمزيد من التفاصيل، يرجى التحقق من `صفحة تثبيت asv على الويب <https://asv.readthedocs.io/en/latest/installing.html>`_.

أولاً، تحتاج إلى تثبيت الإصدار التطويري من asv:

.. prompt:: bash

    pip install git+https://github.com/airspeed-velocity/asv

وتغيير الدليل الخاص بك إلى `asv_benchmarks/`:

.. prompt:: bash

 cd asv_benchmarks

تم تكوين مجموعة المقارنة لتشغيلها مقابل الاستنساخ المحلي الخاص بك من scikit-learn. تأكد من تحديثه:

.. prompt:: bash

  git fetch upstream

في مجموعة المقارنة، يتم تنظيم المقارنات باتباع نفس البنية مثل scikit-learn. على سبيل المثال، يمكنك مقارنة أداء مفوض معين بين ``upstream/main`` والفرع الذي تعمل عليه:

.. prompt:: bash

 asv continuous -b LogisticRegression upstream/main HEAD

تستخدم الأوامر conda بشكل افتراضي لإنشاء بيئات المقارنة. إذا كنت ترغب في استخدام virtualenv بدلاً من ذلك، فاستخدم العلم `-E`:

.. prompt:: bash

 asv continuous -E virtualenv -b LogisticRegression upstream/main HEAD

يمكنك أيضًا تحديد وحدة كاملة للمقارنة:

.. prompt:: bash

 asv continuous -b linear_model upstream/main HEAD

يمكنك استبدال `HEAD` بأي فرع محلي. بشكل افتراضي، سيبلغ فقط عن المقارنات التي تغيرت بنسبة 10٪ على الأقل. يمكنك التحكم في هذه النسبة باستخدام العلم `-f`.

للاتجاه مجموعة المقارنة الكاملة، ما عليك سوى إزالة العلم `-b`:

.. prompt:: bash

 asv continuous upstream/main HEAD

ومع ذلك، فقد يستغرق هذا الأمر ما يصل إلى ساعتين. يقبل العلم `-b` أيضًا تعبيرًا منتظمًا لمجموعة أكثر تعقيدًا من المقارنات لتشغيلها.

لتشغيل المقارنات دون المقارنة بفرع آخر، استخدم الأمر `run`:

.. prompt:: bash

 asv run -b linear_model HEAD^!

يمكنك أيضًا تشغيل مجموعة المقارنة باستخدام إصدار scikit-learn المثبت بالفعل في بيئة Python الحالية الخاصة بك:

.. prompt:: bash

 asv run --python=same

إنه مفيد بشكل خاص عند تثبيت scikit-learn في وضع قابل للتحرير لتجنب إنشاء بيئة جديدة في كل مرة تقوم فيها بتشغيل المقارنات. بشكل افتراضي، لا يتم حفظ النتائج عند استخدام تثبيت موجود. لحفظ النتائج، يجب عليك تحديد تجزئة الالتزام:

.. prompt:: bash

 asv run --python=same --set-commit-hash=<commit hash>

يتم حفظ المقارنات وتنظيمها حسب الجهاز والبيئة والالتزام. لعرض قائمة بجميع المقارنات المحفوظة:

.. prompt:: bash

 asv show

ولرؤية تقرير عن تشغيل معين:

.. prompt:: bash

 asv show <commit hash>

عند إجراء مقارنات لطلب سحب تعمل عليه، يرجى الإبلاغ عن النتائج على github.

تدعم مجموعة المقارنة خيارات قابلة للتكوين إضافية يمكن تعيينها في ملف التكوين `benchmarks/config.json`. على سبيل المثال، يمكن تشغيل المقارنات لقائمة محددة من القيم لمعامل `n_jobs`.

يمكن العثور على مزيد من المعلومات حول كيفية كتابة مقارنة وكيفية استخدام asv في `وثائق asv <https://asv.readthedocs.io/en/latest/index.html>`_.

.. _issue_tracker_tags:

علامات تعقب المشكلات

(تم إرسال هذا النص بتنسيق RST ولا يمكنني ترجمة علامات الترقيم والرموز والمعادلات الرياضية والروابط والعلامات والشفرة البرمجية وفقًا للتعليمات)

هذا نص بتنسيق RST أريد ترجمته إلى اللغة العربية، مع الحفاظ على الرموز الخاصة والرموز والمعادلات الرياضية والروابط والتاجات والشفرة البرمجية:

==================

يجب أن تحتوي جميع المشكلات وطلبات السحب على
`متتبع مشكلات GitHub <https://github.com/scikit-learn/scikit-learn/issues>`_
على الأقل على واحد من العلامات التالية:

:Bug:
    شيء يحدث ولا ينبغي أن يحدث.
    النتائج الخاطئة وكذلك الأخطاء غير المتوقعة من المقيمين تذهب هنا.

:Enhancement:
    تحسين الأداء، قابلية الاستخدام، والاتساق.

:Documentation:
    وثائق وأمثلة مفقودة أو غير صحيحة أو دون المستوى.

:New Feature:
    طلبات ميزة وطلبات سحب تقوم بتنفيذ ميزة جديدة.

هناك أربع علامات أخرى لمساعدة المساهمين الجدد:

:Good first issue:
    هذه المشكلة مثالية للمساهمة الأولى في scikit-learn. اطلب المساعدة
    إذا كان الصياغة غير واضحة. إذا كنت قد ساهمت بالفعل في
    scikit-learn، انظر إلى القضايا السهلة بدلاً من ذلك.

:Easy:
    يمكن معالجة هذه المشكلة دون الكثير من الخبرة السابقة.

:Moderate:
    قد تحتاج إلى بعض المعرفة بالتعلم الآلي أو الحزمة،
    ولكن لا يزال من الممكن الوصول إليها لشخص جديد في المشروع.

:Help wanted:
    هذه العلامة تميز المشكلة التي تفتقر حاليًا إلى المساهم أو
    PR الذي يحتاج إلى مساهم آخر لتولي العمل. هذه
    يمكن أن تتراوح القضايا في الصعوبة، وربما لن تكون مقبولة
    للمساهمين الجدد. لاحظ أن ليس كل القضايا التي تحتاج
    للمساهمين سيكون لديهم هذه العلامة.

.. _backwards-compatibility:

الحفاظ على التوافق مع الإصدارات السابقة

    


    هذا نص بتنسيق RST أريد ترجمته إلى اللغة العربية:

    ===================================

    .. _contributing_deprecation:

    الإهمال
    ------

    إذا تم تغيير اسم أي صف أو دالة أو خاصية أو معامل يمكن الوصول إليه بشكل عام، فإننا ما زلنا ندعم القديم لمدة إصدارين ونصدر تحذير إهمال عند استدعائه أو تمريره أو الوصول إليه.

    .. rubric:: إهمال صف أو دالة

    افترض أن الدالة ``zero_one`` تم تغيير اسمها إلى ``zero_one_loss``، فإننا نضيف الديكور :class:`utils.deprecated` إلى ``zero_one`` ونستدعي ``zero_one_loss`` من تلك الدالة::

        from ..utils import deprecated

        def zero_one_loss(y_true, y_pred, normalize=True):
            # التنفيذ الفعلي
            pass

        @deprecated(
            "تم تغيير اسم الدالة `zero_one` إلى `zero_one_loss` في الإصدار 0.13 وسيتم إزالتها في الإصدار 0.15. تم تغيير السلوك الافتراضي من `normalize=False` إلى `normalize=True`"
        )
        def zero_one(y_true, y_pred, normalize=False):
            return zero_one_loss(y_true, y_pred, normalize)

    يجب أيضًا نقل ``zero_one`` من ``API_REFERENCE`` إلى ``DEPRECATED_API_REFERENCE`` وإضافة ``zero_one_loss`` إلى ``API_REFERENCE`` في ملف ``doc/api_reference.py`` لتظاهر التغييرات في :ref:`api_ref`.

    .. rubric:: إهمال خاصية أو طريقة

    إذا كان يجب إهمال خاصية أو طريقة، استخدم الديكور :class:`~utils.deprecated` على الخاصية. يرجى ملاحظة أنه يجب وضع الديكور :class:`~utils.deprecated` قبل ديكور ``property`` إن وجد، حتى يمكن عرض الوثائق بشكل صحيح. على سبيل المثال، يمكن تغيير اسم الخاصية ``labels_`` إلى ``classes_``::

        @deprecated(
            "تم إهمال الخاصية `labels_` في الإصدار 0.13 وسيتم إزالتها في الإصدار 0.15. استخدم `classes_` بدلاً من ذلك"
        )
        @property
        def labels_(self):
            return self.classes_

    .. rubric:: إهمال معامل

    إذا كان يجب إهمال معامل، يجب رفع تحذير ``FutureWarning`` يدويًا. في المثال التالي، يتم إهمال ``k`` وتغيير اسمه إلى n_clusters::

        import warnings

        def example_function(n_clusters=8, k="deprecated"):
            if k != "deprecated":
                warnings.warn(
                    "`k` تم تغيير اسمه إلى `n_clusters` في الإصدار 0.13 وسيتم إزالته في الإصدار 0.15",
                    FutureWarning,
                )
                n_clusters = k

    عندما يكون التغيير في صف، يمكننا التحقق من الصحة ورفع تحذير في ``fit``::

      import warnings

      class ExampleEstimator(BaseEstimator):
          def __init__(self, n_clusters=8, k='deprecated'):
              self.n_clusters = n_clusters
              self.k = k

          def fit(self, X, y):
              if self.k != "deprecated":
                 warnings.warn(
                      "`k` تم تغيير اسمه إلى `n_clusters` في الإصدار 0.13 وسيتم إزالته في الإصدار 0.15.",
                      FutureWarning,
                  )
                 self._n_clusters = self.k
              else:
                 self._n_clusters = self.n_clusters

    كما في هذه الأمثلة، يجب أن تحتوي رسالة التحذير دائمًا على الإصدار الذي حدث فيه الإهمال والإصدار الذي سيتم فيه إزالة السلوك القديم. إذا حدث الإهمال في الإصدار 0.x-dev، يجب أن تقول الرسالة أن الإهمال حدث في الإصدار 0.x وسيتم الإزالة في 0.(x+2)، حتى يتمكن المستخدمون من توفير الوقت الكافي لتعديل الكود للسلوك الجديد. على سبيل المثال، إذا حدث الإهمال في الإصدار 0.18-dev، يجب أن تقول الرسالة أنه حدث في الإصدار 0.18 وسيتم إزالة السلوك القديم في الإصدار 0.20.

    يجب أن تتضمن رسالة التحذير أيضًا شرحًا موجزًا للتغيير وتشير المستخدمين إلى بديل.

    علاوة على ذلك، يجب إضافة ملاحظة إهمال في الوثائق، حيث تشرح نفس المعلومات كما في تحذير الإهمال كما هو موضح أعلاه. استخدم التوجيه ``.. deprecated::``:

    .. code-block:: rst

      .. deprecated:: 0.13
         ``k`` تم تغيير اسمه إلى ``n_clusters`` في الإصدار 0.13 وسيتم إزالته في الإصدار 0.15.

    ما هو أكثر من ذلك، يتطلب الإهمال اختبارًا يضمن رفع التحذير في الحالات ذات الصلة ولكن ليس في الحالات الأخرى. يجب التقاط التحذير في جميع الاختبارات الأخرى (باستخدام e.g., ``@pytest.mark.filterwarnings``)، ويجب عدم وجود تحذير في الأمثلة.

    تغيير القيمة الافتراضية لمعامل

    

إذا كانت هناك حاجة لتغيير القيمة الافتراضية لباراميتر، يرجى استبدال القيمة الافتراضية بقيمة محددة (مثل ``"warn"``) ورفع ``FutureWarning`` عندما يستخدم المستخدمون القيمة الافتراضية. يفترض المثال التالي أن الإصدار الحالي هو 0.20 وأننا نغير القيمة الافتراضية لـ ``n_clusters`` من 5 (القيمة الافتراضية القديمة لـ 0.20) إلى 10 (القيمة الافتراضية الجديدة لـ 0.22)::

    import warnings

    def example_function(n_clusters="warn"):
        if n_clusters == "warn":
            warnings.warn(
                "ستتغير القيمة الافتراضية لـ `n_clusters` من 5 إلى 10 في 0.22.",
                FutureWarning,
            )
            n_clusters = 5

عندما يكون التغيير في صنف، نقوم بالتحقق ورفع التحذير في ``fit``::

  import warnings

 class ExampleEstimator:
      def __init__(self, n_clusters="warn"):
          self.n_clusters = n_clusters

      def fit(self, X, y):
          if self.n_clusters == "warn":
              warnings.warn(
                  "ستتغير القيمة الافتراضية لـ `n_clusters` من 5 إلى 10 في 0.22.",
                  FutureWarning,
              )
              self._n_clusters = 5

على غرار الإهمال، يجب أن تعطي رسالة التحذير دائمًا كلا من الإصدار الذي حدث فيه التغيير والإصدار الذي سيتم فيه إزالة السلوك القديم.

يجب تحديث وصف الباراميتر في docstring وفقًا لذلك عن طريق إضافة توجيه ``versionchanged`` بالقيمة الافتراضية القديمة والجديدة، مشيرًا إلى الإصدار الذي سيتم فيه تطبيق التغيير:

.. code-block:: rst

    .. versionchanged:: 0.22
       ستتغير القيمة الافتراضية لـ `n_clusters` من 5 إلى 10 في الإصدار 0.22.

أخيرًا، نحن بحاجة إلى اختبار يضمن رفع التحذير في الحالات ذات الصلة ولكن ليس في حالات أخرى. يجب التقاط التحذير في جميع الاختبارات الأخرى (باستخدام مثل ``@pytest.mark.filterwarnings``)، ويجب ألا يكون هناك تحذير في الأمثلة.

.. _code_review:

إرشادات مراجعة الكود

    
(ملاحظة: لم يتم ترجمة النص البرمجي والأكواد لتجنب أي أخطاء في الترجمة)

  هذا نص بتنسيق RST أريد ترجمته إلى اللغة العربية، مع الحفاظ على الرموز الخاصة والرياضية والروابط والتاجات والشفرة البرمجية دون ترجمة:

======================

يعد مراجعة الكود المساهم به في المشروع كطلبات سحب (PRs) مكونًا حاسمًا في تطوير scikit-learn. نشجع أي شخص على البدء في مراجعة كود المطورين الآخرين. غالبًا ما تكون عملية مراجعة الكود تعليمية للغاية لجميع المشاركين. هذا مناسب بشكل خاص إذا كانت ميزة ترغب في استخدامها، وبالتالي يمكنك الرد بشكل نقدي حول ما إذا كان طلب السحب يلبي احتياجاتك. بينما يجب توقيع كل طلب سحب من قبل مطورين أساسيين، يمكنك تسريع هذه العملية من خلال تقديم ملاحظاتك.

.. note::

  الفرق بين التحسين الموضوعي والتعليق الشخصي ليس واضحًا دائمًا. يجب على المراجعين تذكر أن مراجعة الكود تهدف في المقام الأول إلى تقليل المخاطر في المشروع. عند مراجعة الكود، يجب أن تهدف إلى منع المواقف التي قد تتطلب إصلاح الأخطاء أو إهمالها أو سحبها. فيما يتعلق بالوثائق: من الأفضل معالجة الأخطاء الإملائية وقضايا القواعد وتوضيحها على الفور.

.. dropdown:: الجوانب المهمة التي يجب تغطيتها في أي مراجعة للكود

  فيما يلي بعض الجوانب المهمة التي يجب تغطيتها في أي مراجعة للكود، من الأسئلة عالية المستوى إلى قائمة تحقق أكثر تفصيلاً.

  - هل نريد هذا في المكتبة؟ هل من المحتمل أن يتم استخدامه؟ هل أنت، كمستخدم لـ scikit-learn، تحب التغيير وتنوي استخدامه؟ هل هو ضمن نطاق scikit-learn؟ هل سيكون تكلفة الصيانة لميزة جديدة تستحق فوائدها؟

  - هل الكود متسق مع واجهة برمجة التطبيقات (API) لـ scikit-learn؟ هل الوظائف/الفئات/المعلمات العامة مسماة جيدًا ومصممة بشكل بديهي؟

  - هل جميع الوظائف/الفئات العامة ومعلماتها وأنواع الإرجاع والسجلات المسماة وفقًا لاتفاقيات scikit-learn وموثقة بوضوح؟

  - هل يتم وصف أي وظائف جديدة في دليل المستخدم وتوضيحها بالأمثلة؟

  - هل يتم اختبار كل وظيفة/فئة عامة؟ هل تم اختبار مجموعة معقولة من المعلمات، وقيمها، وأنواع القيم، والتركيبات؟ هل الاختبارات تتحقق من أن الكود صحيح، أي يفعل ما تقوله الوثائق؟ إذا كان التغيير هو إصلاح الأخطاء، فهل تم تضمين اختبار عدم الانحدار؟ انظر إلى `هذا <https://jeffknupp.com/blog/2013/12/09/improve-your-python-understanding-unit-testing>`__ للبدء في الاختبار في Python.

  - هل اجتازت الاختبارات في بناء التكامل المستمر؟ إذا كان ذلك مناسبًا، ساعد المساهم في فهم سبب فشل الاختبارات.

  - هل تغطي الاختبارات كل سطر من التعليمات البرمجية (انظر تقرير التغطية في سجل الإنشاء)؟ إذا لم يكن كذلك، هل الأسطر التي تفتقد التغطية استثناءات جيدة؟

  - هل الكود سهل القراءة ومنخفض التكرار؟ هل يجب تحسين أسماء المتغيرات من أجل الوضوح أو الاتساق؟ هل يجب إضافة التعليقات؟ هل يجب إزالة التعليقات لأنها غير مفيدة أو زائدة عن الحاجة؟

  - هل يمكن إعادة كتابة الكود بسهولة ليتم تشغيله بكفاءة أكبر للإعدادات ذات الصلة؟

  - هل الكود متوافق مع الإصدارات السابقة؟ (أو هل دورة الإهمال ضرورية؟)

  - هل سيضيف الكود الجديد أي تبعيات على المكتبات الأخرى؟ (من غير المرجح قبول هذا)

  - هل يتم عرض الوثائق بشكل صحيح (انظر قسم :ref:`contribute_documentation` لمزيد من التفاصيل)، وهل الرسوم البيانية تعليمية؟

  :ref:`saved_replies` يتضمن بعض التعليقات المتكررة التي قد يدلي بها المراجعون.

.. _communication:

.. dropdown:: إرشادات التواصل

  يساعد مراجعة طلبات السحب (PRs) المفتوحة في نقل المشروع إلى الأمام. إنها طريقة رائعة للتعرف على قاعدة الشفرة ويجب أن تحفز المساهم على الاستمرار في المشاركة في المشروع. [1]_

  - كل طلب سحب، جيد أو سيء، هو عمل من أعمال الكرم. سيساعد البدء بتعليق إيجابي المؤلف على الشعور بالمكافأة، وقد يتم سماع ملاحظاتك اللاحقة بشكل أوضح. قد تشعر بالرضا أيضًا.
  - ابدأ إذا أمكن بالقضايا الكبيرة، حتى يعرف المؤلف أنه قد تم فهمه. قاوم إغراء الانتقال على الفور سطرًا بسطر، أو البدء بقضايا صغيرة شائعة.
  - لا تدع الكمال يكون عدوًا للخير. إذا وجدت نفسك تقدم العديد من الاقتراحات الصغيرة التي لا تندرج تحت :ref:`code_review`، ففكر في الأساليب التالية:

    - امتنع عن تقديم هذه الاقتراحات؛
    - قم بتقديمها كـ "Nit" حتى يعرف المساهم أنه لا بأس من عدم معالجتها؛
    - تابع في طلب سحب لاحق، من باب المجاملة، قد ترغب في إعلام المساهم الأصلي.

  - لا تتسرع، خذ الوقت الكافي لتوضيح تعليقاتك وتبرير اقتراحاتك.
  - أنت تمثل المشروع. تحدث الأيام السيئة للجميع، في هذه المناسبة تستحق استراحة: حاول أن تأخذ وقتك وتبقى غير متصل بالإنترنت.

  .. [1] مقتبس من إرشادات الاتصال في numpy `<https://numpy.org/devdocs/dev/reviewer_guidelines.html#communication-guidelines>`_.

قراءة قاعدة الشفرة الحالية

    

قراءة قاعدة الشفرة الحالية

    

  هذا نص بتنسيق RST أريد ترجمته إلى اللغة العربية، مع الحفاظ على الرموز الخاصة والرياضية والروابط والتاجات والشفرة البرمجية دون ترجمة:

==============================

قراءة وفهم قاعدة شفرة موجودة siempre es un ejercicio difícil
que requiere tiempo وخبرة للتحكم فيه. على الرغم من أننا نحاول كتابة شفرة بسيطة
بشكل عام، إلا أن فهم الشفرة قد يبدو ساحقًا في البداية،
نظرا لحجم المشروع الهائل. إليك قائمة بالنصائح التي قد تساعد
اجعل هذه المهمة أسهل وأسرع (بدون ترتيب معين).

- تعرف على :ref:`api_overview`: فهم ما يستخدم :term:`fit`,
  :term:`predict`, :term:`transform`, إلخ.
- قبل الغوص في قراءة شفرة الدالة / الفئة، اذهب من خلال
  أولاً وحاول الحصول على فكرة عما يفعله كل معلمة / سمة. قد يساعد أيضًا في التوقف دقيقة والتفكير *كيف سأفعل هذا
  نفسي إذا اضطررت؟*
- الأمر الأكثر صعوبة هو غالبًا تحديد أي أجزاء من الشفرة
  ذات صلة، والتي ليست كذلك. في scikit-learn **الكثير** من فحص الإدخال
  يتم تنفيذه، خاصة في بداية :term:`fit` الطرق.
  في بعض الأحيان، جزء صغير جدًا من الشفرة هو الذي يقوم بالوظيفة الفعلية.
  على سبيل المثال، عند النظر إلى طريقة :meth:`~linear_model.LinearRegression.fit` من
  :class:`~linear_model.LinearRegression`, ما تبحث عنه
  قد يكون مجرد استدعاء :func:`scipy.linalg.lstsq`, لكنه مدفون في
  إنه مدفون في أسطر متعددة من فحص المدخلات ومعالجة أنواع مختلفة من
  المعلمات.
- نظرًا لاستخدام `الميراث
  <https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)>`_,
  قد يتم تنفيذ بعض الطرق في الفئات الأصلية. كل المقيمين يرثون
  على الأقل من :class:`~base.BaseEstimator`, ومن
  فئة ``Mixin`` (مثل :class:`~base.ClassifierMixin`) التي تمكن السلوك الافتراضي
  اعتمادًا على طبيعة المقيم (المصنف، الوسيط، المحول، إلخ).
- في بعض الأحيان، سيعطيك قراءة الاختبارات لوظيفة معينة فكرة عن
  ما هو الغرض منه. يمكنك استخدام ``git grep`` (انظر أدناه) للعثور على
  جميع الاختبارات المكتوبة لوظيفة ما. يتم وضع معظم الاختبارات لوظيفة/فئة محددة تحت المجلد ``tests/`` للوحدة
- سترى غالبًا شفرة تبدو مثل هذا:
  ``out = Parallel(...)(delayed(some_function)(param) for param in
 some_iterable)``. هذا ينفذ ``some_function`` بالتوازي باستخدام `Joblib
  <https://joblib.readthedocs.io/>`_. ``out`` هو بعد ذلك قابل للتكرار يحتوي
  القيم التي تعيدها ``some_function`` لكل مكالمة.
- نستخدم `Cython <https://cython.org/>`_ لكتابة شفرة سريعة. شفرة Cython تقع في ملفات ``.pyx`` و ``.pxd``. شفرة Cython لديها نكهة أكثر شبهاً بـ C:
  نستخدم المؤشرات، ونقوم بتخصيص الذاكرة اليدوي، إلخ. وجود بعض الخبرة الدنيا في C / C ++ هو أمر إلزامي إلى حد كبير هنا. لمزيد من المعلومات، انظر
  :ref:`cython`.
- أتقن أدواتك.

  - مع مثل هذا المشروع الكبير، كونك فعالاً مع محرر مفضل أو
    IDE يقطع شوطًا طويلاً نحو هضم قاعدة الشفرة. أن تكون قادرًا على القفز بسرعة (أو *قراءة خاطفة*) إلى دالة / فئة / سمة يساعد كثيرا.
    كذلك القدرة على رؤية المكان الذي يستخدم فيه اسم معين بسرعة في ملف.
  - `Git <https://git-scm.com/book/en>`_ لديه أيضًا بعض الميزات القاتلة المضمنة. غالبًا ما يكون من المفيد فهم كيفية تغيير ملف بمرور الوقت،
    باستخدام، على سبيل المثال، ``git blame`` (`دليل
    <https://git-scm.com/docs/git-blame>`_). ويمكن أيضًا القيام بذلك مباشرة
    على GitHub. ``git grep`` (`أمثلة
    <https://git-scm.com/docs/git-grep#_examples>`_) هو أيضا مفيد للغاية لرؤية كل حدوث لنمط (على سبيل المثال، استدعاء دالة أو أ
    متغير) في قاعدة الشفرة.

- قم بتكوين `git blame` لتجاهل الالتزام الذي هاجر نمط الشفرة إلى
  `black`.

  .. prompt:: bash

      git config blame.ignoreRevsFile .git-blame-ignore-revs

  اعثر على مزيد من المعلومات في توثيق black's
  `documentation for avoiding ruining git blame <https://black.readthedocs.io/en/stable/guides/introducing_black_to_your_project.html#avoiding-ruining-git-blame>`_.
    
    
