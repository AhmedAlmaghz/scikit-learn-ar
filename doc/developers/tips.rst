
    هذا نص بتنسيق RST أريد ترجمته إلى اللغة العربية، مع الإبقاء على الرموز الخاصة والرموز والمعادلات الرياضية والروابط والتاجات والشفرة البرمجية كما هي:

.. _developers-tips:

===========================
نصائح وحيل للمطورين
===========================

نصائح للحفاظ على الإنتاجية والعقلانية

(ملاحظة: لم يتم ترجمة المحتوى الداخلي بسبب عدم توفره في النص الأصلي.)

في هذا القسم، نجمع بعض النصائح والأدوات المفيدة التي قد تزيد من جودة حياتك عند مراجعة طلبات السحب وتشغيل اختبارات الوحدة وغيرها. تتكون بعض هذه الحيل من نصوص مستخدم تتطلب امتداد متصفح مثل TamperMonkey أو GreaseMonkey؛ لإعداد نصوص المستخدم، يجب أن يكون أحد هذه الإضافات مثبتًا وممكّنًا وقيد التشغيل. نحن نقدم نصوص المستخدم كملفات GitHub gists؛ لتثبيتها، انقر فوق الزر "Raw" في صفحة الملخص.

.. _TamperMonkey: https://tampermonkey.net/
.. _GreaseMonkey: https://www.greasespot.net/

طي ونشر الاختلافات القديمة في طلبات السحب
-----------------------------------------------------

يخفي GitHub المناقشات على طلبات السحب عندما يتم تغيير خطوط التعليمات البرمجية المقابلة في غضون ذلك. يوفر هذا النص البرمجي اختصارًا (Control-Alt-P في وقت كتابة هذا التقرير ولكن انظر إلى التعليمات البرمجية للتأكد) للكشف عن جميع المناقشات المخفية مرة واحدة، حتى تتمكن من اللحاق بالركب.

التحقق من طلبات السحب كفروع التتبع عن بعد
------------------------------------------------------

في الشوكة المحلية الخاصة بك، أضف إلى `` .git/config `` الخاص بك، تحت العنوان `` [remote "upstream"] ``، السطر::

 fetch = +refs/pull/*/head:refs/remotes/upstream/pr/*

يمكنك بعد ذلك استخدام `` git checkout pr/PR_NUMBER `` للتنقل إلى رمز طلب السحب بالرقم المحدد. (`اقرأ المزيد في هذا المستند. <https://gist.github.com/piscisaureus/3342247>`_)

عرض تغطية الرمز في طلبات السحب
--------------------------------------

لتراكب تقارير تغطية الرمز التي تم إنشاؤها بواسطة تكامل CodeCov المستمر، فكر في `هذا الامتداد للمتصفح <https://github.com/codecov/browser-extension>`_. سيتم عرض تغطية كل سطر كلون خلفية خلف رقم السطر.


.. _pytest_tips:

pytest المエイز والأعلام المفيدة
-------------------------------

تستغرق مجموعة الاختبارات الكاملة وقتًا طويلاً حتى تعمل. للتكرار بشكل أسرع، من الممكن تحديد مجموعة فرعية من الاختبارات باستخدام محددات pytest.
على وجه الخصوص، يمكن للمرء تشغيل `اختبار واحد بناءً على معرف عقدته <https://docs.pytest.org/en/latest/example/markers.html#selecting-tests-based-on-their-node-id>`_:

.. prompt:: bash $

 pytest -v sklearn/linear_model/tests/test_logistic.py::test_sparsify

أو استخدم معلمة `-k pytest <https://docs.pytest.org/en/latest/example/markers.html#using-k-expr-to-select-tests-based-on-their-name>`_
لتحديد الاختبارات بناءً على اسمها. على سبيل المثال،:

.. prompt:: bash $

 pytest sklearn/tests/test_common.py -v -k LogisticRegression

سيتم تشغيل جميع `الاختبارات الشائعة <term> common tests </term>` للمنظم `` LogisticRegression ``.

عندما يفشل اختبار الوحدة، يمكن أن تجعل الحيل التالية التصحيح أسهل:

1. تقوم حجة سطر الأوامر `` pytest -l `` بتوجيه pytest لطباعة المتغيرات المحلية عند حدوث فشل.

2. تقوم الحجة `` pytest --pdb '' بإسقاط مصحح أخطاء Python عند الفشل. بدلاً من ذلك، لإسقاط مصحح الأخطاء الغني IPython `` ipdb ''، يمكنك إعداد alias shell إلى:

   .. prompt:: bash $

      pytest --pdbcls=IPython.terminal.debugger:TerminalPdb --capture no

تشمل خيارات `pytest` الأخرى التي قد تكون مفيدة:

- `` -x `` الذي يخرج عند أول اختبار فاشل،
- `` --lf '' لإعادة تشغيل الاختبارات التي فشلت في التشغيل السابق،
- `` --ff '' لإعادة تشغيل جميع الاختبارات السابقة، تشغيل تلك التي فشلت أولاً،
- `` -s '' بحيث لا يلتقط pytest ناتج عبارات `` print () ''،
- `` --tb = short '' أو `` --tb = line '' للتحكم في طول السجلات،
- `` --runxfail '' أيضًا قم بتشغيل الاختبارات التي تم وضع علامة عليها على أنها فشل معروف (XFAIL) وأبلغ عن الأخطاء.

نظرًا لأن اختبارات التكامل المستمر لدينا ستخطئ إذا لم يتم التقاط `` FutureWarning '' بشكل صحيح، فمن المستحسن أيضًا تشغيل `` pytest '' مع علامة `` -Werror :: FutureWarning ''.

.. _saved_replies:

الردود القياسية للمراجعة

(ملحوظة: لم يتم تضمين محتوى الردود القياسية في النص الأصلي، لذلك لم تتم ترجمته.)

قد يكون من المفيد تخزين بعض هذه الردود في "الردود المحفوظة" في جيتهاب لمراجعتها:

.. highlight:: none

..
    لاحظ أن وضع هذا المحتوى في سطر واحد في نص حرفي هو أسهل طريقة لجعله قابلاً للنسخ وملفوفًا على الشاشة.

المشكلة: أسئلة الاستخدام

::

    أنت تطرح سؤال استخدام. يتتبع المتتبع المشكلات والأخطاء والميزات الجديدة. بالنسبة لأسئلة الاستخدام، يوصى بتجربة [Stack Overflow](https://stackoverflow.com/questions/tagged/scikit-learn) أو [قائمة البريد الإلكتروني](https://mail.python.org/mailman/listinfo/scikit-learn).

    للأسف، نحتاج إلى إغلاق هذه المشكلة لأن أداة التتبع هذه هي أداة اتصال تستخدم في تطوير scikit-learn. النشاط الإضافي الذي تم إنشاؤه بواسطة أسئلة الاستخدام يزحمها كثيرًا ويعيق هذا التطوير. يمكن أن تستمر المحادثة هنا، ولكن لا يوجد ضمان أنها ستتلقى انتباهًا من المطورين الأساسيين.


المشكلة: أنت مرحب بك لتحديث المستندات

::

    يرجى عدم التردد في تقديم طلب سحب لتحديث المستندات إذا كنت تعتقد أنها قد تكون بحاجة للتحسين.

المشكلة: مثال مستقل للخطأ

::

    يرجى تقديم [كود مثال مستقل](https://scikit-learn.org/dev/developers/minimal_reproducer.html)، بما في ذلك الواردات والبيانات (إن أمكن)، بحيث يمكن للمساهمين الآخرين تشغيله وإعادة إنتاج مشكلتك. من الناحية المثالية يجب أن يكون مثال الكود الخاص بك بسيطًا.

المشكلة: إصدارات البرامج

::

    لمساعدتك في تشخيص مشكلتك، يرجى لصق الإخراج الخاص بـ:
    ```py
    import sklearn; sklearn.show_versions()
    ```
    شكرًا.

المشكلة: كتل التعليمات البرمجية

::

    يمكن تحسين قابلية القراءة بشكل كبير إذا قمت [بتنسيق](https://help.github.com/articles/creating-and-highlighting-code-blocks/) مقتطفات التعليمات البرمجية ورسائل الخطأ الكاملة بشكل مناسب. على سبيل المثال:

        ```python
        print(something)
        ```

    ينتج:

    ```python
    print(something)
    ```

    و:

        ```pytb
        Traceback (most recent call last):
            File "<stdin>", line 1, in <module>
        ImportError: No module named 'hello'
        ```

    ينتج:

    ```pytb
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
    ImportError: No module named 'hello'
    ```

    يمكنك تحرير أوصاف مشكلتك وتعليقاتك في أي وقت لتحسين قابلية القراءة. هذا يساعد المطورين كثيرًا. شكرًا!

المشكلة/التعليق: الربط بالكود

::

    نصيحة ودية: يمكنك ربط الرمز [بهذا](https://help.github.com/articles/creating-a-permanent-link-to-a-code-snippet/) من أجل الوضوح.

المشكلة/التعليق: الارتباط بالتعليقات

::

    يرجى استخدام روابط للتعليقات، مما يسهل كثيرًا معرفة ما تشير إليه، بدلاً من مجرد الارتباط بالمشكلة. انظر [هذا](https://stackoverflow.com/questions/25163598/how-do-i-reference-a-specific-issue-comment-on-github) لمزيد من التفاصيل.

PR-NEW: وصف وعنوان أفضل

::

    شكرًا لك على طلب السحب! يرجى جعل عنوان PR أكثر وصفًا. سيصبح العنوان رسالة التزام عند دمج هذا. يجب أن تنص على المشكلة (أو PR) التي تصلحها / تحلها في الوصف باستخدام بناء الجملة الموصوف [هنا](https://scikit-learn.org/dev/developers/contributing.html#contributing-pull-requests).

PR-NEW: إصلاح #

::

    يرجى استخدام "إصلاح #issueNumber" في وصف PR الخاص بك (ويمكنك القيام بذلك أكثر من مرة). بهذه الطريقة يتم إغلاق المشكلة المرتبطة تلقائيًا عند دمج PR. لمزيد من التفاصيل، انظر [هذا](https://github.com/blog/1506-closing-issues-via-pull-requests).

PR-NEW أو مشكلة: تكلفة الصيانة

::

    تتضمن كل ميزة ندرجها [تكلفة صيانة](https://scikit-learn.org/dev/faq.html#why-are-you-so-selective-on-what-algorithms-you-include-in-scikit-learn). معظم صيانتنا متطوعين. لإدراج ميزة جديدة، نحتاج إلى دليل على أنها غالبًا ما تكون مفيدة، ومن الناحية المثالية، [راسخة](https://scikit-learn.org/dev/faq.html#what-are-the-inclusion-criteria-for-new-algorithms) في الأدبيات أو في الممارسة العملية. أيضًا، نتوقع من مؤلفي PR المشاركة في الصيانة للكود الذي يقدمونه، على الأقل في البداية. هذا لا يمنعك من تنفيذه لنفسك ونشره في مستودع منفصل، أو حتى [scikit-learn-contrib](https://scikit-learn-contrib.github.io).

PR-WIP: ما المطلوب قبل الدمج؟

::

    يرجى توضيح (ربما كقائمة مهام في وصف PR) العمل الذي تعتقد أنه لا يزال يتعين القيام به قبل أن يمكن مراجعته للدمج. عندما يصبح جاهزًا، يرجى سابق عنوان PR بـ `[MRG]`.

PR-WIP: اختبار الانحدار مطلوب

::

    يرجى إضافة [اختبار عدم الانحدار](https://en.wikipedia.org/wiki/Non-regression_testing) من شأنه أن يفشل في الاختبار الرئيسي ولكن يمر في هذا PR.

PR-WIP: PEP8

::

    لديك بعض انتهاكات [PEP8](https://www.python.org/dev/peps/pep-0008/)، والتي يمكنك الاطلاع على تفاصيلها في وظيفة `lint` في Circle CI. قد يكون من المفيد تكوين محرر تعليمات برمجية للتحقق من مثل هذه الأخطاء أثناء التنقل، بحيث يمكنك اكتشافها قبل الالتزام.

PR-MRG: صبر

::

    قبل الدمج، نطلب عمومًا من مطورين أساسيين الموافقة على أن طلب السحب الخاص بك مرغوب فيه وجاهز. [يرجى التحلي بالصبر](https://scikit-learn.org/dev/faq.html#why-is-my-pull-request-not-getting-any-attention)، حيث نعتمد في الغالب على الوقت المتطوع من المطورين الأساسيين المشغولين. (أنت أيضًا مرحب بك للمساعدة في [مراجعة PRs الأخرى](https://scikit-learn.org/dev/developers/contributing.html#code-review-guidelines).)

PR-MRG: أضف ما هو جديد

::

    يرجى إضافة إدخال إلى سجل التغيير في `doc/whats_new/v*.rst`. مثل الإدخالات الأخرى هناك، يرجى الرجوع إلى طلب السحب هذا باستخدام `:pr:` وإعطاء نفسك الفضل (والمساهمين الآخرين إذا كان ذلك مناسبًا) مع `:user:`.

PR: لا تغير غير ذي صلة

::

    يرجى عدم تغيير الأسطر غير ذات الصلة. يجعل مساهمتك أصعب في المراجعة وقد يؤدي إلى تعارضات دمج لطلبات السحب الأخرى.

.. _debugging_ci_issues:

تصحيح مشكلات CI

    

(ملاحظة: لم يتم ترجمة بعض الكلمات مثل PEP8 و Circle CI و Stack Overflow نظرًا لأنها علامات تجارية أو مصطلحات تقنية شائعة الاستخدام في مجتمع البرمجة.)

  قد تنشأ مشاكل التكامل المستمر (CI) لعدة أسباب، لذلك هذه ليست إرشادات شاملة، بل قائمة بالنصائح والحيل المفيدة.

    استخدام ملف القفل للحصول على بيئة مشابهة لبيئة التكامل المستمر
    ----------------------------------------------------------------

    يمكن استخدام `conda-lock` لإنشاء بيئة كوندا بنفس حزم كوندا وبايب كما في التكامل المستمر. على سبيل المثال، سيؤدي الأمر التالي إلى إنشاء بيئة كوندا باسم `scikit-learn-doc` مشابهة لبيئة التكامل المستمر:

    .. prompt:: bash $

        conda-lock install -n scikit-learn-doc build_tools/circle/doc_linux-64_conda.lock

    .. note::

        هذا يعمل فقط إذا كان لديك نفس نظام التشغيل كما في بناء التكامل المستمر (تحقق من `platform:` في ملف القفل). على سبيل المثال، لن يعمل الأمر السابق إلا إذا كنت تستخدم جهازًا بنظام لينكس. أيضًا، قد لا يسمح لك هذا بإعادة إنتاج بعض المشكلات التي ترتبط بشكل أكبر بمميزات بيئة التكامل المستمر، على سبيل المثال الهندسة المعمارية لوحدة المعالجة المركزية التي أبلغ عنها OpenBLAS في `sklearn.show_versions()`.

    إذا لم يكن لديك نفس نظام التشغيل كما في بناء التكامل المستمر، فلا يزال بإمكانك إنشاء بيئة كوندا من ملف yaml الصحيح، على الرغم من أنها لن تكون قريبة من بيئة التكامل المستمر مثل استخدام ملف القفل المرتبط. على سبيل المثال لبناء المستند:

    .. prompt:: bash $

        conda env create -n scikit-learn-doc -f build_tools/circle/doc_environment.yml -y

    قد لا يمنحك هذا الإصدار بالضبط نفس إصدارات الحزمة كما في التكامل المستمر لعدة أسباب، على سبيل المثال:

    - قد يكون لبعض الحزم إصدارات جديدة بين آخر تحديث لملفات القفل في الفرع `main` والوقت الذي تقوم فيه بتشغيل أمر `conda create`. يمكنك دائمًا محاولة الاطلاع على الإصدار في ملف القفل وتحديد الإصدارات يدويًا لبعض الحزم المحددة التي تعتقد أنها ستساعد في إعادة إنتاج المشكلة.
    - قد يتم تثبيت حزم مختلفة بشكل افتراضي اعتمادًا على نظام التشغيل. على سبيل المثال، مكتبة BLAS الافتراضية عند تثبيت numpy هي OpenBLAS في لينكس و MKL في ويندوز.

    أيضًا، قد تكون المشكلة خاصة بنظام التشغيل، لذا فإن الطريقة الوحيدة لتتمكن من إعادة الإنتاج هي أن يكون لديك نفس نظام التشغيل كما في بناء التكامل المستمر.

    .. highlight:: default

    تصحيح أخطاء الذاكرة في Cython باستخدام valgrind
    --------------------------------------------------
    
    (لا يوجد نص لترجمته في هذا القسم)

على الرغم من أن إدارة الذاكرة المدمجة في لغة بايثون/NumPy تعتبر قوية نسبياً، إلا أنها يمكن أن تؤدي إلى عقوبات في الأداء لبعض الروتينات. ولهذا السبب، يتم كتابة الكثير من التعليمات البرمجية عالية الأداء في scikit-learn بلغة Cython. ومع ذلك، فإن هذا المكسب في الأداء يأتي مع مقايضة: من السهل جداً ظهور أخطاء في الذاكرة في رمز Cython، خاصة في الحالات التي يعتمد فيها هذا الرمز بشكل كبير على حساب المؤشر.

يمكن أن تظهر أخطاء الذاكرة بعدة طرق. غالباً ما تكون أسهلها في التصحيح هي أخطاء تجزئة الذاكرة وأخطاء glibc ذات الصلة. يمكن أن تؤدي المتغيرات غير المبدئية إلى سلوك غير متوقع يصعب تعقبه. أداة مفيدة جداً عند تصحيح هذه الأنواع من الأخطاء هي Valgrind.

Valgrind هي أداة سطر أوامر يمكنها تتبع أخطاء الذاكرة في مجموعة متنوعة من التعليمات البرمجية. اتبع هذه الخطوات:

1. قم بتثبيت Valgrind على نظامك.

2. قم بتنزيل ملف إلغاء تنشيط Valgrind للغة بايثون: valgrind-python.supp.

3. اتبع الإرشادات الموجودة في ملف README.valgrind لتخصيص عمليات الإيقاف المؤقت لبايثون. إذا لم تقم بذلك، فستحصل على نتائج زائفة قادمة من مفسر بايثون بدلاً من الكود الخاص بك.

4. قم بتشغيل Valgrind على النحو التالي:

   ```bash
   valgrind -v --suppressions=valgrind-python.supp python my_test_script.py
   ```

سيتم عرض قائمة بجميع أخطاء الذاكرة، والتي تشير إلى سطور في رمز C الذي تم إنشاؤه بواسطة Cython من ملف .pyx الخاص بك. إذا فحصت الأسطر المشار إليها في ملف .c، فسترى التعليقات التي تشير إلى الموقع المقابل في ملف مصدر .pyx الخاص بك. نأمل أن يمنحك الإخراج أدلة حول مصدر خطأ الذاكرة الخاص بك.

لمزيد من المعلومات حول Valgrind ومجموعة الخيارات التي يوفرها، راجع البرامج التعليمية والوثائق على موقع Valgrind على الويب.

بناء واختبار منصة ARM64 على جهاز x86\_64
=======================================

تعتبر الأجهزة التي تستند إلى ARM هدفاً شائعاً للانتشار على الهاتف المحمول أو الحافة أو أي عمليات نشر أخرى منخفضة الطاقة (بما في ذلك في السحابة، على سبيل المثال على Scaleway أو AWS Graviton).

فيما يلي إرشادات لإعداد بيئة تطوير محلية لإعادة إنتاج أخطاء أو إخفاقات اختبارات خاصة بـ ARM على كمبيوتر محمول أو محطة عمل x86\_64. يعتمد هذا على محاكاة وضع مستخدم QEMU باستخدام Docker للراحة (انظر https://github.com/multiarch/qemu-user-static).

.. ملاحظة::

    تم توضيح التعليمات التالية لـ ARM64 ولكنها تنطبق أيضاً على ppc64le، بعد تغيير صورة Docker ومسارات Miniforge بشكل مناسب.

قم بإعداد مجلد على نظام ملفات المضيف وقم بتنزيل الأدوات الضرورية وكود المصدر:

.. prompt:: bash $

    mkdir arm64
    pushd arm64
    wget https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-Linux-aarch64.sh
    git clone https://github.com/scikit-learn/scikit-learn.git

استخدم Docker لتثبيت وضع مستخدم QEMU وتشغيل حاوية ARM64v8 مع الوصول إلى مجلدك المشترك تحت نقطة التثبيت "/io":

.. prompt:: bash $

    docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
    docker run -v`pwd`:/io --rm -it arm64v8/ubuntu /bin/bash

في الحاوية، قم بتثبيت miniforge3 للعمارة ARM64 (المعروفة أيضاً باسم aarch64):

.. prompt:: bash $

    bash Miniforge3-Linux-aarch64.sh
    # اختر تثبيت miniforge3 تحت: `/io/miniforge3`

في كل مرة تعيد فيها تشغيل حاوية جديدة، ستحتاج إلى إعادة تهيئة بيئة conda المثبتة مسبقاً تحت "/io/miniforge3":

.. prompt:: bash $

    /io/miniforge3/bin/conda init
    source /root/.bashrc

نظرًا لأن مجلد "/root" الرئيسي هو جزء من حاوية Docker المؤقتة. كل ملف أو دليل مخزّن تحت "/io" يكون ثابتاً من ناحية أخرى.

بعد ذلك، يمكنك بناء scikit-learn كالمعتاد (ستحتاج إلى تثبيت أدوات ومكتبات التحويل باستخدام apt أو conda كالمعتاد). يستغرق بناء scikit-learn الكثير من الوقت بسبب طبقة المحاكاة، ومع ذلك، تحتاج إلى القيام بذلك مرة واحدة فقط إذا وضعت مجلد scikit-learn تحت نقطة التثبيت "/io".

ثم استخدم pytest لتشغيل اختبارات الوحدة فقط للمعامل الذي تهتم بتصحيحه.

خلفية البناء Meson
==================

اعتباراً من scikit-learn 1.5.0، نستخدم Meson-python كأداة بناء. Meson هي أداة جديدة لـ scikit-learn ونظام PyData الإيكولوجي. يتم استخدامه من قبل العديد من الحزم الأخرى التي كتبت أدلة جيدة حول ماهيتها وكيفية عملها.

- `وثيقة إعداد pandas
  <https://pandas.pydata.org/docs/development/contributing_environment.html#step-3-build-and-install-pandas>`_:
  لديها pandas إعداد مشابه لإعدادنا (بدون spin أو dev.py)
- `وثيقة Meson في scipy
  <https://scipy.github.io/devdocs/building/understanding_meson.html>`_ تعطي المزيد من المعلومات حول كيفية عمل Meson خلف الكواليس


(لقد حافظت على تنسيق النص الأصلي قدر الإمكان، بما في ذلك استخدام المسافات للنصوص البرمجية والأوامر في سطر الأوامر، لضمان سهولة القراءة والفهم).
